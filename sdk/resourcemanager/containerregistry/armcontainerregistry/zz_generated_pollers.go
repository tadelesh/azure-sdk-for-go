//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcontainerregistry

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"net/http"
)

// AgentPoolsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type AgentPoolsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AgentPoolsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AgentPoolsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AgentPoolsClientCreateResponse will be returned.
func (p *AgentPoolsClientCreatePoller) FinalResponse(ctx context.Context) (AgentPoolsClientCreateResponse, error) {
	respType := AgentPoolsClientCreateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.AgentPool)
	if err != nil {
		return AgentPoolsClientCreateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AgentPoolsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AgentPoolsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type AgentPoolsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AgentPoolsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AgentPoolsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AgentPoolsClientDeleteResponse will be returned.
func (p *AgentPoolsClientDeletePoller) FinalResponse(ctx context.Context) (AgentPoolsClientDeleteResponse, error) {
	respType := AgentPoolsClientDeleteResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return AgentPoolsClientDeleteResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AgentPoolsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AgentPoolsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type AgentPoolsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AgentPoolsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AgentPoolsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AgentPoolsClientUpdateResponse will be returned.
func (p *AgentPoolsClientUpdatePoller) FinalResponse(ctx context.Context) (AgentPoolsClientUpdateResponse, error) {
	respType := AgentPoolsClientUpdateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.AgentPool)
	if err != nil {
		return AgentPoolsClientUpdateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AgentPoolsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ConnectedRegistriesClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type ConnectedRegistriesClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ConnectedRegistriesClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ConnectedRegistriesClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ConnectedRegistriesClientCreateResponse will be returned.
func (p *ConnectedRegistriesClientCreatePoller) FinalResponse(ctx context.Context) (ConnectedRegistriesClientCreateResponse, error) {
	respType := ConnectedRegistriesClientCreateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.ConnectedRegistry)
	if err != nil {
		return ConnectedRegistriesClientCreateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ConnectedRegistriesClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ConnectedRegistriesClientDeactivatePoller provides polling facilities until the operation reaches a terminal state.
type ConnectedRegistriesClientDeactivatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ConnectedRegistriesClientDeactivatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ConnectedRegistriesClientDeactivatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ConnectedRegistriesClientDeactivateResponse will be returned.
func (p *ConnectedRegistriesClientDeactivatePoller) FinalResponse(ctx context.Context) (ConnectedRegistriesClientDeactivateResponse, error) {
	respType := ConnectedRegistriesClientDeactivateResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ConnectedRegistriesClientDeactivateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ConnectedRegistriesClientDeactivatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ConnectedRegistriesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ConnectedRegistriesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ConnectedRegistriesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ConnectedRegistriesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ConnectedRegistriesClientDeleteResponse will be returned.
func (p *ConnectedRegistriesClientDeletePoller) FinalResponse(ctx context.Context) (ConnectedRegistriesClientDeleteResponse, error) {
	respType := ConnectedRegistriesClientDeleteResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ConnectedRegistriesClientDeleteResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ConnectedRegistriesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ConnectedRegistriesClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ConnectedRegistriesClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ConnectedRegistriesClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ConnectedRegistriesClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ConnectedRegistriesClientUpdateResponse will be returned.
func (p *ConnectedRegistriesClientUpdatePoller) FinalResponse(ctx context.Context) (ConnectedRegistriesClientUpdateResponse, error) {
	respType := ConnectedRegistriesClientUpdateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.ConnectedRegistry)
	if err != nil {
		return ConnectedRegistriesClientUpdateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ConnectedRegistriesClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExportPipelinesClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type ExportPipelinesClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExportPipelinesClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExportPipelinesClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExportPipelinesClientCreateResponse will be returned.
func (p *ExportPipelinesClientCreatePoller) FinalResponse(ctx context.Context) (ExportPipelinesClientCreateResponse, error) {
	respType := ExportPipelinesClientCreateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.ExportPipeline)
	if err != nil {
		return ExportPipelinesClientCreateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExportPipelinesClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ExportPipelinesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ExportPipelinesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ExportPipelinesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ExportPipelinesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ExportPipelinesClientDeleteResponse will be returned.
func (p *ExportPipelinesClientDeletePoller) FinalResponse(ctx context.Context) (ExportPipelinesClientDeleteResponse, error) {
	respType := ExportPipelinesClientDeleteResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ExportPipelinesClientDeleteResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ExportPipelinesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ImportPipelinesClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type ImportPipelinesClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ImportPipelinesClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ImportPipelinesClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ImportPipelinesClientCreateResponse will be returned.
func (p *ImportPipelinesClientCreatePoller) FinalResponse(ctx context.Context) (ImportPipelinesClientCreateResponse, error) {
	respType := ImportPipelinesClientCreateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.ImportPipeline)
	if err != nil {
		return ImportPipelinesClientCreateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ImportPipelinesClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ImportPipelinesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ImportPipelinesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ImportPipelinesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ImportPipelinesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ImportPipelinesClientDeleteResponse will be returned.
func (p *ImportPipelinesClientDeletePoller) FinalResponse(ctx context.Context) (ImportPipelinesClientDeleteResponse, error) {
	respType := ImportPipelinesClientDeleteResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ImportPipelinesClientDeleteResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ImportPipelinesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PipelineRunsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type PipelineRunsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PipelineRunsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PipelineRunsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PipelineRunsClientCreateResponse will be returned.
func (p *PipelineRunsClientCreatePoller) FinalResponse(ctx context.Context) (PipelineRunsClientCreateResponse, error) {
	respType := PipelineRunsClientCreateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.PipelineRun)
	if err != nil {
		return PipelineRunsClientCreateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PipelineRunsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PipelineRunsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type PipelineRunsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PipelineRunsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PipelineRunsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PipelineRunsClientDeleteResponse will be returned.
func (p *PipelineRunsClientDeletePoller) FinalResponse(ctx context.Context) (PipelineRunsClientDeleteResponse, error) {
	respType := PipelineRunsClientDeleteResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PipelineRunsClientDeleteResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PipelineRunsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateEndpointConnectionsClientCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointConnectionsClientCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateEndpointConnectionsClientCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateEndpointConnectionsClientCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateEndpointConnectionsClientCreateOrUpdateResponse will be returned.
func (p *PrivateEndpointConnectionsClientCreateOrUpdatePoller) FinalResponse(ctx context.Context) (PrivateEndpointConnectionsClientCreateOrUpdateResponse, error) {
	respType := PrivateEndpointConnectionsClientCreateOrUpdateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.PrivateEndpointConnection)
	if err != nil {
		return PrivateEndpointConnectionsClientCreateOrUpdateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateEndpointConnectionsClientCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// PrivateEndpointConnectionsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type PrivateEndpointConnectionsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *PrivateEndpointConnectionsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *PrivateEndpointConnectionsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final PrivateEndpointConnectionsClientDeleteResponse will be returned.
func (p *PrivateEndpointConnectionsClientDeletePoller) FinalResponse(ctx context.Context) (PrivateEndpointConnectionsClientDeleteResponse, error) {
	respType := PrivateEndpointConnectionsClientDeleteResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return PrivateEndpointConnectionsClientDeleteResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *PrivateEndpointConnectionsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RegistriesClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type RegistriesClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RegistriesClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RegistriesClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RegistriesClientCreateResponse will be returned.
func (p *RegistriesClientCreatePoller) FinalResponse(ctx context.Context) (RegistriesClientCreateResponse, error) {
	respType := RegistriesClientCreateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.Registry)
	if err != nil {
		return RegistriesClientCreateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RegistriesClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RegistriesClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type RegistriesClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RegistriesClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RegistriesClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RegistriesClientDeleteResponse will be returned.
func (p *RegistriesClientDeletePoller) FinalResponse(ctx context.Context) (RegistriesClientDeleteResponse, error) {
	respType := RegistriesClientDeleteResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return RegistriesClientDeleteResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RegistriesClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RegistriesClientGenerateCredentialsPoller provides polling facilities until the operation reaches a terminal state.
type RegistriesClientGenerateCredentialsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RegistriesClientGenerateCredentialsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RegistriesClientGenerateCredentialsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RegistriesClientGenerateCredentialsResponse will be returned.
func (p *RegistriesClientGenerateCredentialsPoller) FinalResponse(ctx context.Context) (RegistriesClientGenerateCredentialsResponse, error) {
	respType := RegistriesClientGenerateCredentialsResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.GenerateCredentialsResult)
	if err != nil {
		return RegistriesClientGenerateCredentialsResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RegistriesClientGenerateCredentialsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RegistriesClientImportImagePoller provides polling facilities until the operation reaches a terminal state.
type RegistriesClientImportImagePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RegistriesClientImportImagePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RegistriesClientImportImagePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RegistriesClientImportImageResponse will be returned.
func (p *RegistriesClientImportImagePoller) FinalResponse(ctx context.Context) (RegistriesClientImportImageResponse, error) {
	respType := RegistriesClientImportImageResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return RegistriesClientImportImageResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RegistriesClientImportImagePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RegistriesClientScheduleRunPoller provides polling facilities until the operation reaches a terminal state.
type RegistriesClientScheduleRunPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RegistriesClientScheduleRunPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RegistriesClientScheduleRunPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RegistriesClientScheduleRunResponse will be returned.
func (p *RegistriesClientScheduleRunPoller) FinalResponse(ctx context.Context) (RegistriesClientScheduleRunResponse, error) {
	respType := RegistriesClientScheduleRunResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.Run)
	if err != nil {
		return RegistriesClientScheduleRunResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RegistriesClientScheduleRunPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RegistriesClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type RegistriesClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RegistriesClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RegistriesClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RegistriesClientUpdateResponse will be returned.
func (p *RegistriesClientUpdatePoller) FinalResponse(ctx context.Context) (RegistriesClientUpdateResponse, error) {
	respType := RegistriesClientUpdateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.Registry)
	if err != nil {
		return RegistriesClientUpdateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RegistriesClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationsClientCreateResponse will be returned.
func (p *ReplicationsClientCreatePoller) FinalResponse(ctx context.Context) (ReplicationsClientCreateResponse, error) {
	respType := ReplicationsClientCreateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.Replication)
	if err != nil {
		return ReplicationsClientCreateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationsClientDeleteResponse will be returned.
func (p *ReplicationsClientDeletePoller) FinalResponse(ctx context.Context) (ReplicationsClientDeleteResponse, error) {
	respType := ReplicationsClientDeleteResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ReplicationsClientDeleteResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ReplicationsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ReplicationsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ReplicationsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ReplicationsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ReplicationsClientUpdateResponse will be returned.
func (p *ReplicationsClientUpdatePoller) FinalResponse(ctx context.Context) (ReplicationsClientUpdateResponse, error) {
	respType := ReplicationsClientUpdateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.Replication)
	if err != nil {
		return ReplicationsClientUpdateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ReplicationsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RunsClientCancelPoller provides polling facilities until the operation reaches a terminal state.
type RunsClientCancelPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RunsClientCancelPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RunsClientCancelPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RunsClientCancelResponse will be returned.
func (p *RunsClientCancelPoller) FinalResponse(ctx context.Context) (RunsClientCancelResponse, error) {
	respType := RunsClientCancelResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return RunsClientCancelResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RunsClientCancelPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// RunsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type RunsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *RunsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *RunsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final RunsClientUpdateResponse will be returned.
func (p *RunsClientUpdatePoller) FinalResponse(ctx context.Context) (RunsClientUpdateResponse, error) {
	respType := RunsClientUpdateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.Run)
	if err != nil {
		return RunsClientUpdateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *RunsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ScopeMapsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type ScopeMapsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ScopeMapsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ScopeMapsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ScopeMapsClientCreateResponse will be returned.
func (p *ScopeMapsClientCreatePoller) FinalResponse(ctx context.Context) (ScopeMapsClientCreateResponse, error) {
	respType := ScopeMapsClientCreateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.ScopeMap)
	if err != nil {
		return ScopeMapsClientCreateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ScopeMapsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ScopeMapsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type ScopeMapsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ScopeMapsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ScopeMapsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ScopeMapsClientDeleteResponse will be returned.
func (p *ScopeMapsClientDeletePoller) FinalResponse(ctx context.Context) (ScopeMapsClientDeleteResponse, error) {
	respType := ScopeMapsClientDeleteResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return ScopeMapsClientDeleteResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ScopeMapsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// ScopeMapsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type ScopeMapsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *ScopeMapsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *ScopeMapsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final ScopeMapsClientUpdateResponse will be returned.
func (p *ScopeMapsClientUpdatePoller) FinalResponse(ctx context.Context) (ScopeMapsClientUpdateResponse, error) {
	respType := ScopeMapsClientUpdateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.ScopeMap)
	if err != nil {
		return ScopeMapsClientUpdateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *ScopeMapsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TaskRunsClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type TaskRunsClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TaskRunsClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TaskRunsClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TaskRunsClientCreateResponse will be returned.
func (p *TaskRunsClientCreatePoller) FinalResponse(ctx context.Context) (TaskRunsClientCreateResponse, error) {
	respType := TaskRunsClientCreateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.TaskRun)
	if err != nil {
		return TaskRunsClientCreateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TaskRunsClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TaskRunsClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type TaskRunsClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TaskRunsClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TaskRunsClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TaskRunsClientDeleteResponse will be returned.
func (p *TaskRunsClientDeletePoller) FinalResponse(ctx context.Context) (TaskRunsClientDeleteResponse, error) {
	respType := TaskRunsClientDeleteResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return TaskRunsClientDeleteResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TaskRunsClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TaskRunsClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type TaskRunsClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TaskRunsClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TaskRunsClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TaskRunsClientUpdateResponse will be returned.
func (p *TaskRunsClientUpdatePoller) FinalResponse(ctx context.Context) (TaskRunsClientUpdateResponse, error) {
	respType := TaskRunsClientUpdateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.TaskRun)
	if err != nil {
		return TaskRunsClientUpdateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TaskRunsClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TasksClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type TasksClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TasksClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TasksClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TasksClientCreateResponse will be returned.
func (p *TasksClientCreatePoller) FinalResponse(ctx context.Context) (TasksClientCreateResponse, error) {
	respType := TasksClientCreateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.Task)
	if err != nil {
		return TasksClientCreateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TasksClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TasksClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type TasksClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TasksClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TasksClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TasksClientDeleteResponse will be returned.
func (p *TasksClientDeletePoller) FinalResponse(ctx context.Context) (TasksClientDeleteResponse, error) {
	respType := TasksClientDeleteResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return TasksClientDeleteResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TasksClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TasksClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type TasksClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TasksClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TasksClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TasksClientUpdateResponse will be returned.
func (p *TasksClientUpdatePoller) FinalResponse(ctx context.Context) (TasksClientUpdateResponse, error) {
	respType := TasksClientUpdateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.Task)
	if err != nil {
		return TasksClientUpdateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TasksClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TokensClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type TokensClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TokensClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TokensClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TokensClientCreateResponse will be returned.
func (p *TokensClientCreatePoller) FinalResponse(ctx context.Context) (TokensClientCreateResponse, error) {
	respType := TokensClientCreateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.Token)
	if err != nil {
		return TokensClientCreateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TokensClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TokensClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type TokensClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TokensClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TokensClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TokensClientDeleteResponse will be returned.
func (p *TokensClientDeletePoller) FinalResponse(ctx context.Context) (TokensClientDeleteResponse, error) {
	respType := TokensClientDeleteResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return TokensClientDeleteResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TokensClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// TokensClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type TokensClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *TokensClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *TokensClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final TokensClientUpdateResponse will be returned.
func (p *TokensClientUpdatePoller) FinalResponse(ctx context.Context) (TokensClientUpdateResponse, error) {
	respType := TokensClientUpdateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.Token)
	if err != nil {
		return TokensClientUpdateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *TokensClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WebhooksClientCreatePoller provides polling facilities until the operation reaches a terminal state.
type WebhooksClientCreatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WebhooksClientCreatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WebhooksClientCreatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WebhooksClientCreateResponse will be returned.
func (p *WebhooksClientCreatePoller) FinalResponse(ctx context.Context) (WebhooksClientCreateResponse, error) {
	respType := WebhooksClientCreateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.Webhook)
	if err != nil {
		return WebhooksClientCreateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WebhooksClientCreatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WebhooksClientDeletePoller provides polling facilities until the operation reaches a terminal state.
type WebhooksClientDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WebhooksClientDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WebhooksClientDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WebhooksClientDeleteResponse will be returned.
func (p *WebhooksClientDeletePoller) FinalResponse(ctx context.Context) (WebhooksClientDeleteResponse, error) {
	respType := WebhooksClientDeleteResponse{}
	_, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return WebhooksClientDeleteResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WebhooksClientDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// WebhooksClientUpdatePoller provides polling facilities until the operation reaches a terminal state.
type WebhooksClientUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *WebhooksClientUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *WebhooksClientUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final WebhooksClientUpdateResponse will be returned.
func (p *WebhooksClientUpdatePoller) FinalResponse(ctx context.Context) (WebhooksClientUpdateResponse, error) {
	respType := WebhooksClientUpdateResponse{}
	_, err := p.pt.FinalResponse(ctx, &respType.Webhook)
	if err != nil {
		return WebhooksClientUpdateResponse{}, err
	}
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *WebhooksClientUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}
