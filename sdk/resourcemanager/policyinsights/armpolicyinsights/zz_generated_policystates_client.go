//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armpolicyinsights

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// PolicyStatesClient contains the methods for the PolicyStates group.
// Don't use this type directly, use NewPolicyStatesClient() instead.
type PolicyStatesClient struct {
	host string
	pl   runtime.Pipeline
}

// NewPolicyStatesClient creates a new instance of PolicyStatesClient with the specified values.
// credential - used to authorize requests. Usually a credential from azidentity.
// options - pass nil to accept the default values.
func NewPolicyStatesClient(credential azcore.TokenCredential, options *arm.ClientOptions) *PolicyStatesClient {
	if options == nil {
		options = &arm.ClientOptions{}
	}
	ep := options.Endpoint
	if len(ep) == 0 {
		ep = arm.AzurePublicCloud
	}
	client := &PolicyStatesClient{
		host: string(ep),
		pl:   armruntime.NewPipeline(moduleName, moduleVersion, credential, runtime.PipelineOptions{}, options),
	}
	return client
}

// ListQueryResultsForManagementGroup - Queries policy states for the resources under the management group.
// If the operation fails it returns an *azcore.ResponseError type.
// policyStatesResource - The virtual resource under PolicyStates resource type. In a given time range, 'latest' represents
// the latest policy state(s), whereas 'default' represents all policy state(s).
// managementGroupsNamespace - The namespace for Microsoft Management RP; only "Microsoft.Management" is allowed.
// managementGroupName - Management group name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyStatesClient) ListQueryResultsForManagementGroup(policyStatesResource PolicyStatesResource, managementGroupsNamespace Enum0, managementGroupName string, options *QueryOptions) *runtime.Pager[PolicyStatesClientListQueryResultsForManagementGroupResponse] {
	return runtime.NewPager(runtime.PageProcessor[PolicyStatesClientListQueryResultsForManagementGroupResponse]{
		More: func(page PolicyStatesClientListQueryResultsForManagementGroupResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PolicyStatesClientListQueryResultsForManagementGroupResponse) (PolicyStatesClientListQueryResultsForManagementGroupResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listQueryResultsForManagementGroupCreateRequest(ctx, policyStatesResource, managementGroupsNamespace, managementGroupName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.ODataNextLink)
			}
			if err != nil {
				return PolicyStatesClientListQueryResultsForManagementGroupResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return PolicyStatesClientListQueryResultsForManagementGroupResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return PolicyStatesClientListQueryResultsForManagementGroupResponse{}, runtime.NewResponseError(resp)
			}
			return client.listQueryResultsForManagementGroupHandleResponse(resp)
		},
	})
}

// listQueryResultsForManagementGroupCreateRequest creates the ListQueryResultsForManagementGroup request.
func (client *PolicyStatesClient) listQueryResultsForManagementGroupCreateRequest(ctx context.Context, policyStatesResource PolicyStatesResource, managementGroupsNamespace Enum0, managementGroupName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/providers/{managementGroupsNamespace}/managementGroups/{managementGroupName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesResource}/queryResults"
	if policyStatesResource == "" {
		return nil, errors.New("parameter policyStatesResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyStatesResource}", url.PathEscape(string(policyStatesResource)))
	if managementGroupsNamespace == "" {
		return nil, errors.New("parameter managementGroupsNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupsNamespace}", url.PathEscape(string(managementGroupsNamespace)))
	if managementGroupName == "" {
		return nil, errors.New("parameter managementGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupName}", url.PathEscape(managementGroupName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForManagementGroupHandleResponse handles the ListQueryResultsForManagementGroup response.
func (client *PolicyStatesClient) listQueryResultsForManagementGroupHandleResponse(resp *http.Response) (PolicyStatesClientListQueryResultsForManagementGroupResponse, error) {
	result := PolicyStatesClientListQueryResultsForManagementGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyStatesQueryResults); err != nil {
		return PolicyStatesClientListQueryResultsForManagementGroupResponse{}, err
	}
	return result, nil
}

// ListQueryResultsForPolicyDefinition - Queries policy states for the subscription level policy definition.
// If the operation fails it returns an *azcore.ResponseError type.
// policyStatesResource - The virtual resource under PolicyStates resource type. In a given time range, 'latest' represents
// the latest policy state(s), whereas 'default' represents all policy state(s).
// subscriptionID - Microsoft Azure subscription ID.
// authorizationNamespace - The namespace for Microsoft Authorization resource provider; only "Microsoft.Authorization" is
// allowed.
// policyDefinitionName - Policy definition name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyStatesClient) ListQueryResultsForPolicyDefinition(policyStatesResource PolicyStatesResource, subscriptionID string, authorizationNamespace Enum4, policyDefinitionName string, options *QueryOptions) *runtime.Pager[PolicyStatesClientListQueryResultsForPolicyDefinitionResponse] {
	return runtime.NewPager(runtime.PageProcessor[PolicyStatesClientListQueryResultsForPolicyDefinitionResponse]{
		More: func(page PolicyStatesClientListQueryResultsForPolicyDefinitionResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PolicyStatesClientListQueryResultsForPolicyDefinitionResponse) (PolicyStatesClientListQueryResultsForPolicyDefinitionResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listQueryResultsForPolicyDefinitionCreateRequest(ctx, policyStatesResource, subscriptionID, authorizationNamespace, policyDefinitionName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.ODataNextLink)
			}
			if err != nil {
				return PolicyStatesClientListQueryResultsForPolicyDefinitionResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return PolicyStatesClientListQueryResultsForPolicyDefinitionResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return PolicyStatesClientListQueryResultsForPolicyDefinitionResponse{}, runtime.NewResponseError(resp)
			}
			return client.listQueryResultsForPolicyDefinitionHandleResponse(resp)
		},
	})
}

// listQueryResultsForPolicyDefinitionCreateRequest creates the ListQueryResultsForPolicyDefinition request.
func (client *PolicyStatesClient) listQueryResultsForPolicyDefinitionCreateRequest(ctx context.Context, policyStatesResource PolicyStatesResource, subscriptionID string, authorizationNamespace Enum4, policyDefinitionName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/{authorizationNamespace}/policyDefinitions/{policyDefinitionName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesResource}/queryResults"
	if policyStatesResource == "" {
		return nil, errors.New("parameter policyStatesResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyStatesResource}", url.PathEscape(string(policyStatesResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	if authorizationNamespace == "" {
		return nil, errors.New("parameter authorizationNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{authorizationNamespace}", url.PathEscape(string(authorizationNamespace)))
	if policyDefinitionName == "" {
		return nil, errors.New("parameter policyDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyDefinitionName}", url.PathEscape(policyDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForPolicyDefinitionHandleResponse handles the ListQueryResultsForPolicyDefinition response.
func (client *PolicyStatesClient) listQueryResultsForPolicyDefinitionHandleResponse(resp *http.Response) (PolicyStatesClientListQueryResultsForPolicyDefinitionResponse, error) {
	result := PolicyStatesClientListQueryResultsForPolicyDefinitionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyStatesQueryResults); err != nil {
		return PolicyStatesClientListQueryResultsForPolicyDefinitionResponse{}, err
	}
	return result, nil
}

// ListQueryResultsForPolicySetDefinition - Queries policy states for the subscription level policy set definition.
// If the operation fails it returns an *azcore.ResponseError type.
// policyStatesResource - The virtual resource under PolicyStates resource type. In a given time range, 'latest' represents
// the latest policy state(s), whereas 'default' represents all policy state(s).
// subscriptionID - Microsoft Azure subscription ID.
// authorizationNamespace - The namespace for Microsoft Authorization resource provider; only "Microsoft.Authorization" is
// allowed.
// policySetDefinitionName - Policy set definition name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyStatesClient) ListQueryResultsForPolicySetDefinition(policyStatesResource PolicyStatesResource, subscriptionID string, authorizationNamespace Enum4, policySetDefinitionName string, options *QueryOptions) *runtime.Pager[PolicyStatesClientListQueryResultsForPolicySetDefinitionResponse] {
	return runtime.NewPager(runtime.PageProcessor[PolicyStatesClientListQueryResultsForPolicySetDefinitionResponse]{
		More: func(page PolicyStatesClientListQueryResultsForPolicySetDefinitionResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PolicyStatesClientListQueryResultsForPolicySetDefinitionResponse) (PolicyStatesClientListQueryResultsForPolicySetDefinitionResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listQueryResultsForPolicySetDefinitionCreateRequest(ctx, policyStatesResource, subscriptionID, authorizationNamespace, policySetDefinitionName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.ODataNextLink)
			}
			if err != nil {
				return PolicyStatesClientListQueryResultsForPolicySetDefinitionResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return PolicyStatesClientListQueryResultsForPolicySetDefinitionResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return PolicyStatesClientListQueryResultsForPolicySetDefinitionResponse{}, runtime.NewResponseError(resp)
			}
			return client.listQueryResultsForPolicySetDefinitionHandleResponse(resp)
		},
	})
}

// listQueryResultsForPolicySetDefinitionCreateRequest creates the ListQueryResultsForPolicySetDefinition request.
func (client *PolicyStatesClient) listQueryResultsForPolicySetDefinitionCreateRequest(ctx context.Context, policyStatesResource PolicyStatesResource, subscriptionID string, authorizationNamespace Enum4, policySetDefinitionName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/{authorizationNamespace}/policySetDefinitions/{policySetDefinitionName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesResource}/queryResults"
	if policyStatesResource == "" {
		return nil, errors.New("parameter policyStatesResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyStatesResource}", url.PathEscape(string(policyStatesResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	if authorizationNamespace == "" {
		return nil, errors.New("parameter authorizationNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{authorizationNamespace}", url.PathEscape(string(authorizationNamespace)))
	if policySetDefinitionName == "" {
		return nil, errors.New("parameter policySetDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policySetDefinitionName}", url.PathEscape(policySetDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForPolicySetDefinitionHandleResponse handles the ListQueryResultsForPolicySetDefinition response.
func (client *PolicyStatesClient) listQueryResultsForPolicySetDefinitionHandleResponse(resp *http.Response) (PolicyStatesClientListQueryResultsForPolicySetDefinitionResponse, error) {
	result := PolicyStatesClientListQueryResultsForPolicySetDefinitionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyStatesQueryResults); err != nil {
		return PolicyStatesClientListQueryResultsForPolicySetDefinitionResponse{}, err
	}
	return result, nil
}

// ListQueryResultsForResource - Queries policy states for the resource.
// If the operation fails it returns an *azcore.ResponseError type.
// policyStatesResource - The virtual resource under PolicyStates resource type. In a given time range, 'latest' represents
// the latest policy state(s), whereas 'default' represents all policy state(s).
// resourceID - Resource ID.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyStatesClient) ListQueryResultsForResource(policyStatesResource PolicyStatesResource, resourceID string, options *QueryOptions) *runtime.Pager[PolicyStatesClientListQueryResultsForResourceResponse] {
	return runtime.NewPager(runtime.PageProcessor[PolicyStatesClientListQueryResultsForResourceResponse]{
		More: func(page PolicyStatesClientListQueryResultsForResourceResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PolicyStatesClientListQueryResultsForResourceResponse) (PolicyStatesClientListQueryResultsForResourceResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listQueryResultsForResourceCreateRequest(ctx, policyStatesResource, resourceID, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.ODataNextLink)
			}
			if err != nil {
				return PolicyStatesClientListQueryResultsForResourceResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return PolicyStatesClientListQueryResultsForResourceResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return PolicyStatesClientListQueryResultsForResourceResponse{}, runtime.NewResponseError(resp)
			}
			return client.listQueryResultsForResourceHandleResponse(resp)
		},
	})
}

// listQueryResultsForResourceCreateRequest creates the ListQueryResultsForResource request.
func (client *PolicyStatesClient) listQueryResultsForResourceCreateRequest(ctx context.Context, policyStatesResource PolicyStatesResource, resourceID string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/{resourceId}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesResource}/queryResults"
	if policyStatesResource == "" {
		return nil, errors.New("parameter policyStatesResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyStatesResource}", url.PathEscape(string(policyStatesResource)))
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceID)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", *options.Expand)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForResourceHandleResponse handles the ListQueryResultsForResource response.
func (client *PolicyStatesClient) listQueryResultsForResourceHandleResponse(resp *http.Response) (PolicyStatesClientListQueryResultsForResourceResponse, error) {
	result := PolicyStatesClientListQueryResultsForResourceResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyStatesQueryResults); err != nil {
		return PolicyStatesClientListQueryResultsForResourceResponse{}, err
	}
	return result, nil
}

// ListQueryResultsForResourceGroup - Queries policy states for the resources under the resource group.
// If the operation fails it returns an *azcore.ResponseError type.
// policyStatesResource - The virtual resource under PolicyStates resource type. In a given time range, 'latest' represents
// the latest policy state(s), whereas 'default' represents all policy state(s).
// subscriptionID - Microsoft Azure subscription ID.
// resourceGroupName - Resource group name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyStatesClient) ListQueryResultsForResourceGroup(policyStatesResource PolicyStatesResource, subscriptionID string, resourceGroupName string, options *QueryOptions) *runtime.Pager[PolicyStatesClientListQueryResultsForResourceGroupResponse] {
	return runtime.NewPager(runtime.PageProcessor[PolicyStatesClientListQueryResultsForResourceGroupResponse]{
		More: func(page PolicyStatesClientListQueryResultsForResourceGroupResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PolicyStatesClientListQueryResultsForResourceGroupResponse) (PolicyStatesClientListQueryResultsForResourceGroupResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listQueryResultsForResourceGroupCreateRequest(ctx, policyStatesResource, subscriptionID, resourceGroupName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.ODataNextLink)
			}
			if err != nil {
				return PolicyStatesClientListQueryResultsForResourceGroupResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return PolicyStatesClientListQueryResultsForResourceGroupResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return PolicyStatesClientListQueryResultsForResourceGroupResponse{}, runtime.NewResponseError(resp)
			}
			return client.listQueryResultsForResourceGroupHandleResponse(resp)
		},
	})
}

// listQueryResultsForResourceGroupCreateRequest creates the ListQueryResultsForResourceGroup request.
func (client *PolicyStatesClient) listQueryResultsForResourceGroupCreateRequest(ctx context.Context, policyStatesResource PolicyStatesResource, subscriptionID string, resourceGroupName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesResource}/queryResults"
	if policyStatesResource == "" {
		return nil, errors.New("parameter policyStatesResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyStatesResource}", url.PathEscape(string(policyStatesResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForResourceGroupHandleResponse handles the ListQueryResultsForResourceGroup response.
func (client *PolicyStatesClient) listQueryResultsForResourceGroupHandleResponse(resp *http.Response) (PolicyStatesClientListQueryResultsForResourceGroupResponse, error) {
	result := PolicyStatesClientListQueryResultsForResourceGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyStatesQueryResults); err != nil {
		return PolicyStatesClientListQueryResultsForResourceGroupResponse{}, err
	}
	return result, nil
}

// ListQueryResultsForResourceGroupLevelPolicyAssignment - Queries policy states for the resource group level policy assignment.
// If the operation fails it returns an *azcore.ResponseError type.
// policyStatesResource - The virtual resource under PolicyStates resource type. In a given time range, 'latest' represents
// the latest policy state(s), whereas 'default' represents all policy state(s).
// subscriptionID - Microsoft Azure subscription ID.
// resourceGroupName - Resource group name.
// authorizationNamespace - The namespace for Microsoft Authorization resource provider; only "Microsoft.Authorization" is
// allowed.
// policyAssignmentName - Policy assignment name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyStatesClient) ListQueryResultsForResourceGroupLevelPolicyAssignment(policyStatesResource PolicyStatesResource, subscriptionID string, resourceGroupName string, authorizationNamespace Enum4, policyAssignmentName string, options *QueryOptions) *runtime.Pager[PolicyStatesClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse] {
	return runtime.NewPager(runtime.PageProcessor[PolicyStatesClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse]{
		More: func(page PolicyStatesClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PolicyStatesClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse) (PolicyStatesClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listQueryResultsForResourceGroupLevelPolicyAssignmentCreateRequest(ctx, policyStatesResource, subscriptionID, resourceGroupName, authorizationNamespace, policyAssignmentName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.ODataNextLink)
			}
			if err != nil {
				return PolicyStatesClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return PolicyStatesClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return PolicyStatesClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse{}, runtime.NewResponseError(resp)
			}
			return client.listQueryResultsForResourceGroupLevelPolicyAssignmentHandleResponse(resp)
		},
	})
}

// listQueryResultsForResourceGroupLevelPolicyAssignmentCreateRequest creates the ListQueryResultsForResourceGroupLevelPolicyAssignment request.
func (client *PolicyStatesClient) listQueryResultsForResourceGroupLevelPolicyAssignmentCreateRequest(ctx context.Context, policyStatesResource PolicyStatesResource, subscriptionID string, resourceGroupName string, authorizationNamespace Enum4, policyAssignmentName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{authorizationNamespace}/policyAssignments/{policyAssignmentName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesResource}/queryResults"
	if policyStatesResource == "" {
		return nil, errors.New("parameter policyStatesResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyStatesResource}", url.PathEscape(string(policyStatesResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if authorizationNamespace == "" {
		return nil, errors.New("parameter authorizationNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{authorizationNamespace}", url.PathEscape(string(authorizationNamespace)))
	if policyAssignmentName == "" {
		return nil, errors.New("parameter policyAssignmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyAssignmentName}", url.PathEscape(policyAssignmentName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForResourceGroupLevelPolicyAssignmentHandleResponse handles the ListQueryResultsForResourceGroupLevelPolicyAssignment response.
func (client *PolicyStatesClient) listQueryResultsForResourceGroupLevelPolicyAssignmentHandleResponse(resp *http.Response) (PolicyStatesClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse, error) {
	result := PolicyStatesClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyStatesQueryResults); err != nil {
		return PolicyStatesClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse{}, err
	}
	return result, nil
}

// ListQueryResultsForSubscription - Queries policy states for the resources under the subscription.
// If the operation fails it returns an *azcore.ResponseError type.
// policyStatesResource - The virtual resource under PolicyStates resource type. In a given time range, 'latest' represents
// the latest policy state(s), whereas 'default' represents all policy state(s).
// subscriptionID - Microsoft Azure subscription ID.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyStatesClient) ListQueryResultsForSubscription(policyStatesResource PolicyStatesResource, subscriptionID string, options *QueryOptions) *runtime.Pager[PolicyStatesClientListQueryResultsForSubscriptionResponse] {
	return runtime.NewPager(runtime.PageProcessor[PolicyStatesClientListQueryResultsForSubscriptionResponse]{
		More: func(page PolicyStatesClientListQueryResultsForSubscriptionResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PolicyStatesClientListQueryResultsForSubscriptionResponse) (PolicyStatesClientListQueryResultsForSubscriptionResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listQueryResultsForSubscriptionCreateRequest(ctx, policyStatesResource, subscriptionID, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.ODataNextLink)
			}
			if err != nil {
				return PolicyStatesClientListQueryResultsForSubscriptionResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return PolicyStatesClientListQueryResultsForSubscriptionResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return PolicyStatesClientListQueryResultsForSubscriptionResponse{}, runtime.NewResponseError(resp)
			}
			return client.listQueryResultsForSubscriptionHandleResponse(resp)
		},
	})
}

// listQueryResultsForSubscriptionCreateRequest creates the ListQueryResultsForSubscription request.
func (client *PolicyStatesClient) listQueryResultsForSubscriptionCreateRequest(ctx context.Context, policyStatesResource PolicyStatesResource, subscriptionID string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesResource}/queryResults"
	if policyStatesResource == "" {
		return nil, errors.New("parameter policyStatesResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyStatesResource}", url.PathEscape(string(policyStatesResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForSubscriptionHandleResponse handles the ListQueryResultsForSubscription response.
func (client *PolicyStatesClient) listQueryResultsForSubscriptionHandleResponse(resp *http.Response) (PolicyStatesClientListQueryResultsForSubscriptionResponse, error) {
	result := PolicyStatesClientListQueryResultsForSubscriptionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyStatesQueryResults); err != nil {
		return PolicyStatesClientListQueryResultsForSubscriptionResponse{}, err
	}
	return result, nil
}

// ListQueryResultsForSubscriptionLevelPolicyAssignment - Queries policy states for the subscription level policy assignment.
// If the operation fails it returns an *azcore.ResponseError type.
// policyStatesResource - The virtual resource under PolicyStates resource type. In a given time range, 'latest' represents
// the latest policy state(s), whereas 'default' represents all policy state(s).
// subscriptionID - Microsoft Azure subscription ID.
// authorizationNamespace - The namespace for Microsoft Authorization resource provider; only "Microsoft.Authorization" is
// allowed.
// policyAssignmentName - Policy assignment name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyStatesClient) ListQueryResultsForSubscriptionLevelPolicyAssignment(policyStatesResource PolicyStatesResource, subscriptionID string, authorizationNamespace Enum4, policyAssignmentName string, options *QueryOptions) *runtime.Pager[PolicyStatesClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse] {
	return runtime.NewPager(runtime.PageProcessor[PolicyStatesClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse]{
		More: func(page PolicyStatesClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PolicyStatesClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse) (PolicyStatesClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listQueryResultsForSubscriptionLevelPolicyAssignmentCreateRequest(ctx, policyStatesResource, subscriptionID, authorizationNamespace, policyAssignmentName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.ODataNextLink)
			}
			if err != nil {
				return PolicyStatesClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return PolicyStatesClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return PolicyStatesClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse{}, runtime.NewResponseError(resp)
			}
			return client.listQueryResultsForSubscriptionLevelPolicyAssignmentHandleResponse(resp)
		},
	})
}

// listQueryResultsForSubscriptionLevelPolicyAssignmentCreateRequest creates the ListQueryResultsForSubscriptionLevelPolicyAssignment request.
func (client *PolicyStatesClient) listQueryResultsForSubscriptionLevelPolicyAssignmentCreateRequest(ctx context.Context, policyStatesResource PolicyStatesResource, subscriptionID string, authorizationNamespace Enum4, policyAssignmentName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/{authorizationNamespace}/policyAssignments/{policyAssignmentName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesResource}/queryResults"
	if policyStatesResource == "" {
		return nil, errors.New("parameter policyStatesResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyStatesResource}", url.PathEscape(string(policyStatesResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	if authorizationNamespace == "" {
		return nil, errors.New("parameter authorizationNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{authorizationNamespace}", url.PathEscape(string(authorizationNamespace)))
	if policyAssignmentName == "" {
		return nil, errors.New("parameter policyAssignmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyAssignmentName}", url.PathEscape(policyAssignmentName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForSubscriptionLevelPolicyAssignmentHandleResponse handles the ListQueryResultsForSubscriptionLevelPolicyAssignment response.
func (client *PolicyStatesClient) listQueryResultsForSubscriptionLevelPolicyAssignmentHandleResponse(resp *http.Response) (PolicyStatesClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse, error) {
	result := PolicyStatesClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyStatesQueryResults); err != nil {
		return PolicyStatesClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse{}, err
	}
	return result, nil
}

// SummarizeForManagementGroup - Summarizes policy states for the resources under the management group.
// If the operation fails it returns an *azcore.ResponseError type.
// policyStatesSummaryResource - The virtual resource under PolicyStates resource type for summarize action. In a given time
// range, 'latest' represents the latest policy state(s) and is the only allowed value.
// managementGroupsNamespace - The namespace for Microsoft Management RP; only "Microsoft.Management" is allowed.
// managementGroupName - Management group name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyStatesClient) SummarizeForManagementGroup(ctx context.Context, policyStatesSummaryResource Enum6, managementGroupsNamespace Enum0, managementGroupName string, options *QueryOptions) (PolicyStatesClientSummarizeForManagementGroupResponse, error) {
	req, err := client.summarizeForManagementGroupCreateRequest(ctx, policyStatesSummaryResource, managementGroupsNamespace, managementGroupName, options)
	if err != nil {
		return PolicyStatesClientSummarizeForManagementGroupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PolicyStatesClientSummarizeForManagementGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PolicyStatesClientSummarizeForManagementGroupResponse{}, runtime.NewResponseError(resp)
	}
	return client.summarizeForManagementGroupHandleResponse(resp)
}

// summarizeForManagementGroupCreateRequest creates the SummarizeForManagementGroup request.
func (client *PolicyStatesClient) summarizeForManagementGroupCreateRequest(ctx context.Context, policyStatesSummaryResource Enum6, managementGroupsNamespace Enum0, managementGroupName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/providers/{managementGroupsNamespace}/managementGroups/{managementGroupName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesSummaryResource}/summarize"
	if policyStatesSummaryResource == "" {
		return nil, errors.New("parameter policyStatesSummaryResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyStatesSummaryResource}", url.PathEscape(string(policyStatesSummaryResource)))
	if managementGroupsNamespace == "" {
		return nil, errors.New("parameter managementGroupsNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupsNamespace}", url.PathEscape(string(managementGroupsNamespace)))
	if managementGroupName == "" {
		return nil, errors.New("parameter managementGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupName}", url.PathEscape(managementGroupName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// summarizeForManagementGroupHandleResponse handles the SummarizeForManagementGroup response.
func (client *PolicyStatesClient) summarizeForManagementGroupHandleResponse(resp *http.Response) (PolicyStatesClientSummarizeForManagementGroupResponse, error) {
	result := PolicyStatesClientSummarizeForManagementGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SummarizeResults); err != nil {
		return PolicyStatesClientSummarizeForManagementGroupResponse{}, err
	}
	return result, nil
}

// SummarizeForPolicyDefinition - Summarizes policy states for the subscription level policy definition.
// If the operation fails it returns an *azcore.ResponseError type.
// policyStatesSummaryResource - The virtual resource under PolicyStates resource type for summarize action. In a given time
// range, 'latest' represents the latest policy state(s) and is the only allowed value.
// subscriptionID - Microsoft Azure subscription ID.
// authorizationNamespace - The namespace for Microsoft Authorization resource provider; only "Microsoft.Authorization" is
// allowed.
// policyDefinitionName - Policy definition name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyStatesClient) SummarizeForPolicyDefinition(ctx context.Context, policyStatesSummaryResource Enum6, subscriptionID string, authorizationNamespace Enum4, policyDefinitionName string, options *QueryOptions) (PolicyStatesClientSummarizeForPolicyDefinitionResponse, error) {
	req, err := client.summarizeForPolicyDefinitionCreateRequest(ctx, policyStatesSummaryResource, subscriptionID, authorizationNamespace, policyDefinitionName, options)
	if err != nil {
		return PolicyStatesClientSummarizeForPolicyDefinitionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PolicyStatesClientSummarizeForPolicyDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PolicyStatesClientSummarizeForPolicyDefinitionResponse{}, runtime.NewResponseError(resp)
	}
	return client.summarizeForPolicyDefinitionHandleResponse(resp)
}

// summarizeForPolicyDefinitionCreateRequest creates the SummarizeForPolicyDefinition request.
func (client *PolicyStatesClient) summarizeForPolicyDefinitionCreateRequest(ctx context.Context, policyStatesSummaryResource Enum6, subscriptionID string, authorizationNamespace Enum4, policyDefinitionName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/{authorizationNamespace}/policyDefinitions/{policyDefinitionName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesSummaryResource}/summarize"
	if policyStatesSummaryResource == "" {
		return nil, errors.New("parameter policyStatesSummaryResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyStatesSummaryResource}", url.PathEscape(string(policyStatesSummaryResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	if authorizationNamespace == "" {
		return nil, errors.New("parameter authorizationNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{authorizationNamespace}", url.PathEscape(string(authorizationNamespace)))
	if policyDefinitionName == "" {
		return nil, errors.New("parameter policyDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyDefinitionName}", url.PathEscape(policyDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// summarizeForPolicyDefinitionHandleResponse handles the SummarizeForPolicyDefinition response.
func (client *PolicyStatesClient) summarizeForPolicyDefinitionHandleResponse(resp *http.Response) (PolicyStatesClientSummarizeForPolicyDefinitionResponse, error) {
	result := PolicyStatesClientSummarizeForPolicyDefinitionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SummarizeResults); err != nil {
		return PolicyStatesClientSummarizeForPolicyDefinitionResponse{}, err
	}
	return result, nil
}

// SummarizeForPolicySetDefinition - Summarizes policy states for the subscription level policy set definition.
// If the operation fails it returns an *azcore.ResponseError type.
// policyStatesSummaryResource - The virtual resource under PolicyStates resource type for summarize action. In a given time
// range, 'latest' represents the latest policy state(s) and is the only allowed value.
// subscriptionID - Microsoft Azure subscription ID.
// authorizationNamespace - The namespace for Microsoft Authorization resource provider; only "Microsoft.Authorization" is
// allowed.
// policySetDefinitionName - Policy set definition name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyStatesClient) SummarizeForPolicySetDefinition(ctx context.Context, policyStatesSummaryResource Enum6, subscriptionID string, authorizationNamespace Enum4, policySetDefinitionName string, options *QueryOptions) (PolicyStatesClientSummarizeForPolicySetDefinitionResponse, error) {
	req, err := client.summarizeForPolicySetDefinitionCreateRequest(ctx, policyStatesSummaryResource, subscriptionID, authorizationNamespace, policySetDefinitionName, options)
	if err != nil {
		return PolicyStatesClientSummarizeForPolicySetDefinitionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PolicyStatesClientSummarizeForPolicySetDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PolicyStatesClientSummarizeForPolicySetDefinitionResponse{}, runtime.NewResponseError(resp)
	}
	return client.summarizeForPolicySetDefinitionHandleResponse(resp)
}

// summarizeForPolicySetDefinitionCreateRequest creates the SummarizeForPolicySetDefinition request.
func (client *PolicyStatesClient) summarizeForPolicySetDefinitionCreateRequest(ctx context.Context, policyStatesSummaryResource Enum6, subscriptionID string, authorizationNamespace Enum4, policySetDefinitionName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/{authorizationNamespace}/policySetDefinitions/{policySetDefinitionName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesSummaryResource}/summarize"
	if policyStatesSummaryResource == "" {
		return nil, errors.New("parameter policyStatesSummaryResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyStatesSummaryResource}", url.PathEscape(string(policyStatesSummaryResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	if authorizationNamespace == "" {
		return nil, errors.New("parameter authorizationNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{authorizationNamespace}", url.PathEscape(string(authorizationNamespace)))
	if policySetDefinitionName == "" {
		return nil, errors.New("parameter policySetDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policySetDefinitionName}", url.PathEscape(policySetDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// summarizeForPolicySetDefinitionHandleResponse handles the SummarizeForPolicySetDefinition response.
func (client *PolicyStatesClient) summarizeForPolicySetDefinitionHandleResponse(resp *http.Response) (PolicyStatesClientSummarizeForPolicySetDefinitionResponse, error) {
	result := PolicyStatesClientSummarizeForPolicySetDefinitionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SummarizeResults); err != nil {
		return PolicyStatesClientSummarizeForPolicySetDefinitionResponse{}, err
	}
	return result, nil
}

// SummarizeForResource - Summarizes policy states for the resource.
// If the operation fails it returns an *azcore.ResponseError type.
// policyStatesSummaryResource - The virtual resource under PolicyStates resource type for summarize action. In a given time
// range, 'latest' represents the latest policy state(s) and is the only allowed value.
// resourceID - Resource ID.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyStatesClient) SummarizeForResource(ctx context.Context, policyStatesSummaryResource Enum6, resourceID string, options *QueryOptions) (PolicyStatesClientSummarizeForResourceResponse, error) {
	req, err := client.summarizeForResourceCreateRequest(ctx, policyStatesSummaryResource, resourceID, options)
	if err != nil {
		return PolicyStatesClientSummarizeForResourceResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PolicyStatesClientSummarizeForResourceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PolicyStatesClientSummarizeForResourceResponse{}, runtime.NewResponseError(resp)
	}
	return client.summarizeForResourceHandleResponse(resp)
}

// summarizeForResourceCreateRequest creates the SummarizeForResource request.
func (client *PolicyStatesClient) summarizeForResourceCreateRequest(ctx context.Context, policyStatesSummaryResource Enum6, resourceID string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/{resourceId}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesSummaryResource}/summarize"
	if policyStatesSummaryResource == "" {
		return nil, errors.New("parameter policyStatesSummaryResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyStatesSummaryResource}", url.PathEscape(string(policyStatesSummaryResource)))
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceID)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// summarizeForResourceHandleResponse handles the SummarizeForResource response.
func (client *PolicyStatesClient) summarizeForResourceHandleResponse(resp *http.Response) (PolicyStatesClientSummarizeForResourceResponse, error) {
	result := PolicyStatesClientSummarizeForResourceResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SummarizeResults); err != nil {
		return PolicyStatesClientSummarizeForResourceResponse{}, err
	}
	return result, nil
}

// SummarizeForResourceGroup - Summarizes policy states for the resources under the resource group.
// If the operation fails it returns an *azcore.ResponseError type.
// policyStatesSummaryResource - The virtual resource under PolicyStates resource type for summarize action. In a given time
// range, 'latest' represents the latest policy state(s) and is the only allowed value.
// subscriptionID - Microsoft Azure subscription ID.
// resourceGroupName - Resource group name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyStatesClient) SummarizeForResourceGroup(ctx context.Context, policyStatesSummaryResource Enum6, subscriptionID string, resourceGroupName string, options *QueryOptions) (PolicyStatesClientSummarizeForResourceGroupResponse, error) {
	req, err := client.summarizeForResourceGroupCreateRequest(ctx, policyStatesSummaryResource, subscriptionID, resourceGroupName, options)
	if err != nil {
		return PolicyStatesClientSummarizeForResourceGroupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PolicyStatesClientSummarizeForResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PolicyStatesClientSummarizeForResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	return client.summarizeForResourceGroupHandleResponse(resp)
}

// summarizeForResourceGroupCreateRequest creates the SummarizeForResourceGroup request.
func (client *PolicyStatesClient) summarizeForResourceGroupCreateRequest(ctx context.Context, policyStatesSummaryResource Enum6, subscriptionID string, resourceGroupName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesSummaryResource}/summarize"
	if policyStatesSummaryResource == "" {
		return nil, errors.New("parameter policyStatesSummaryResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyStatesSummaryResource}", url.PathEscape(string(policyStatesSummaryResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// summarizeForResourceGroupHandleResponse handles the SummarizeForResourceGroup response.
func (client *PolicyStatesClient) summarizeForResourceGroupHandleResponse(resp *http.Response) (PolicyStatesClientSummarizeForResourceGroupResponse, error) {
	result := PolicyStatesClientSummarizeForResourceGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SummarizeResults); err != nil {
		return PolicyStatesClientSummarizeForResourceGroupResponse{}, err
	}
	return result, nil
}

// SummarizeForResourceGroupLevelPolicyAssignment - Summarizes policy states for the resource group level policy assignment.
// If the operation fails it returns an *azcore.ResponseError type.
// policyStatesSummaryResource - The virtual resource under PolicyStates resource type for summarize action. In a given time
// range, 'latest' represents the latest policy state(s) and is the only allowed value.
// subscriptionID - Microsoft Azure subscription ID.
// resourceGroupName - Resource group name.
// authorizationNamespace - The namespace for Microsoft Authorization resource provider; only "Microsoft.Authorization" is
// allowed.
// policyAssignmentName - Policy assignment name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyStatesClient) SummarizeForResourceGroupLevelPolicyAssignment(ctx context.Context, policyStatesSummaryResource Enum6, subscriptionID string, resourceGroupName string, authorizationNamespace Enum4, policyAssignmentName string, options *QueryOptions) (PolicyStatesClientSummarizeForResourceGroupLevelPolicyAssignmentResponse, error) {
	req, err := client.summarizeForResourceGroupLevelPolicyAssignmentCreateRequest(ctx, policyStatesSummaryResource, subscriptionID, resourceGroupName, authorizationNamespace, policyAssignmentName, options)
	if err != nil {
		return PolicyStatesClientSummarizeForResourceGroupLevelPolicyAssignmentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PolicyStatesClientSummarizeForResourceGroupLevelPolicyAssignmentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PolicyStatesClientSummarizeForResourceGroupLevelPolicyAssignmentResponse{}, runtime.NewResponseError(resp)
	}
	return client.summarizeForResourceGroupLevelPolicyAssignmentHandleResponse(resp)
}

// summarizeForResourceGroupLevelPolicyAssignmentCreateRequest creates the SummarizeForResourceGroupLevelPolicyAssignment request.
func (client *PolicyStatesClient) summarizeForResourceGroupLevelPolicyAssignmentCreateRequest(ctx context.Context, policyStatesSummaryResource Enum6, subscriptionID string, resourceGroupName string, authorizationNamespace Enum4, policyAssignmentName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{authorizationNamespace}/policyAssignments/{policyAssignmentName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesSummaryResource}/summarize"
	if policyStatesSummaryResource == "" {
		return nil, errors.New("parameter policyStatesSummaryResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyStatesSummaryResource}", url.PathEscape(string(policyStatesSummaryResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if authorizationNamespace == "" {
		return nil, errors.New("parameter authorizationNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{authorizationNamespace}", url.PathEscape(string(authorizationNamespace)))
	if policyAssignmentName == "" {
		return nil, errors.New("parameter policyAssignmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyAssignmentName}", url.PathEscape(policyAssignmentName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// summarizeForResourceGroupLevelPolicyAssignmentHandleResponse handles the SummarizeForResourceGroupLevelPolicyAssignment response.
func (client *PolicyStatesClient) summarizeForResourceGroupLevelPolicyAssignmentHandleResponse(resp *http.Response) (PolicyStatesClientSummarizeForResourceGroupLevelPolicyAssignmentResponse, error) {
	result := PolicyStatesClientSummarizeForResourceGroupLevelPolicyAssignmentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SummarizeResults); err != nil {
		return PolicyStatesClientSummarizeForResourceGroupLevelPolicyAssignmentResponse{}, err
	}
	return result, nil
}

// SummarizeForSubscription - Summarizes policy states for the resources under the subscription.
// If the operation fails it returns an *azcore.ResponseError type.
// policyStatesSummaryResource - The virtual resource under PolicyStates resource type for summarize action. In a given time
// range, 'latest' represents the latest policy state(s) and is the only allowed value.
// subscriptionID - Microsoft Azure subscription ID.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyStatesClient) SummarizeForSubscription(ctx context.Context, policyStatesSummaryResource Enum6, subscriptionID string, options *QueryOptions) (PolicyStatesClientSummarizeForSubscriptionResponse, error) {
	req, err := client.summarizeForSubscriptionCreateRequest(ctx, policyStatesSummaryResource, subscriptionID, options)
	if err != nil {
		return PolicyStatesClientSummarizeForSubscriptionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PolicyStatesClientSummarizeForSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PolicyStatesClientSummarizeForSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	return client.summarizeForSubscriptionHandleResponse(resp)
}

// summarizeForSubscriptionCreateRequest creates the SummarizeForSubscription request.
func (client *PolicyStatesClient) summarizeForSubscriptionCreateRequest(ctx context.Context, policyStatesSummaryResource Enum6, subscriptionID string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesSummaryResource}/summarize"
	if policyStatesSummaryResource == "" {
		return nil, errors.New("parameter policyStatesSummaryResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyStatesSummaryResource}", url.PathEscape(string(policyStatesSummaryResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// summarizeForSubscriptionHandleResponse handles the SummarizeForSubscription response.
func (client *PolicyStatesClient) summarizeForSubscriptionHandleResponse(resp *http.Response) (PolicyStatesClientSummarizeForSubscriptionResponse, error) {
	result := PolicyStatesClientSummarizeForSubscriptionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SummarizeResults); err != nil {
		return PolicyStatesClientSummarizeForSubscriptionResponse{}, err
	}
	return result, nil
}

// SummarizeForSubscriptionLevelPolicyAssignment - Summarizes policy states for the subscription level policy assignment.
// If the operation fails it returns an *azcore.ResponseError type.
// policyStatesSummaryResource - The virtual resource under PolicyStates resource type for summarize action. In a given time
// range, 'latest' represents the latest policy state(s) and is the only allowed value.
// subscriptionID - Microsoft Azure subscription ID.
// authorizationNamespace - The namespace for Microsoft Authorization resource provider; only "Microsoft.Authorization" is
// allowed.
// policyAssignmentName - Policy assignment name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyStatesClient) SummarizeForSubscriptionLevelPolicyAssignment(ctx context.Context, policyStatesSummaryResource Enum6, subscriptionID string, authorizationNamespace Enum4, policyAssignmentName string, options *QueryOptions) (PolicyStatesClientSummarizeForSubscriptionLevelPolicyAssignmentResponse, error) {
	req, err := client.summarizeForSubscriptionLevelPolicyAssignmentCreateRequest(ctx, policyStatesSummaryResource, subscriptionID, authorizationNamespace, policyAssignmentName, options)
	if err != nil {
		return PolicyStatesClientSummarizeForSubscriptionLevelPolicyAssignmentResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return PolicyStatesClientSummarizeForSubscriptionLevelPolicyAssignmentResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return PolicyStatesClientSummarizeForSubscriptionLevelPolicyAssignmentResponse{}, runtime.NewResponseError(resp)
	}
	return client.summarizeForSubscriptionLevelPolicyAssignmentHandleResponse(resp)
}

// summarizeForSubscriptionLevelPolicyAssignmentCreateRequest creates the SummarizeForSubscriptionLevelPolicyAssignment request.
func (client *PolicyStatesClient) summarizeForSubscriptionLevelPolicyAssignmentCreateRequest(ctx context.Context, policyStatesSummaryResource Enum6, subscriptionID string, authorizationNamespace Enum4, policyAssignmentName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/{authorizationNamespace}/policyAssignments/{policyAssignmentName}/providers/Microsoft.PolicyInsights/policyStates/{policyStatesSummaryResource}/summarize"
	if policyStatesSummaryResource == "" {
		return nil, errors.New("parameter policyStatesSummaryResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyStatesSummaryResource}", url.PathEscape(string(policyStatesSummaryResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	if authorizationNamespace == "" {
		return nil, errors.New("parameter authorizationNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{authorizationNamespace}", url.PathEscape(string(authorizationNamespace)))
	if policyAssignmentName == "" {
		return nil, errors.New("parameter policyAssignmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyAssignmentName}", url.PathEscape(policyAssignmentName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// summarizeForSubscriptionLevelPolicyAssignmentHandleResponse handles the SummarizeForSubscriptionLevelPolicyAssignment response.
func (client *PolicyStatesClient) summarizeForSubscriptionLevelPolicyAssignmentHandleResponse(resp *http.Response) (PolicyStatesClientSummarizeForSubscriptionLevelPolicyAssignmentResponse, error) {
	result := PolicyStatesClientSummarizeForSubscriptionLevelPolicyAssignmentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.SummarizeResults); err != nil {
		return PolicyStatesClientSummarizeForSubscriptionLevelPolicyAssignmentResponse{}, err
	}
	return result, nil
}

// BeginTriggerResourceGroupEvaluation - Triggers a policy evaluation scan for all the resources under the resource group.
// If the operation fails it returns an *azcore.ResponseError type.
// subscriptionID - Microsoft Azure subscription ID.
// resourceGroupName - Resource group name.
// options - PolicyStatesClientBeginTriggerResourceGroupEvaluationOptions contains the optional parameters for the PolicyStatesClient.BeginTriggerResourceGroupEvaluation
// method.
func (client *PolicyStatesClient) BeginTriggerResourceGroupEvaluation(ctx context.Context, subscriptionID string, resourceGroupName string, options *PolicyStatesClientBeginTriggerResourceGroupEvaluationOptions) (*armruntime.Poller[PolicyStatesClientTriggerResourceGroupEvaluationResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.triggerResourceGroupEvaluation(ctx, subscriptionID, resourceGroupName, options)
		if err != nil {
			return nil, err
		}
		return armruntime.NewPoller[PolicyStatesClientTriggerResourceGroupEvaluationResponse]("PolicyStatesClient.TriggerResourceGroupEvaluation", "location", resp, client.pl, nil)
	} else {
		return armruntime.NewPollerFromResumeToken[PolicyStatesClientTriggerResourceGroupEvaluationResponse]("PolicyStatesClient.TriggerResourceGroupEvaluation", options.ResumeToken, client.pl, nil)
	}
}

// TriggerResourceGroupEvaluation - Triggers a policy evaluation scan for all the resources under the resource group.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *PolicyStatesClient) triggerResourceGroupEvaluation(ctx context.Context, subscriptionID string, resourceGroupName string, options *PolicyStatesClientBeginTriggerResourceGroupEvaluationOptions) (*http.Response, error) {
	req, err := client.triggerResourceGroupEvaluationCreateRequest(ctx, subscriptionID, resourceGroupName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// triggerResourceGroupEvaluationCreateRequest creates the TriggerResourceGroupEvaluation request.
func (client *PolicyStatesClient) triggerResourceGroupEvaluationCreateRequest(ctx context.Context, subscriptionID string, resourceGroupName string, options *PolicyStatesClientBeginTriggerResourceGroupEvaluationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.PolicyInsights/policyStates/latest/triggerEvaluation"
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// BeginTriggerSubscriptionEvaluation - Triggers a policy evaluation scan for all the resources under the subscription
// If the operation fails it returns an *azcore.ResponseError type.
// subscriptionID - Microsoft Azure subscription ID.
// options - PolicyStatesClientBeginTriggerSubscriptionEvaluationOptions contains the optional parameters for the PolicyStatesClient.BeginTriggerSubscriptionEvaluation
// method.
func (client *PolicyStatesClient) BeginTriggerSubscriptionEvaluation(ctx context.Context, subscriptionID string, options *PolicyStatesClientBeginTriggerSubscriptionEvaluationOptions) (*armruntime.Poller[PolicyStatesClientTriggerSubscriptionEvaluationResponse], error) {
	if options == nil || options.ResumeToken == "" {
		resp, err := client.triggerSubscriptionEvaluation(ctx, subscriptionID, options)
		if err != nil {
			return nil, err
		}
		return armruntime.NewPoller[PolicyStatesClientTriggerSubscriptionEvaluationResponse]("PolicyStatesClient.TriggerSubscriptionEvaluation", "location", resp, client.pl, nil)
	} else {
		return armruntime.NewPollerFromResumeToken[PolicyStatesClientTriggerSubscriptionEvaluationResponse]("PolicyStatesClient.TriggerSubscriptionEvaluation", options.ResumeToken, client.pl, nil)
	}
}

// TriggerSubscriptionEvaluation - Triggers a policy evaluation scan for all the resources under the subscription
// If the operation fails it returns an *azcore.ResponseError type.
func (client *PolicyStatesClient) triggerSubscriptionEvaluation(ctx context.Context, subscriptionID string, options *PolicyStatesClientBeginTriggerSubscriptionEvaluationOptions) (*http.Response, error) {
	req, err := client.triggerSubscriptionEvaluationCreateRequest(ctx, subscriptionID, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusAccepted) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// triggerSubscriptionEvaluationCreateRequest creates the TriggerSubscriptionEvaluation request.
func (client *PolicyStatesClient) triggerSubscriptionEvaluationCreateRequest(ctx context.Context, subscriptionID string, options *PolicyStatesClientBeginTriggerSubscriptionEvaluationOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.PolicyInsights/policyStates/latest/triggerEvaluation"
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}
