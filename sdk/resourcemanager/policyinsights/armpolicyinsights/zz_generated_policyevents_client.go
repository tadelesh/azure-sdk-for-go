//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armpolicyinsights

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"net/url"
	"strconv"
	"strings"
	"time"
)

// PolicyEventsClient contains the methods for the PolicyEvents group.
// Don't use this type directly, use NewPolicyEventsClient() instead.
type PolicyEventsClient struct {
	host string
	pl   runtime.Pipeline
}

// NewPolicyEventsClient creates a new instance of PolicyEventsClient with the specified values.
// credential - used to authorize requests. Usually a credential from azidentity.
// options - pass nil to accept the default values.
func NewPolicyEventsClient(credential azcore.TokenCredential, options *arm.ClientOptions) *PolicyEventsClient {
	if options == nil {
		options = &arm.ClientOptions{}
	}
	ep := options.Endpoint
	if len(ep) == 0 {
		ep = arm.AzurePublicCloud
	}
	client := &PolicyEventsClient{
		host: string(ep),
		pl:   armruntime.NewPipeline(moduleName, moduleVersion, credential, runtime.PipelineOptions{}, options),
	}
	return client
}

// ListQueryResultsForManagementGroup - Queries policy events for the resources under the management group.
// If the operation fails it returns an *azcore.ResponseError type.
// policyEventsResource - The name of the virtual resource under PolicyEvents resource type; only "default" is allowed.
// managementGroupsNamespace - The namespace for Microsoft Management RP; only "Microsoft.Management" is allowed.
// managementGroupName - Management group name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyEventsClient) ListQueryResultsForManagementGroup(policyEventsResource Enum1, managementGroupsNamespace Enum0, managementGroupName string, options *QueryOptions) *runtime.Pager[PolicyEventsClientListQueryResultsForManagementGroupResponse] {
	return runtime.NewPager(runtime.PageProcessor[PolicyEventsClientListQueryResultsForManagementGroupResponse]{
		More: func(page PolicyEventsClientListQueryResultsForManagementGroupResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PolicyEventsClientListQueryResultsForManagementGroupResponse) (PolicyEventsClientListQueryResultsForManagementGroupResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listQueryResultsForManagementGroupCreateRequest(ctx, policyEventsResource, managementGroupsNamespace, managementGroupName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.ODataNextLink)
			}
			if err != nil {
				return PolicyEventsClientListQueryResultsForManagementGroupResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return PolicyEventsClientListQueryResultsForManagementGroupResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return PolicyEventsClientListQueryResultsForManagementGroupResponse{}, runtime.NewResponseError(resp)
			}
			return client.listQueryResultsForManagementGroupHandleResponse(resp)
		},
	})
}

// listQueryResultsForManagementGroupCreateRequest creates the ListQueryResultsForManagementGroup request.
func (client *PolicyEventsClient) listQueryResultsForManagementGroupCreateRequest(ctx context.Context, policyEventsResource Enum1, managementGroupsNamespace Enum0, managementGroupName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/providers/{managementGroupsNamespace}/managementGroups/{managementGroupName}/providers/Microsoft.PolicyInsights/policyEvents/{policyEventsResource}/queryResults"
	if policyEventsResource == "" {
		return nil, errors.New("parameter policyEventsResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyEventsResource}", url.PathEscape(string(policyEventsResource)))
	if managementGroupsNamespace == "" {
		return nil, errors.New("parameter managementGroupsNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupsNamespace}", url.PathEscape(string(managementGroupsNamespace)))
	if managementGroupName == "" {
		return nil, errors.New("parameter managementGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managementGroupName}", url.PathEscape(managementGroupName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForManagementGroupHandleResponse handles the ListQueryResultsForManagementGroup response.
func (client *PolicyEventsClient) listQueryResultsForManagementGroupHandleResponse(resp *http.Response) (PolicyEventsClientListQueryResultsForManagementGroupResponse, error) {
	result := PolicyEventsClientListQueryResultsForManagementGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyEventsQueryResults); err != nil {
		return PolicyEventsClientListQueryResultsForManagementGroupResponse{}, err
	}
	return result, nil
}

// ListQueryResultsForPolicyDefinition - Queries policy events for the subscription level policy definition.
// If the operation fails it returns an *azcore.ResponseError type.
// policyEventsResource - The name of the virtual resource under PolicyEvents resource type; only "default" is allowed.
// subscriptionID - Microsoft Azure subscription ID.
// authorizationNamespace - The namespace for Microsoft Authorization resource provider; only "Microsoft.Authorization" is
// allowed.
// policyDefinitionName - Policy definition name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyEventsClient) ListQueryResultsForPolicyDefinition(policyEventsResource Enum1, subscriptionID string, authorizationNamespace Enum4, policyDefinitionName string, options *QueryOptions) *runtime.Pager[PolicyEventsClientListQueryResultsForPolicyDefinitionResponse] {
	return runtime.NewPager(runtime.PageProcessor[PolicyEventsClientListQueryResultsForPolicyDefinitionResponse]{
		More: func(page PolicyEventsClientListQueryResultsForPolicyDefinitionResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PolicyEventsClientListQueryResultsForPolicyDefinitionResponse) (PolicyEventsClientListQueryResultsForPolicyDefinitionResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listQueryResultsForPolicyDefinitionCreateRequest(ctx, policyEventsResource, subscriptionID, authorizationNamespace, policyDefinitionName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.ODataNextLink)
			}
			if err != nil {
				return PolicyEventsClientListQueryResultsForPolicyDefinitionResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return PolicyEventsClientListQueryResultsForPolicyDefinitionResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return PolicyEventsClientListQueryResultsForPolicyDefinitionResponse{}, runtime.NewResponseError(resp)
			}
			return client.listQueryResultsForPolicyDefinitionHandleResponse(resp)
		},
	})
}

// listQueryResultsForPolicyDefinitionCreateRequest creates the ListQueryResultsForPolicyDefinition request.
func (client *PolicyEventsClient) listQueryResultsForPolicyDefinitionCreateRequest(ctx context.Context, policyEventsResource Enum1, subscriptionID string, authorizationNamespace Enum4, policyDefinitionName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/{authorizationNamespace}/policyDefinitions/{policyDefinitionName}/providers/Microsoft.PolicyInsights/policyEvents/{policyEventsResource}/queryResults"
	if policyEventsResource == "" {
		return nil, errors.New("parameter policyEventsResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyEventsResource}", url.PathEscape(string(policyEventsResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	if authorizationNamespace == "" {
		return nil, errors.New("parameter authorizationNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{authorizationNamespace}", url.PathEscape(string(authorizationNamespace)))
	if policyDefinitionName == "" {
		return nil, errors.New("parameter policyDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyDefinitionName}", url.PathEscape(policyDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForPolicyDefinitionHandleResponse handles the ListQueryResultsForPolicyDefinition response.
func (client *PolicyEventsClient) listQueryResultsForPolicyDefinitionHandleResponse(resp *http.Response) (PolicyEventsClientListQueryResultsForPolicyDefinitionResponse, error) {
	result := PolicyEventsClientListQueryResultsForPolicyDefinitionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyEventsQueryResults); err != nil {
		return PolicyEventsClientListQueryResultsForPolicyDefinitionResponse{}, err
	}
	return result, nil
}

// ListQueryResultsForPolicySetDefinition - Queries policy events for the subscription level policy set definition.
// If the operation fails it returns an *azcore.ResponseError type.
// policyEventsResource - The name of the virtual resource under PolicyEvents resource type; only "default" is allowed.
// subscriptionID - Microsoft Azure subscription ID.
// authorizationNamespace - The namespace for Microsoft Authorization resource provider; only "Microsoft.Authorization" is
// allowed.
// policySetDefinitionName - Policy set definition name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyEventsClient) ListQueryResultsForPolicySetDefinition(policyEventsResource Enum1, subscriptionID string, authorizationNamespace Enum4, policySetDefinitionName string, options *QueryOptions) *runtime.Pager[PolicyEventsClientListQueryResultsForPolicySetDefinitionResponse] {
	return runtime.NewPager(runtime.PageProcessor[PolicyEventsClientListQueryResultsForPolicySetDefinitionResponse]{
		More: func(page PolicyEventsClientListQueryResultsForPolicySetDefinitionResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PolicyEventsClientListQueryResultsForPolicySetDefinitionResponse) (PolicyEventsClientListQueryResultsForPolicySetDefinitionResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listQueryResultsForPolicySetDefinitionCreateRequest(ctx, policyEventsResource, subscriptionID, authorizationNamespace, policySetDefinitionName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.ODataNextLink)
			}
			if err != nil {
				return PolicyEventsClientListQueryResultsForPolicySetDefinitionResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return PolicyEventsClientListQueryResultsForPolicySetDefinitionResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return PolicyEventsClientListQueryResultsForPolicySetDefinitionResponse{}, runtime.NewResponseError(resp)
			}
			return client.listQueryResultsForPolicySetDefinitionHandleResponse(resp)
		},
	})
}

// listQueryResultsForPolicySetDefinitionCreateRequest creates the ListQueryResultsForPolicySetDefinition request.
func (client *PolicyEventsClient) listQueryResultsForPolicySetDefinitionCreateRequest(ctx context.Context, policyEventsResource Enum1, subscriptionID string, authorizationNamespace Enum4, policySetDefinitionName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/{authorizationNamespace}/policySetDefinitions/{policySetDefinitionName}/providers/Microsoft.PolicyInsights/policyEvents/{policyEventsResource}/queryResults"
	if policyEventsResource == "" {
		return nil, errors.New("parameter policyEventsResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyEventsResource}", url.PathEscape(string(policyEventsResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	if authorizationNamespace == "" {
		return nil, errors.New("parameter authorizationNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{authorizationNamespace}", url.PathEscape(string(authorizationNamespace)))
	if policySetDefinitionName == "" {
		return nil, errors.New("parameter policySetDefinitionName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policySetDefinitionName}", url.PathEscape(policySetDefinitionName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForPolicySetDefinitionHandleResponse handles the ListQueryResultsForPolicySetDefinition response.
func (client *PolicyEventsClient) listQueryResultsForPolicySetDefinitionHandleResponse(resp *http.Response) (PolicyEventsClientListQueryResultsForPolicySetDefinitionResponse, error) {
	result := PolicyEventsClientListQueryResultsForPolicySetDefinitionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyEventsQueryResults); err != nil {
		return PolicyEventsClientListQueryResultsForPolicySetDefinitionResponse{}, err
	}
	return result, nil
}

// ListQueryResultsForResource - Queries policy events for the resource.
// If the operation fails it returns an *azcore.ResponseError type.
// policyEventsResource - The name of the virtual resource under PolicyEvents resource type; only "default" is allowed.
// resourceID - Resource ID.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyEventsClient) ListQueryResultsForResource(policyEventsResource Enum1, resourceID string, options *QueryOptions) *runtime.Pager[PolicyEventsClientListQueryResultsForResourceResponse] {
	return runtime.NewPager(runtime.PageProcessor[PolicyEventsClientListQueryResultsForResourceResponse]{
		More: func(page PolicyEventsClientListQueryResultsForResourceResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PolicyEventsClientListQueryResultsForResourceResponse) (PolicyEventsClientListQueryResultsForResourceResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listQueryResultsForResourceCreateRequest(ctx, policyEventsResource, resourceID, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.ODataNextLink)
			}
			if err != nil {
				return PolicyEventsClientListQueryResultsForResourceResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return PolicyEventsClientListQueryResultsForResourceResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return PolicyEventsClientListQueryResultsForResourceResponse{}, runtime.NewResponseError(resp)
			}
			return client.listQueryResultsForResourceHandleResponse(resp)
		},
	})
}

// listQueryResultsForResourceCreateRequest creates the ListQueryResultsForResource request.
func (client *PolicyEventsClient) listQueryResultsForResourceCreateRequest(ctx context.Context, policyEventsResource Enum1, resourceID string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/{resourceId}/providers/Microsoft.PolicyInsights/policyEvents/{policyEventsResource}/queryResults"
	if policyEventsResource == "" {
		return nil, errors.New("parameter policyEventsResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyEventsResource}", url.PathEscape(string(policyEventsResource)))
	urlPath = strings.ReplaceAll(urlPath, "{resourceId}", resourceID)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", *options.Expand)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForResourceHandleResponse handles the ListQueryResultsForResource response.
func (client *PolicyEventsClient) listQueryResultsForResourceHandleResponse(resp *http.Response) (PolicyEventsClientListQueryResultsForResourceResponse, error) {
	result := PolicyEventsClientListQueryResultsForResourceResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyEventsQueryResults); err != nil {
		return PolicyEventsClientListQueryResultsForResourceResponse{}, err
	}
	return result, nil
}

// ListQueryResultsForResourceGroup - Queries policy events for the resources under the resource group.
// If the operation fails it returns an *azcore.ResponseError type.
// policyEventsResource - The name of the virtual resource under PolicyEvents resource type; only "default" is allowed.
// subscriptionID - Microsoft Azure subscription ID.
// resourceGroupName - Resource group name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyEventsClient) ListQueryResultsForResourceGroup(policyEventsResource Enum1, subscriptionID string, resourceGroupName string, options *QueryOptions) *runtime.Pager[PolicyEventsClientListQueryResultsForResourceGroupResponse] {
	return runtime.NewPager(runtime.PageProcessor[PolicyEventsClientListQueryResultsForResourceGroupResponse]{
		More: func(page PolicyEventsClientListQueryResultsForResourceGroupResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PolicyEventsClientListQueryResultsForResourceGroupResponse) (PolicyEventsClientListQueryResultsForResourceGroupResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listQueryResultsForResourceGroupCreateRequest(ctx, policyEventsResource, subscriptionID, resourceGroupName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.ODataNextLink)
			}
			if err != nil {
				return PolicyEventsClientListQueryResultsForResourceGroupResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return PolicyEventsClientListQueryResultsForResourceGroupResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return PolicyEventsClientListQueryResultsForResourceGroupResponse{}, runtime.NewResponseError(resp)
			}
			return client.listQueryResultsForResourceGroupHandleResponse(resp)
		},
	})
}

// listQueryResultsForResourceGroupCreateRequest creates the ListQueryResultsForResourceGroup request.
func (client *PolicyEventsClient) listQueryResultsForResourceGroupCreateRequest(ctx context.Context, policyEventsResource Enum1, subscriptionID string, resourceGroupName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.PolicyInsights/policyEvents/{policyEventsResource}/queryResults"
	if policyEventsResource == "" {
		return nil, errors.New("parameter policyEventsResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyEventsResource}", url.PathEscape(string(policyEventsResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForResourceGroupHandleResponse handles the ListQueryResultsForResourceGroup response.
func (client *PolicyEventsClient) listQueryResultsForResourceGroupHandleResponse(resp *http.Response) (PolicyEventsClientListQueryResultsForResourceGroupResponse, error) {
	result := PolicyEventsClientListQueryResultsForResourceGroupResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyEventsQueryResults); err != nil {
		return PolicyEventsClientListQueryResultsForResourceGroupResponse{}, err
	}
	return result, nil
}

// ListQueryResultsForResourceGroupLevelPolicyAssignment - Queries policy events for the resource group level policy assignment.
// If the operation fails it returns an *azcore.ResponseError type.
// policyEventsResource - The name of the virtual resource under PolicyEvents resource type; only "default" is allowed.
// subscriptionID - Microsoft Azure subscription ID.
// resourceGroupName - Resource group name.
// authorizationNamespace - The namespace for Microsoft Authorization resource provider; only "Microsoft.Authorization" is
// allowed.
// policyAssignmentName - Policy assignment name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyEventsClient) ListQueryResultsForResourceGroupLevelPolicyAssignment(policyEventsResource Enum1, subscriptionID string, resourceGroupName string, authorizationNamespace Enum4, policyAssignmentName string, options *QueryOptions) *runtime.Pager[PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse] {
	return runtime.NewPager(runtime.PageProcessor[PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse]{
		More: func(page PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse) (PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listQueryResultsForResourceGroupLevelPolicyAssignmentCreateRequest(ctx, policyEventsResource, subscriptionID, resourceGroupName, authorizationNamespace, policyAssignmentName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.ODataNextLink)
			}
			if err != nil {
				return PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse{}, runtime.NewResponseError(resp)
			}
			return client.listQueryResultsForResourceGroupLevelPolicyAssignmentHandleResponse(resp)
		},
	})
}

// listQueryResultsForResourceGroupLevelPolicyAssignmentCreateRequest creates the ListQueryResultsForResourceGroupLevelPolicyAssignment request.
func (client *PolicyEventsClient) listQueryResultsForResourceGroupLevelPolicyAssignmentCreateRequest(ctx context.Context, policyEventsResource Enum1, subscriptionID string, resourceGroupName string, authorizationNamespace Enum4, policyAssignmentName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourcegroups/{resourceGroupName}/providers/{authorizationNamespace}/policyAssignments/{policyAssignmentName}/providers/Microsoft.PolicyInsights/policyEvents/{policyEventsResource}/queryResults"
	if policyEventsResource == "" {
		return nil, errors.New("parameter policyEventsResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyEventsResource}", url.PathEscape(string(policyEventsResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", url.PathEscape(resourceGroupName))
	if authorizationNamespace == "" {
		return nil, errors.New("parameter authorizationNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{authorizationNamespace}", url.PathEscape(string(authorizationNamespace)))
	if policyAssignmentName == "" {
		return nil, errors.New("parameter policyAssignmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyAssignmentName}", url.PathEscape(policyAssignmentName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForResourceGroupLevelPolicyAssignmentHandleResponse handles the ListQueryResultsForResourceGroupLevelPolicyAssignment response.
func (client *PolicyEventsClient) listQueryResultsForResourceGroupLevelPolicyAssignmentHandleResponse(resp *http.Response) (PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse, error) {
	result := PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyEventsQueryResults); err != nil {
		return PolicyEventsClientListQueryResultsForResourceGroupLevelPolicyAssignmentResponse{}, err
	}
	return result, nil
}

// ListQueryResultsForSubscription - Queries policy events for the resources under the subscription.
// If the operation fails it returns an *azcore.ResponseError type.
// policyEventsResource - The name of the virtual resource under PolicyEvents resource type; only "default" is allowed.
// subscriptionID - Microsoft Azure subscription ID.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyEventsClient) ListQueryResultsForSubscription(policyEventsResource Enum1, subscriptionID string, options *QueryOptions) *runtime.Pager[PolicyEventsClientListQueryResultsForSubscriptionResponse] {
	return runtime.NewPager(runtime.PageProcessor[PolicyEventsClientListQueryResultsForSubscriptionResponse]{
		More: func(page PolicyEventsClientListQueryResultsForSubscriptionResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PolicyEventsClientListQueryResultsForSubscriptionResponse) (PolicyEventsClientListQueryResultsForSubscriptionResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listQueryResultsForSubscriptionCreateRequest(ctx, policyEventsResource, subscriptionID, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.ODataNextLink)
			}
			if err != nil {
				return PolicyEventsClientListQueryResultsForSubscriptionResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return PolicyEventsClientListQueryResultsForSubscriptionResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return PolicyEventsClientListQueryResultsForSubscriptionResponse{}, runtime.NewResponseError(resp)
			}
			return client.listQueryResultsForSubscriptionHandleResponse(resp)
		},
	})
}

// listQueryResultsForSubscriptionCreateRequest creates the ListQueryResultsForSubscription request.
func (client *PolicyEventsClient) listQueryResultsForSubscriptionCreateRequest(ctx context.Context, policyEventsResource Enum1, subscriptionID string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.PolicyInsights/policyEvents/{policyEventsResource}/queryResults"
	if policyEventsResource == "" {
		return nil, errors.New("parameter policyEventsResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyEventsResource}", url.PathEscape(string(policyEventsResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForSubscriptionHandleResponse handles the ListQueryResultsForSubscription response.
func (client *PolicyEventsClient) listQueryResultsForSubscriptionHandleResponse(resp *http.Response) (PolicyEventsClientListQueryResultsForSubscriptionResponse, error) {
	result := PolicyEventsClientListQueryResultsForSubscriptionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyEventsQueryResults); err != nil {
		return PolicyEventsClientListQueryResultsForSubscriptionResponse{}, err
	}
	return result, nil
}

// ListQueryResultsForSubscriptionLevelPolicyAssignment - Queries policy events for the subscription level policy assignment.
// If the operation fails it returns an *azcore.ResponseError type.
// policyEventsResource - The name of the virtual resource under PolicyEvents resource type; only "default" is allowed.
// subscriptionID - Microsoft Azure subscription ID.
// authorizationNamespace - The namespace for Microsoft Authorization resource provider; only "Microsoft.Authorization" is
// allowed.
// policyAssignmentName - Policy assignment name.
// options - QueryOptions contains a group of parameters for the PolicyTrackedResourcesClient.ListQueryResultsForManagementGroup
// method.
func (client *PolicyEventsClient) ListQueryResultsForSubscriptionLevelPolicyAssignment(policyEventsResource Enum1, subscriptionID string, authorizationNamespace Enum4, policyAssignmentName string, options *QueryOptions) *runtime.Pager[PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse] {
	return runtime.NewPager(runtime.PageProcessor[PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse]{
		More: func(page PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse) bool {
			return page.ODataNextLink != nil && len(*page.ODataNextLink) > 0
		},
		Fetcher: func(ctx context.Context, page *PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse) (PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse, error) {
			var req *policy.Request
			var err error
			if page == nil {
				req, err = client.listQueryResultsForSubscriptionLevelPolicyAssignmentCreateRequest(ctx, policyEventsResource, subscriptionID, authorizationNamespace, policyAssignmentName, options)
			} else {
				req, err = runtime.NewRequest(ctx, http.MethodGet, *page.ODataNextLink)
			}
			if err != nil {
				return PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse{}, err
			}
			resp, err := client.pl.Do(req)
			if err != nil {
				return PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse{}, err
			}
			if !runtime.HasStatusCode(resp, http.StatusOK) {
				return PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse{}, runtime.NewResponseError(resp)
			}
			return client.listQueryResultsForSubscriptionLevelPolicyAssignmentHandleResponse(resp)
		},
	})
}

// listQueryResultsForSubscriptionLevelPolicyAssignmentCreateRequest creates the ListQueryResultsForSubscriptionLevelPolicyAssignment request.
func (client *PolicyEventsClient) listQueryResultsForSubscriptionLevelPolicyAssignmentCreateRequest(ctx context.Context, policyEventsResource Enum1, subscriptionID string, authorizationNamespace Enum4, policyAssignmentName string, options *QueryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/{authorizationNamespace}/policyAssignments/{policyAssignmentName}/providers/Microsoft.PolicyInsights/policyEvents/{policyEventsResource}/queryResults"
	if policyEventsResource == "" {
		return nil, errors.New("parameter policyEventsResource cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyEventsResource}", url.PathEscape(string(policyEventsResource)))
	if subscriptionID == "" {
		return nil, errors.New("parameter subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", url.PathEscape(subscriptionID))
	if authorizationNamespace == "" {
		return nil, errors.New("parameter authorizationNamespace cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{authorizationNamespace}", url.PathEscape(string(authorizationNamespace)))
	if policyAssignmentName == "" {
		return nil, errors.New("parameter policyAssignmentName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{policyAssignmentName}", url.PathEscape(policyAssignmentName))
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2019-10-01")
	if options != nil && options.Top != nil {
		reqQP.Set("$top", strconv.FormatInt(int64(*options.Top), 10))
	}
	if options != nil && options.OrderBy != nil {
		reqQP.Set("$orderby", *options.OrderBy)
	}
	if options != nil && options.Select != nil {
		reqQP.Set("$select", *options.Select)
	}
	if options != nil && options.From != nil {
		reqQP.Set("$from", options.From.Format(time.RFC3339Nano))
	}
	if options != nil && options.To != nil {
		reqQP.Set("$to", options.To.Format(time.RFC3339Nano))
	}
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	if options != nil && options.Apply != nil {
		reqQP.Set("$apply", *options.Apply)
	}
	if options != nil && options.SkipToken != nil {
		reqQP.Set("$skiptoken", *options.SkipToken)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listQueryResultsForSubscriptionLevelPolicyAssignmentHandleResponse handles the ListQueryResultsForSubscriptionLevelPolicyAssignment response.
func (client *PolicyEventsClient) listQueryResultsForSubscriptionLevelPolicyAssignmentHandleResponse(resp *http.Response) (PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse, error) {
	result := PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.PolicyEventsQueryResults); err != nil {
		return PolicyEventsClientListQueryResultsForSubscriptionLevelPolicyAssignmentResponse{}, err
	}
	return result, nil
}
