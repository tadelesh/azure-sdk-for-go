//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armlogz

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"time"
)

// MonitorClientListVMHostUpdateResponse contains the response from method MonitorClient.ListVMHostUpdate.
type MonitorClientListVMHostUpdateResponse struct {
	VMResourcesListResponse
}

// MonitorClientListVMHostsResponse contains the response from method MonitorClient.ListVMHosts.
type MonitorClientListVMHostsResponse struct {
	VMResourcesListResponse
}

// MonitorClientVMHostPayloadResponse contains the response from method MonitorClient.VMHostPayload.
type MonitorClientVMHostPayloadResponse struct {
	VMExtensionPayload
}

// MonitorsClientCreatePollerResponse contains the response from method MonitorsClient.Create.
type MonitorsClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MonitorsClientCreatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l MonitorsClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MonitorsClientCreateResponse, error) {
	respType := MonitorsClientCreateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MonitorResource)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a MonitorsClientCreatePollerResponse from the provided client and resume token.
func (l *MonitorsClientCreatePollerResponse) Resume(ctx context.Context, client *MonitorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MonitorsClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &MonitorsClientCreatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// MonitorsClientCreateResponse contains the response from method MonitorsClient.Create.
type MonitorsClientCreateResponse struct {
	MonitorResource
}

// MonitorsClientDeletePollerResponse contains the response from method MonitorsClient.Delete.
type MonitorsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *MonitorsClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l MonitorsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (MonitorsClientDeleteResponse, error) {
	respType := MonitorsClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a MonitorsClientDeletePollerResponse from the provided client and resume token.
func (l *MonitorsClientDeletePollerResponse) Resume(ctx context.Context, client *MonitorsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("MonitorsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &MonitorsClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// MonitorsClientDeleteResponse contains the response from method MonitorsClient.Delete.
type MonitorsClientDeleteResponse struct {
	// placeholder for future response values
}

// MonitorsClientGetResponse contains the response from method MonitorsClient.Get.
type MonitorsClientGetResponse struct {
	MonitorResource
}

// MonitorsClientListByResourceGroupResponse contains the response from method MonitorsClient.ListByResourceGroup.
type MonitorsClientListByResourceGroupResponse struct {
	MonitorResourceListResponse
}

// MonitorsClientListBySubscriptionResponse contains the response from method MonitorsClient.ListBySubscription.
type MonitorsClientListBySubscriptionResponse struct {
	MonitorResourceListResponse
}

// MonitorsClientListMonitoredResourcesResponse contains the response from method MonitorsClient.ListMonitoredResources.
type MonitorsClientListMonitoredResourcesResponse struct {
	MonitoredResourceListResponse
}

// MonitorsClientListUserRolesResponse contains the response from method MonitorsClient.ListUserRoles.
type MonitorsClientListUserRolesResponse struct {
	UserRoleListResponse
}

// MonitorsClientUpdateResponse contains the response from method MonitorsClient.Update.
type MonitorsClientUpdateResponse struct {
	MonitorResource
}

// OperationsClientListResponse contains the response from method OperationsClient.List.
type OperationsClientListResponse struct {
	OperationListResult
}

// SingleSignOnClientCreateOrUpdatePollerResponse contains the response from method SingleSignOnClient.CreateOrUpdate.
type SingleSignOnClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SingleSignOnClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SingleSignOnClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SingleSignOnClientCreateOrUpdateResponse, error) {
	respType := SingleSignOnClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.SingleSignOnResource)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a SingleSignOnClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *SingleSignOnClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *SingleSignOnClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SingleSignOnClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SingleSignOnClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// SingleSignOnClientCreateOrUpdateResponse contains the response from method SingleSignOnClient.CreateOrUpdate.
type SingleSignOnClientCreateOrUpdateResponse struct {
	SingleSignOnResource
}

// SingleSignOnClientGetResponse contains the response from method SingleSignOnClient.Get.
type SingleSignOnClientGetResponse struct {
	SingleSignOnResource
}

// SingleSignOnClientListResponse contains the response from method SingleSignOnClient.List.
type SingleSignOnClientListResponse struct {
	SingleSignOnResourceListResponse
}

// SubAccountClientCreatePollerResponse contains the response from method SubAccountClient.Create.
type SubAccountClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SubAccountClientCreatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SubAccountClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SubAccountClientCreateResponse, error) {
	respType := SubAccountClientCreateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.MonitorResource)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a SubAccountClientCreatePollerResponse from the provided client and resume token.
func (l *SubAccountClientCreatePollerResponse) Resume(ctx context.Context, client *SubAccountClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SubAccountClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SubAccountClientCreatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// SubAccountClientCreateResponse contains the response from method SubAccountClient.Create.
type SubAccountClientCreateResponse struct {
	MonitorResource
}

// SubAccountClientDeletePollerResponse contains the response from method SubAccountClient.Delete.
type SubAccountClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SubAccountClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SubAccountClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SubAccountClientDeleteResponse, error) {
	respType := SubAccountClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a SubAccountClientDeletePollerResponse from the provided client and resume token.
func (l *SubAccountClientDeletePollerResponse) Resume(ctx context.Context, client *SubAccountClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SubAccountClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SubAccountClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// SubAccountClientDeleteResponse contains the response from method SubAccountClient.Delete.
type SubAccountClientDeleteResponse struct {
	// placeholder for future response values
}

// SubAccountClientGetResponse contains the response from method SubAccountClient.Get.
type SubAccountClientGetResponse struct {
	MonitorResource
}

// SubAccountClientListMonitoredResourcesResponse contains the response from method SubAccountClient.ListMonitoredResources.
type SubAccountClientListMonitoredResourcesResponse struct {
	MonitoredResourceListResponse
}

// SubAccountClientListResponse contains the response from method SubAccountClient.List.
type SubAccountClientListResponse struct {
	MonitorResourceListResponse
}

// SubAccountClientListVMHostUpdateResponse contains the response from method SubAccountClient.ListVMHostUpdate.
type SubAccountClientListVMHostUpdateResponse struct {
	VMResourcesListResponse
}

// SubAccountClientListVMHostsResponse contains the response from method SubAccountClient.ListVMHosts.
type SubAccountClientListVMHostsResponse struct {
	VMResourcesListResponse
}

// SubAccountClientUpdateResponse contains the response from method SubAccountClient.Update.
type SubAccountClientUpdateResponse struct {
	MonitorResource
}

// SubAccountClientVMHostPayloadResponse contains the response from method SubAccountClient.VMHostPayload.
type SubAccountClientVMHostPayloadResponse struct {
	VMExtensionPayload
}

// SubAccountTagRulesClientCreateOrUpdateResponse contains the response from method SubAccountTagRulesClient.CreateOrUpdate.
type SubAccountTagRulesClientCreateOrUpdateResponse struct {
	MonitoringTagRules
}

// SubAccountTagRulesClientDeleteResponse contains the response from method SubAccountTagRulesClient.Delete.
type SubAccountTagRulesClientDeleteResponse struct {
	// Location contains the information returned from the location header response.
	Location *string
}

// SubAccountTagRulesClientGetResponse contains the response from method SubAccountTagRulesClient.Get.
type SubAccountTagRulesClientGetResponse struct {
	MonitoringTagRules
}

// SubAccountTagRulesClientListResponse contains the response from method SubAccountTagRulesClient.List.
type SubAccountTagRulesClientListResponse struct {
	MonitoringTagRulesListResponse
}

// TagRulesClientCreateOrUpdateResponse contains the response from method TagRulesClient.CreateOrUpdate.
type TagRulesClientCreateOrUpdateResponse struct {
	MonitoringTagRules
}

// TagRulesClientDeleteResponse contains the response from method TagRulesClient.Delete.
type TagRulesClientDeleteResponse struct {
	// Location contains the information returned from the location header response.
	Location *string
}

// TagRulesClientGetResponse contains the response from method TagRulesClient.Get.
type TagRulesClientGetResponse struct {
	MonitoringTagRules
}

// TagRulesClientListResponse contains the response from method TagRulesClient.List.
type TagRulesClientListResponse struct {
	MonitoringTagRulesListResponse
}
