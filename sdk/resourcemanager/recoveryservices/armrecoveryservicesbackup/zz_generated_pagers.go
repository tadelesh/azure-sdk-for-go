//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armrecoveryservicesbackup

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// BackupEnginesClientListPager provides operations for iterating over paged responses.
type BackupEnginesClientListPager struct {
	client    *BackupEnginesClient
	current   BackupEnginesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BackupEnginesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BackupEnginesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BackupEngineBaseResourceList.NextLink == nil || len(*p.current.BackupEngineBaseResourceList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *BackupEnginesClientListPager) NextPage(ctx context.Context) (BackupEnginesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return BackupEnginesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BackupEnginesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BackupEnginesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BackupEnginesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return BackupEnginesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BackupJobsClientListPager provides operations for iterating over paged responses.
type BackupJobsClientListPager struct {
	client    *BackupJobsClient
	current   BackupJobsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BackupJobsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BackupJobsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobResourceList.NextLink == nil || len(*p.current.JobResourceList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *BackupJobsClientListPager) NextPage(ctx context.Context) (BackupJobsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return BackupJobsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BackupJobsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BackupJobsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BackupJobsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return BackupJobsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BackupPoliciesClientListPager provides operations for iterating over paged responses.
type BackupPoliciesClientListPager struct {
	client    *BackupPoliciesClient
	current   BackupPoliciesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BackupPoliciesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BackupPoliciesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProtectionPolicyResourceList.NextLink == nil || len(*p.current.ProtectionPolicyResourceList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *BackupPoliciesClientListPager) NextPage(ctx context.Context) (BackupPoliciesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return BackupPoliciesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BackupPoliciesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BackupPoliciesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BackupPoliciesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return BackupPoliciesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BackupProtectableItemsClientListPager provides operations for iterating over paged responses.
type BackupProtectableItemsClientListPager struct {
	client    *BackupProtectableItemsClient
	current   BackupProtectableItemsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BackupProtectableItemsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BackupProtectableItemsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkloadProtectableItemResourceList.NextLink == nil || len(*p.current.WorkloadProtectableItemResourceList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *BackupProtectableItemsClientListPager) NextPage(ctx context.Context) (BackupProtectableItemsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return BackupProtectableItemsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BackupProtectableItemsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BackupProtectableItemsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BackupProtectableItemsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return BackupProtectableItemsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BackupProtectedItemsClientListPager provides operations for iterating over paged responses.
type BackupProtectedItemsClientListPager struct {
	client    *BackupProtectedItemsClient
	current   BackupProtectedItemsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BackupProtectedItemsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BackupProtectedItemsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProtectedItemResourceList.NextLink == nil || len(*p.current.ProtectedItemResourceList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *BackupProtectedItemsClientListPager) NextPage(ctx context.Context) (BackupProtectedItemsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return BackupProtectedItemsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BackupProtectedItemsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BackupProtectedItemsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BackupProtectedItemsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return BackupProtectedItemsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BackupProtectionContainersClientListPager provides operations for iterating over paged responses.
type BackupProtectionContainersClientListPager struct {
	client    *BackupProtectionContainersClient
	current   BackupProtectionContainersClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BackupProtectionContainersClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BackupProtectionContainersClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProtectionContainerResourceList.NextLink == nil || len(*p.current.ProtectionContainerResourceList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *BackupProtectionContainersClientListPager) NextPage(ctx context.Context) (BackupProtectionContainersClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return BackupProtectionContainersClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BackupProtectionContainersClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BackupProtectionContainersClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BackupProtectionContainersClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return BackupProtectionContainersClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BackupProtectionIntentClientListPager provides operations for iterating over paged responses.
type BackupProtectionIntentClientListPager struct {
	client    *BackupProtectionIntentClient
	current   BackupProtectionIntentClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BackupProtectionIntentClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BackupProtectionIntentClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProtectionIntentResourceList.NextLink == nil || len(*p.current.ProtectionIntentResourceList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *BackupProtectionIntentClientListPager) NextPage(ctx context.Context) (BackupProtectionIntentClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return BackupProtectionIntentClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BackupProtectionIntentClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BackupProtectionIntentClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BackupProtectionIntentClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return BackupProtectionIntentClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BackupUsageSummariesClientListPager provides operations for iterating over paged responses.
type BackupUsageSummariesClientListPager struct {
	client    *BackupUsageSummariesClient
	current   BackupUsageSummariesClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BackupUsageSummariesClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *BackupUsageSummariesClientListPager) NextPage(ctx context.Context) (BackupUsageSummariesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return BackupUsageSummariesClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BackupUsageSummariesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BackupUsageSummariesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BackupUsageSummariesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return BackupUsageSummariesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BackupWorkloadItemsClientListPager provides operations for iterating over paged responses.
type BackupWorkloadItemsClientListPager struct {
	client    *BackupWorkloadItemsClient
	current   BackupWorkloadItemsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BackupWorkloadItemsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BackupWorkloadItemsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkloadItemResourceList.NextLink == nil || len(*p.current.WorkloadItemResourceList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *BackupWorkloadItemsClientListPager) NextPage(ctx context.Context) (BackupWorkloadItemsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return BackupWorkloadItemsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BackupWorkloadItemsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BackupWorkloadItemsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BackupWorkloadItemsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return BackupWorkloadItemsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *OperationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ClientDiscoveryResponse.NextLink == nil || len(*p.current.ClientDiscoveryResponse.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *OperationsClientListPager) NextPage(ctx context.Context) (OperationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return OperationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return OperationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProtectableContainersClientListPager provides operations for iterating over paged responses.
type ProtectableContainersClientListPager struct {
	client    *ProtectableContainersClient
	current   ProtectableContainersClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProtectableContainersClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProtectableContainersClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProtectableContainerResourceList.NextLink == nil || len(*p.current.ProtectableContainerResourceList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProtectableContainersClientListPager) NextPage(ctx context.Context) (ProtectableContainersClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProtectableContainersClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProtectableContainersClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProtectableContainersClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProtectableContainersClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ProtectableContainersClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RecoveryPointsClientListPager provides operations for iterating over paged responses.
type RecoveryPointsClientListPager struct {
	client    *RecoveryPointsClient
	current   RecoveryPointsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RecoveryPointsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RecoveryPointsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RecoveryPointResourceList.NextLink == nil || len(*p.current.RecoveryPointResourceList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RecoveryPointsClientListPager) NextPage(ctx context.Context) (RecoveryPointsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RecoveryPointsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RecoveryPointsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RecoveryPointsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RecoveryPointsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return RecoveryPointsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RecoveryPointsRecommendedForMoveClientListPager provides operations for iterating over paged responses.
type RecoveryPointsRecommendedForMoveClientListPager struct {
	client    *RecoveryPointsRecommendedForMoveClient
	current   RecoveryPointsRecommendedForMoveClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RecoveryPointsRecommendedForMoveClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RecoveryPointsRecommendedForMoveClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RecoveryPointResourceList.NextLink == nil || len(*p.current.RecoveryPointResourceList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RecoveryPointsRecommendedForMoveClientListPager) NextPage(ctx context.Context) (RecoveryPointsRecommendedForMoveClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RecoveryPointsRecommendedForMoveClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RecoveryPointsRecommendedForMoveClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RecoveryPointsRecommendedForMoveClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RecoveryPointsRecommendedForMoveClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return RecoveryPointsRecommendedForMoveClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ResourceGuardProxiesClientGetPager provides operations for iterating over paged responses.
type ResourceGuardProxiesClientGetPager struct {
	client    *ResourceGuardProxiesClient
	current   ResourceGuardProxiesClientGetResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ResourceGuardProxiesClientGetResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ResourceGuardProxiesClientGetPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceGuardProxyBaseResourceList.NextLink == nil || len(*p.current.ResourceGuardProxyBaseResourceList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ResourceGuardProxiesClientGetPager) NextPage(ctx context.Context) (ResourceGuardProxiesClientGetResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ResourceGuardProxiesClientGetResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ResourceGuardProxiesClientGetResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ResourceGuardProxiesClientGetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ResourceGuardProxiesClientGetResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.getHandleResponse(resp)
	if err != nil {
		return ResourceGuardProxiesClientGetResponse{}, err
	}
	p.current = result
	return p.current, nil
}
