//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armstorage

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AccountsClientListByResourceGroupPager provides operations for iterating over paged responses.
type AccountsClientListByResourceGroupPager struct {
	client    *AccountsClient
	current   AccountsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AccountsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AccountsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AccountListResult.NextLink == nil || len(*p.current.AccountListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AccountsClientListByResourceGroupPager) NextPage(ctx context.Context) (AccountsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AccountsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AccountsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AccountsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AccountsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return AccountsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AccountsClientListPager provides operations for iterating over paged responses.
type AccountsClientListPager struct {
	client    *AccountsClient
	current   AccountsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AccountsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AccountsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AccountListResult.NextLink == nil || len(*p.current.AccountListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AccountsClientListPager) NextPage(ctx context.Context) (AccountsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AccountsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AccountsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AccountsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AccountsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return AccountsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BlobContainersClientListPager provides operations for iterating over paged responses.
type BlobContainersClientListPager struct {
	client    *BlobContainersClient
	current   BlobContainersClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BlobContainersClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BlobContainersClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListContainerItems.NextLink == nil || len(*p.current.ListContainerItems.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *BlobContainersClientListPager) NextPage(ctx context.Context) (BlobContainersClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return BlobContainersClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BlobContainersClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BlobContainersClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BlobContainersClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return BlobContainersClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BlobInventoryPoliciesClientListPager provides operations for iterating over paged responses.
type BlobInventoryPoliciesClientListPager struct {
	client    *BlobInventoryPoliciesClient
	current   BlobInventoryPoliciesClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BlobInventoryPoliciesClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *BlobInventoryPoliciesClientListPager) NextPage(ctx context.Context) (BlobInventoryPoliciesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return BlobInventoryPoliciesClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BlobInventoryPoliciesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BlobInventoryPoliciesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BlobInventoryPoliciesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return BlobInventoryPoliciesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BlobServicesClientListPager provides operations for iterating over paged responses.
type BlobServicesClientListPager struct {
	client    *BlobServicesClient
	current   BlobServicesClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BlobServicesClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *BlobServicesClientListPager) NextPage(ctx context.Context) (BlobServicesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return BlobServicesClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BlobServicesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BlobServicesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BlobServicesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return BlobServicesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DeletedAccountsClientListPager provides operations for iterating over paged responses.
type DeletedAccountsClientListPager struct {
	client    *DeletedAccountsClient
	current   DeletedAccountsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeletedAccountsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DeletedAccountsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeletedAccountListResult.NextLink == nil || len(*p.current.DeletedAccountListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DeletedAccountsClientListPager) NextPage(ctx context.Context) (DeletedAccountsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DeletedAccountsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DeletedAccountsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DeletedAccountsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DeletedAccountsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return DeletedAccountsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// EncryptionScopesClientListPager provides operations for iterating over paged responses.
type EncryptionScopesClientListPager struct {
	client    *EncryptionScopesClient
	current   EncryptionScopesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EncryptionScopesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *EncryptionScopesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EncryptionScopeListResult.NextLink == nil || len(*p.current.EncryptionScopeListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *EncryptionScopesClientListPager) NextPage(ctx context.Context) (EncryptionScopesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return EncryptionScopesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return EncryptionScopesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return EncryptionScopesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return EncryptionScopesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return EncryptionScopesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// FileSharesClientListPager provides operations for iterating over paged responses.
type FileSharesClientListPager struct {
	client    *FileSharesClient
	current   FileSharesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, FileSharesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *FileSharesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FileShareItems.NextLink == nil || len(*p.current.FileShareItems.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *FileSharesClientListPager) NextPage(ctx context.Context) (FileSharesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return FileSharesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return FileSharesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return FileSharesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return FileSharesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return FileSharesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// LocalUsersClientListPager provides operations for iterating over paged responses.
type LocalUsersClientListPager struct {
	client    *LocalUsersClient
	current   LocalUsersClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *LocalUsersClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *LocalUsersClientListPager) NextPage(ctx context.Context) (LocalUsersClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return LocalUsersClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return LocalUsersClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return LocalUsersClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return LocalUsersClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return LocalUsersClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ObjectReplicationPoliciesClientListPager provides operations for iterating over paged responses.
type ObjectReplicationPoliciesClientListPager struct {
	client    *ObjectReplicationPoliciesClient
	current   ObjectReplicationPoliciesClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ObjectReplicationPoliciesClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *ObjectReplicationPoliciesClientListPager) NextPage(ctx context.Context) (ObjectReplicationPoliciesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return ObjectReplicationPoliciesClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ObjectReplicationPoliciesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ObjectReplicationPoliciesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ObjectReplicationPoliciesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ObjectReplicationPoliciesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *OperationsClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *OperationsClientListPager) NextPage(ctx context.Context) (OperationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return OperationsClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return OperationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PrivateEndpointConnectionsClientListPager provides operations for iterating over paged responses.
type PrivateEndpointConnectionsClientListPager struct {
	client    *PrivateEndpointConnectionsClient
	current   PrivateEndpointConnectionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PrivateEndpointConnectionsClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *PrivateEndpointConnectionsClientListPager) NextPage(ctx context.Context) (PrivateEndpointConnectionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return PrivateEndpointConnectionsClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PrivateEndpointConnectionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PrivateEndpointConnectionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PrivateEndpointConnectionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return PrivateEndpointConnectionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// QueueClientListPager provides operations for iterating over paged responses.
type QueueClientListPager struct {
	client    *QueueClient
	current   QueueClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, QueueClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *QueueClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListQueueResource.NextLink == nil || len(*p.current.ListQueueResource.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *QueueClientListPager) NextPage(ctx context.Context) (QueueClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return QueueClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return QueueClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return QueueClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return QueueClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return QueueClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SKUsClientListPager provides operations for iterating over paged responses.
type SKUsClientListPager struct {
	client    *SKUsClient
	current   SKUsClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SKUsClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *SKUsClientListPager) NextPage(ctx context.Context) (SKUsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return SKUsClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SKUsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SKUsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SKUsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return SKUsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TableClientListPager provides operations for iterating over paged responses.
type TableClientListPager struct {
	client    *TableClient
	current   TableClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TableClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TableClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListTableResource.NextLink == nil || len(*p.current.ListTableResource.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *TableClientListPager) NextPage(ctx context.Context) (TableClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return TableClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TableClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TableClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TableClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return TableClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// UsagesClientListByLocationPager provides operations for iterating over paged responses.
type UsagesClientListByLocationPager struct {
	client    *UsagesClient
	current   UsagesClientListByLocationResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *UsagesClientListByLocationPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *UsagesClientListByLocationPager) NextPage(ctx context.Context) (UsagesClientListByLocationResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return UsagesClientListByLocationResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return UsagesClientListByLocationResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return UsagesClientListByLocationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return UsagesClientListByLocationResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		return UsagesClientListByLocationResponse{}, err
	}
	p.current = result
	return p.current, nil
}
