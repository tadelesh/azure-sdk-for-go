//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armtestbase

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"time"
)

// AccountsClientCheckPackageNameAvailabilityResponse contains the response from method AccountsClient.CheckPackageNameAvailability.
type AccountsClientCheckPackageNameAvailabilityResponse struct {
	CheckNameAvailabilityResult
}

// AccountsClientCreatePollerResponse contains the response from method AccountsClient.Create.
type AccountsClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AccountsClientCreatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AccountsClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AccountsClientCreateResponse, error) {
	respType := AccountsClientCreateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AccountResource)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a AccountsClientCreatePollerResponse from the provided client and resume token.
func (l *AccountsClientCreatePollerResponse) Resume(ctx context.Context, client *AccountsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AccountsClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AccountsClientCreatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// AccountsClientCreateResponse contains the response from method AccountsClient.Create.
type AccountsClientCreateResponse struct {
	AccountResource
}

// AccountsClientDeletePollerResponse contains the response from method AccountsClient.Delete.
type AccountsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AccountsClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AccountsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AccountsClientDeleteResponse, error) {
	respType := AccountsClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a AccountsClientDeletePollerResponse from the provided client and resume token.
func (l *AccountsClientDeletePollerResponse) Resume(ctx context.Context, client *AccountsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AccountsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AccountsClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// AccountsClientDeleteResponse contains the response from method AccountsClient.Delete.
type AccountsClientDeleteResponse struct {
	// placeholder for future response values
}

// AccountsClientGetFileUploadURLResponse contains the response from method AccountsClient.GetFileUploadURL.
type AccountsClientGetFileUploadURLResponse struct {
	FileUploadURLResponse
}

// AccountsClientGetResponse contains the response from method AccountsClient.Get.
type AccountsClientGetResponse struct {
	AccountResource
}

// AccountsClientListByResourceGroupResponse contains the response from method AccountsClient.ListByResourceGroup.
type AccountsClientListByResourceGroupResponse struct {
	AccountListResult
}

// AccountsClientListBySubscriptionResponse contains the response from method AccountsClient.ListBySubscription.
type AccountsClientListBySubscriptionResponse struct {
	AccountListResult
}

// AccountsClientOffboardPollerResponse contains the response from method AccountsClient.Offboard.
type AccountsClientOffboardPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AccountsClientOffboardPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AccountsClientOffboardPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AccountsClientOffboardResponse, error) {
	respType := AccountsClientOffboardResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a AccountsClientOffboardPollerResponse from the provided client and resume token.
func (l *AccountsClientOffboardPollerResponse) Resume(ctx context.Context, client *AccountsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AccountsClient.Offboard", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AccountsClientOffboardPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// AccountsClientOffboardResponse contains the response from method AccountsClient.Offboard.
type AccountsClientOffboardResponse struct {
	// placeholder for future response values
}

// AccountsClientUpdatePollerResponse contains the response from method AccountsClient.Update.
type AccountsClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *AccountsClientUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l AccountsClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (AccountsClientUpdateResponse, error) {
	respType := AccountsClientUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.AccountResource)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a AccountsClientUpdatePollerResponse from the provided client and resume token.
func (l *AccountsClientUpdatePollerResponse) Resume(ctx context.Context, client *AccountsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("AccountsClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &AccountsClientUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// AccountsClientUpdateResponse contains the response from method AccountsClient.Update.
type AccountsClientUpdateResponse struct {
	AccountResource
}

// AnalysisResultsClientGetResponse contains the response from method AnalysisResultsClient.Get.
type AnalysisResultsClientGetResponse struct {
	AnalysisResultSingletonResource
}

// AnalysisResultsClientListResponse contains the response from method AnalysisResultsClient.List.
type AnalysisResultsClientListResponse struct {
	AnalysisResultListResult
}

// AvailableOSClientGetResponse contains the response from method AvailableOSClient.Get.
type AvailableOSClientGetResponse struct {
	AvailableOSResource
}

// AvailableOSClientListResponse contains the response from method AvailableOSClient.List.
type AvailableOSClientListResponse struct {
	AvailableOSListResult
}

// CustomerEventsClientCreatePollerResponse contains the response from method CustomerEventsClient.Create.
type CustomerEventsClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CustomerEventsClientCreatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CustomerEventsClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CustomerEventsClientCreateResponse, error) {
	respType := CustomerEventsClientCreateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CustomerEventResource)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a CustomerEventsClientCreatePollerResponse from the provided client and resume token.
func (l *CustomerEventsClientCreatePollerResponse) Resume(ctx context.Context, client *CustomerEventsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CustomerEventsClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &CustomerEventsClientCreatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// CustomerEventsClientCreateResponse contains the response from method CustomerEventsClient.Create.
type CustomerEventsClientCreateResponse struct {
	CustomerEventResource
}

// CustomerEventsClientDeletePollerResponse contains the response from method CustomerEventsClient.Delete.
type CustomerEventsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CustomerEventsClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CustomerEventsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CustomerEventsClientDeleteResponse, error) {
	respType := CustomerEventsClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a CustomerEventsClientDeletePollerResponse from the provided client and resume token.
func (l *CustomerEventsClientDeletePollerResponse) Resume(ctx context.Context, client *CustomerEventsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CustomerEventsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &CustomerEventsClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// CustomerEventsClientDeleteResponse contains the response from method CustomerEventsClient.Delete.
type CustomerEventsClientDeleteResponse struct {
	// placeholder for future response values
}

// CustomerEventsClientGetResponse contains the response from method CustomerEventsClient.Get.
type CustomerEventsClientGetResponse struct {
	CustomerEventResource
}

// CustomerEventsClientListByTestBaseAccountResponse contains the response from method CustomerEventsClient.ListByTestBaseAccount.
type CustomerEventsClientListByTestBaseAccountResponse struct {
	CustomerEventListResult
}

// EmailEventsClientGetResponse contains the response from method EmailEventsClient.Get.
type EmailEventsClientGetResponse struct {
	EmailEventResource
}

// EmailEventsClientListResponse contains the response from method EmailEventsClient.List.
type EmailEventsClientListResponse struct {
	EmailEventListResult
}

// FavoriteProcessesClientCreateResponse contains the response from method FavoriteProcessesClient.Create.
type FavoriteProcessesClientCreateResponse struct {
	FavoriteProcessResource
}

// FavoriteProcessesClientDeleteResponse contains the response from method FavoriteProcessesClient.Delete.
type FavoriteProcessesClientDeleteResponse struct {
	// placeholder for future response values
}

// FavoriteProcessesClientGetResponse contains the response from method FavoriteProcessesClient.Get.
type FavoriteProcessesClientGetResponse struct {
	FavoriteProcessResource
}

// FavoriteProcessesClientListResponse contains the response from method FavoriteProcessesClient.List.
type FavoriteProcessesClientListResponse struct {
	FavoriteProcessListResult
}

// FlightingRingsClientGetResponse contains the response from method FlightingRingsClient.Get.
type FlightingRingsClientGetResponse struct {
	FlightingRingResource
}

// FlightingRingsClientListResponse contains the response from method FlightingRingsClient.List.
type FlightingRingsClientListResponse struct {
	FlightingRingListResult
}

// OSUpdatesClientGetResponse contains the response from method OSUpdatesClient.Get.
type OSUpdatesClientGetResponse struct {
	OSUpdateResource
}

// OSUpdatesClientListResponse contains the response from method OSUpdatesClient.List.
type OSUpdatesClientListResponse struct {
	OSUpdateListResult
}

// OperationsClientListResponse contains the response from method OperationsClient.List.
type OperationsClientListResponse struct {
	OperationListResult
}

// PackagesClientCreatePollerResponse contains the response from method PackagesClient.Create.
type PackagesClientCreatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PackagesClientCreatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PackagesClientCreatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PackagesClientCreateResponse, error) {
	respType := PackagesClientCreateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PackageResource)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a PackagesClientCreatePollerResponse from the provided client and resume token.
func (l *PackagesClientCreatePollerResponse) Resume(ctx context.Context, client *PackagesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PackagesClient.Create", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PackagesClientCreatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// PackagesClientCreateResponse contains the response from method PackagesClient.Create.
type PackagesClientCreateResponse struct {
	PackageResource
}

// PackagesClientDeletePollerResponse contains the response from method PackagesClient.Delete.
type PackagesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PackagesClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PackagesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PackagesClientDeleteResponse, error) {
	respType := PackagesClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a PackagesClientDeletePollerResponse from the provided client and resume token.
func (l *PackagesClientDeletePollerResponse) Resume(ctx context.Context, client *PackagesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PackagesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PackagesClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// PackagesClientDeleteResponse contains the response from method PackagesClient.Delete.
type PackagesClientDeleteResponse struct {
	// placeholder for future response values
}

// PackagesClientGetDownloadURLResponse contains the response from method PackagesClient.GetDownloadURL.
type PackagesClientGetDownloadURLResponse struct {
	DownloadURLResponse
}

// PackagesClientGetResponse contains the response from method PackagesClient.Get.
type PackagesClientGetResponse struct {
	PackageResource
}

// PackagesClientHardDeletePollerResponse contains the response from method PackagesClient.HardDelete.
type PackagesClientHardDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PackagesClientHardDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PackagesClientHardDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PackagesClientHardDeleteResponse, error) {
	respType := PackagesClientHardDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a PackagesClientHardDeletePollerResponse from the provided client and resume token.
func (l *PackagesClientHardDeletePollerResponse) Resume(ctx context.Context, client *PackagesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PackagesClient.HardDelete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PackagesClientHardDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// PackagesClientHardDeleteResponse contains the response from method PackagesClient.HardDelete.
type PackagesClientHardDeleteResponse struct {
	// placeholder for future response values
}

// PackagesClientListByTestBaseAccountResponse contains the response from method PackagesClient.ListByTestBaseAccount.
type PackagesClientListByTestBaseAccountResponse struct {
	PackageListResult
}

// PackagesClientUpdatePollerResponse contains the response from method PackagesClient.Update.
type PackagesClientUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *PackagesClientUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l PackagesClientUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (PackagesClientUpdateResponse, error) {
	respType := PackagesClientUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.PackageResource)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a PackagesClientUpdatePollerResponse from the provided client and resume token.
func (l *PackagesClientUpdatePollerResponse) Resume(ctx context.Context, client *PackagesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("PackagesClient.Update", token, client.pl)
	if err != nil {
		return err
	}
	poller := &PackagesClientUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// PackagesClientUpdateResponse contains the response from method PackagesClient.Update.
type PackagesClientUpdateResponse struct {
	PackageResource
}

// SKUsClientListResponse contains the response from method SKUsClient.List.
type SKUsClientListResponse struct {
	AccountSKUListResult
}

// TestResultsClientGetDownloadURLResponse contains the response from method TestResultsClient.GetDownloadURL.
type TestResultsClientGetDownloadURLResponse struct {
	DownloadURLResponse
}

// TestResultsClientGetResponse contains the response from method TestResultsClient.Get.
type TestResultsClientGetResponse struct {
	TestResultResource
}

// TestResultsClientGetVideoDownloadURLResponse contains the response from method TestResultsClient.GetVideoDownloadURL.
type TestResultsClientGetVideoDownloadURLResponse struct {
	DownloadURLResponse
}

// TestResultsClientListResponse contains the response from method TestResultsClient.List.
type TestResultsClientListResponse struct {
	TestResultListResult
}

// TestSummariesClientGetResponse contains the response from method TestSummariesClient.Get.
type TestSummariesClientGetResponse struct {
	TestSummaryResource
}

// TestSummariesClientListResponse contains the response from method TestSummariesClient.List.
type TestSummariesClientListResponse struct {
	TestSummaryListResult
}

// TestTypesClientGetResponse contains the response from method TestTypesClient.Get.
type TestTypesClientGetResponse struct {
	TestTypeResource
}

// TestTypesClientListResponse contains the response from method TestTypesClient.List.
type TestTypesClientListResponse struct {
	TestTypeListResult
}

// UsageClientListResponse contains the response from method UsageClient.List.
type UsageClientListResponse struct {
	AccountUsageDataList
}
