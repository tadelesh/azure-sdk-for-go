//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armstorSimple1200Series

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AccessControlRecordsClientListByManagerPager provides operations for iterating over paged responses.
type AccessControlRecordsClientListByManagerPager struct {
	client    *AccessControlRecordsClient
	current   AccessControlRecordsClientListByManagerResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AccessControlRecordsClientListByManagerPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *AccessControlRecordsClientListByManagerPager) NextPage(ctx context.Context) (AccessControlRecordsClientListByManagerResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return AccessControlRecordsClientListByManagerResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AccessControlRecordsClientListByManagerResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AccessControlRecordsClientListByManagerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AccessControlRecordsClientListByManagerResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByManagerHandleResponse(resp)
	if err != nil {
		return AccessControlRecordsClientListByManagerResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AlertsClientListByManagerPager provides operations for iterating over paged responses.
type AlertsClientListByManagerPager struct {
	client    *AlertsClient
	current   AlertsClientListByManagerResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AlertsClientListByManagerResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AlertsClientListByManagerPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AlertList.NextLink == nil || len(*p.current.AlertList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AlertsClientListByManagerPager) NextPage(ctx context.Context) (AlertsClientListByManagerResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AlertsClientListByManagerResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AlertsClientListByManagerResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AlertsClientListByManagerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AlertsClientListByManagerResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByManagerHandleResponse(resp)
	if err != nil {
		return AlertsClientListByManagerResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AvailableProviderOperationsClientListPager provides operations for iterating over paged responses.
type AvailableProviderOperationsClientListPager struct {
	client    *AvailableProviderOperationsClient
	current   AvailableProviderOperationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailableProviderOperationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AvailableProviderOperationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailableProviderOperations.NextLink == nil || len(*p.current.AvailableProviderOperations.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AvailableProviderOperationsClientListPager) NextPage(ctx context.Context) (AvailableProviderOperationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AvailableProviderOperationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AvailableProviderOperationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AvailableProviderOperationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AvailableProviderOperationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return AvailableProviderOperationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BackupScheduleGroupsClientListByDevicePager provides operations for iterating over paged responses.
type BackupScheduleGroupsClientListByDevicePager struct {
	client    *BackupScheduleGroupsClient
	current   BackupScheduleGroupsClientListByDeviceResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BackupScheduleGroupsClientListByDevicePager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *BackupScheduleGroupsClientListByDevicePager) NextPage(ctx context.Context) (BackupScheduleGroupsClientListByDeviceResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return BackupScheduleGroupsClientListByDeviceResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BackupScheduleGroupsClientListByDeviceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BackupScheduleGroupsClientListByDeviceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BackupScheduleGroupsClientListByDeviceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByDeviceHandleResponse(resp)
	if err != nil {
		return BackupScheduleGroupsClientListByDeviceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BackupsClientListByDevicePager provides operations for iterating over paged responses.
type BackupsClientListByDevicePager struct {
	client    *BackupsClient
	current   BackupsClientListByDeviceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BackupsClientListByDeviceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BackupsClientListByDevicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BackupList.NextLink == nil || len(*p.current.BackupList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *BackupsClientListByDevicePager) NextPage(ctx context.Context) (BackupsClientListByDeviceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return BackupsClientListByDeviceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BackupsClientListByDeviceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BackupsClientListByDeviceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BackupsClientListByDeviceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByDeviceHandleResponse(resp)
	if err != nil {
		return BackupsClientListByDeviceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BackupsClientListByManagerPager provides operations for iterating over paged responses.
type BackupsClientListByManagerPager struct {
	client    *BackupsClient
	current   BackupsClientListByManagerResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BackupsClientListByManagerResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BackupsClientListByManagerPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BackupList.NextLink == nil || len(*p.current.BackupList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *BackupsClientListByManagerPager) NextPage(ctx context.Context) (BackupsClientListByManagerResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return BackupsClientListByManagerResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BackupsClientListByManagerResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BackupsClientListByManagerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BackupsClientListByManagerResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByManagerHandleResponse(resp)
	if err != nil {
		return BackupsClientListByManagerResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ChapSettingsClientListByDevicePager provides operations for iterating over paged responses.
type ChapSettingsClientListByDevicePager struct {
	client    *ChapSettingsClient
	current   ChapSettingsClientListByDeviceResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ChapSettingsClientListByDevicePager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *ChapSettingsClientListByDevicePager) NextPage(ctx context.Context) (ChapSettingsClientListByDeviceResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return ChapSettingsClientListByDeviceResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ChapSettingsClientListByDeviceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ChapSettingsClientListByDeviceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ChapSettingsClientListByDeviceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByDeviceHandleResponse(resp)
	if err != nil {
		return ChapSettingsClientListByDeviceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DevicesClientListByManagerPager provides operations for iterating over paged responses.
type DevicesClientListByManagerPager struct {
	client    *DevicesClient
	current   DevicesClientListByManagerResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DevicesClientListByManagerPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *DevicesClientListByManagerPager) NextPage(ctx context.Context) (DevicesClientListByManagerResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return DevicesClientListByManagerResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DevicesClientListByManagerResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DevicesClientListByManagerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DevicesClientListByManagerResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByManagerHandleResponse(resp)
	if err != nil {
		return DevicesClientListByManagerResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DevicesClientListFailoverTargetPager provides operations for iterating over paged responses.
type DevicesClientListFailoverTargetPager struct {
	client    *DevicesClient
	current   DevicesClientListFailoverTargetResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DevicesClientListFailoverTargetPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *DevicesClientListFailoverTargetPager) NextPage(ctx context.Context) (DevicesClientListFailoverTargetResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return DevicesClientListFailoverTargetResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DevicesClientListFailoverTargetResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DevicesClientListFailoverTargetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DevicesClientListFailoverTargetResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listFailoverTargetHandleResponse(resp)
	if err != nil {
		return DevicesClientListFailoverTargetResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DevicesClientListMetricDefinitionPager provides operations for iterating over paged responses.
type DevicesClientListMetricDefinitionPager struct {
	client    *DevicesClient
	current   DevicesClientListMetricDefinitionResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DevicesClientListMetricDefinitionPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *DevicesClientListMetricDefinitionPager) NextPage(ctx context.Context) (DevicesClientListMetricDefinitionResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return DevicesClientListMetricDefinitionResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DevicesClientListMetricDefinitionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DevicesClientListMetricDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DevicesClientListMetricDefinitionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricDefinitionHandleResponse(resp)
	if err != nil {
		return DevicesClientListMetricDefinitionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DevicesClientListMetricsPager provides operations for iterating over paged responses.
type DevicesClientListMetricsPager struct {
	client    *DevicesClient
	current   DevicesClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DevicesClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *DevicesClientListMetricsPager) NextPage(ctx context.Context) (DevicesClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return DevicesClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DevicesClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DevicesClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DevicesClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return DevicesClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// FileServersClientListByDevicePager provides operations for iterating over paged responses.
type FileServersClientListByDevicePager struct {
	client    *FileServersClient
	current   FileServersClientListByDeviceResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *FileServersClientListByDevicePager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *FileServersClientListByDevicePager) NextPage(ctx context.Context) (FileServersClientListByDeviceResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return FileServersClientListByDeviceResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return FileServersClientListByDeviceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return FileServersClientListByDeviceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return FileServersClientListByDeviceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByDeviceHandleResponse(resp)
	if err != nil {
		return FileServersClientListByDeviceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// FileServersClientListByManagerPager provides operations for iterating over paged responses.
type FileServersClientListByManagerPager struct {
	client    *FileServersClient
	current   FileServersClientListByManagerResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *FileServersClientListByManagerPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *FileServersClientListByManagerPager) NextPage(ctx context.Context) (FileServersClientListByManagerResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return FileServersClientListByManagerResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return FileServersClientListByManagerResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return FileServersClientListByManagerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return FileServersClientListByManagerResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByManagerHandleResponse(resp)
	if err != nil {
		return FileServersClientListByManagerResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// FileServersClientListMetricDefinitionPager provides operations for iterating over paged responses.
type FileServersClientListMetricDefinitionPager struct {
	client    *FileServersClient
	current   FileServersClientListMetricDefinitionResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *FileServersClientListMetricDefinitionPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *FileServersClientListMetricDefinitionPager) NextPage(ctx context.Context) (FileServersClientListMetricDefinitionResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return FileServersClientListMetricDefinitionResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return FileServersClientListMetricDefinitionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return FileServersClientListMetricDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return FileServersClientListMetricDefinitionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricDefinitionHandleResponse(resp)
	if err != nil {
		return FileServersClientListMetricDefinitionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// FileServersClientListMetricsPager provides operations for iterating over paged responses.
type FileServersClientListMetricsPager struct {
	client    *FileServersClient
	current   FileServersClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *FileServersClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *FileServersClientListMetricsPager) NextPage(ctx context.Context) (FileServersClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return FileServersClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return FileServersClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return FileServersClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return FileServersClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return FileServersClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// FileSharesClientListByDevicePager provides operations for iterating over paged responses.
type FileSharesClientListByDevicePager struct {
	client    *FileSharesClient
	current   FileSharesClientListByDeviceResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *FileSharesClientListByDevicePager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *FileSharesClientListByDevicePager) NextPage(ctx context.Context) (FileSharesClientListByDeviceResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return FileSharesClientListByDeviceResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return FileSharesClientListByDeviceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return FileSharesClientListByDeviceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return FileSharesClientListByDeviceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByDeviceHandleResponse(resp)
	if err != nil {
		return FileSharesClientListByDeviceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// FileSharesClientListByFileServerPager provides operations for iterating over paged responses.
type FileSharesClientListByFileServerPager struct {
	client    *FileSharesClient
	current   FileSharesClientListByFileServerResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *FileSharesClientListByFileServerPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *FileSharesClientListByFileServerPager) NextPage(ctx context.Context) (FileSharesClientListByFileServerResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return FileSharesClientListByFileServerResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return FileSharesClientListByFileServerResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return FileSharesClientListByFileServerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return FileSharesClientListByFileServerResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByFileServerHandleResponse(resp)
	if err != nil {
		return FileSharesClientListByFileServerResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// FileSharesClientListMetricDefinitionPager provides operations for iterating over paged responses.
type FileSharesClientListMetricDefinitionPager struct {
	client    *FileSharesClient
	current   FileSharesClientListMetricDefinitionResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *FileSharesClientListMetricDefinitionPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *FileSharesClientListMetricDefinitionPager) NextPage(ctx context.Context) (FileSharesClientListMetricDefinitionResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return FileSharesClientListMetricDefinitionResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return FileSharesClientListMetricDefinitionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return FileSharesClientListMetricDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return FileSharesClientListMetricDefinitionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricDefinitionHandleResponse(resp)
	if err != nil {
		return FileSharesClientListMetricDefinitionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// FileSharesClientListMetricsPager provides operations for iterating over paged responses.
type FileSharesClientListMetricsPager struct {
	client    *FileSharesClient
	current   FileSharesClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *FileSharesClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *FileSharesClientListMetricsPager) NextPage(ctx context.Context) (FileSharesClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return FileSharesClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return FileSharesClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return FileSharesClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return FileSharesClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return FileSharesClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IscsiDisksClientListByDevicePager provides operations for iterating over paged responses.
type IscsiDisksClientListByDevicePager struct {
	client    *IscsiDisksClient
	current   IscsiDisksClientListByDeviceResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IscsiDisksClientListByDevicePager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *IscsiDisksClientListByDevicePager) NextPage(ctx context.Context) (IscsiDisksClientListByDeviceResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return IscsiDisksClientListByDeviceResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IscsiDisksClientListByDeviceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IscsiDisksClientListByDeviceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IscsiDisksClientListByDeviceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByDeviceHandleResponse(resp)
	if err != nil {
		return IscsiDisksClientListByDeviceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IscsiDisksClientListByIscsiServerPager provides operations for iterating over paged responses.
type IscsiDisksClientListByIscsiServerPager struct {
	client    *IscsiDisksClient
	current   IscsiDisksClientListByIscsiServerResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IscsiDisksClientListByIscsiServerPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *IscsiDisksClientListByIscsiServerPager) NextPage(ctx context.Context) (IscsiDisksClientListByIscsiServerResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return IscsiDisksClientListByIscsiServerResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IscsiDisksClientListByIscsiServerResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IscsiDisksClientListByIscsiServerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IscsiDisksClientListByIscsiServerResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByIscsiServerHandleResponse(resp)
	if err != nil {
		return IscsiDisksClientListByIscsiServerResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IscsiDisksClientListMetricDefinitionPager provides operations for iterating over paged responses.
type IscsiDisksClientListMetricDefinitionPager struct {
	client    *IscsiDisksClient
	current   IscsiDisksClientListMetricDefinitionResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IscsiDisksClientListMetricDefinitionPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *IscsiDisksClientListMetricDefinitionPager) NextPage(ctx context.Context) (IscsiDisksClientListMetricDefinitionResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return IscsiDisksClientListMetricDefinitionResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IscsiDisksClientListMetricDefinitionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IscsiDisksClientListMetricDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IscsiDisksClientListMetricDefinitionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricDefinitionHandleResponse(resp)
	if err != nil {
		return IscsiDisksClientListMetricDefinitionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IscsiDisksClientListMetricsPager provides operations for iterating over paged responses.
type IscsiDisksClientListMetricsPager struct {
	client    *IscsiDisksClient
	current   IscsiDisksClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IscsiDisksClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *IscsiDisksClientListMetricsPager) NextPage(ctx context.Context) (IscsiDisksClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return IscsiDisksClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IscsiDisksClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IscsiDisksClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IscsiDisksClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return IscsiDisksClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IscsiServersClientListByDevicePager provides operations for iterating over paged responses.
type IscsiServersClientListByDevicePager struct {
	client    *IscsiServersClient
	current   IscsiServersClientListByDeviceResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IscsiServersClientListByDevicePager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *IscsiServersClientListByDevicePager) NextPage(ctx context.Context) (IscsiServersClientListByDeviceResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return IscsiServersClientListByDeviceResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IscsiServersClientListByDeviceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IscsiServersClientListByDeviceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IscsiServersClientListByDeviceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByDeviceHandleResponse(resp)
	if err != nil {
		return IscsiServersClientListByDeviceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IscsiServersClientListByManagerPager provides operations for iterating over paged responses.
type IscsiServersClientListByManagerPager struct {
	client    *IscsiServersClient
	current   IscsiServersClientListByManagerResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IscsiServersClientListByManagerPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *IscsiServersClientListByManagerPager) NextPage(ctx context.Context) (IscsiServersClientListByManagerResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return IscsiServersClientListByManagerResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IscsiServersClientListByManagerResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IscsiServersClientListByManagerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IscsiServersClientListByManagerResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByManagerHandleResponse(resp)
	if err != nil {
		return IscsiServersClientListByManagerResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IscsiServersClientListMetricDefinitionPager provides operations for iterating over paged responses.
type IscsiServersClientListMetricDefinitionPager struct {
	client    *IscsiServersClient
	current   IscsiServersClientListMetricDefinitionResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IscsiServersClientListMetricDefinitionPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *IscsiServersClientListMetricDefinitionPager) NextPage(ctx context.Context) (IscsiServersClientListMetricDefinitionResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return IscsiServersClientListMetricDefinitionResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IscsiServersClientListMetricDefinitionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IscsiServersClientListMetricDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IscsiServersClientListMetricDefinitionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricDefinitionHandleResponse(resp)
	if err != nil {
		return IscsiServersClientListMetricDefinitionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IscsiServersClientListMetricsPager provides operations for iterating over paged responses.
type IscsiServersClientListMetricsPager struct {
	client    *IscsiServersClient
	current   IscsiServersClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IscsiServersClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *IscsiServersClientListMetricsPager) NextPage(ctx context.Context) (IscsiServersClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return IscsiServersClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IscsiServersClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IscsiServersClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IscsiServersClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return IscsiServersClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// JobsClientListByDevicePager provides operations for iterating over paged responses.
type JobsClientListByDevicePager struct {
	client    *JobsClient
	current   JobsClientListByDeviceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobsClientListByDeviceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *JobsClientListByDevicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobList.NextLink == nil || len(*p.current.JobList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *JobsClientListByDevicePager) NextPage(ctx context.Context) (JobsClientListByDeviceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return JobsClientListByDeviceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return JobsClientListByDeviceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return JobsClientListByDeviceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return JobsClientListByDeviceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByDeviceHandleResponse(resp)
	if err != nil {
		return JobsClientListByDeviceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// JobsClientListByManagerPager provides operations for iterating over paged responses.
type JobsClientListByManagerPager struct {
	client    *JobsClient
	current   JobsClientListByManagerResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobsClientListByManagerResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *JobsClientListByManagerPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobList.NextLink == nil || len(*p.current.JobList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *JobsClientListByManagerPager) NextPage(ctx context.Context) (JobsClientListByManagerResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return JobsClientListByManagerResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return JobsClientListByManagerResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return JobsClientListByManagerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return JobsClientListByManagerResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByManagerHandleResponse(resp)
	if err != nil {
		return JobsClientListByManagerResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ManagersClientListByResourceGroupPager provides operations for iterating over paged responses.
type ManagersClientListByResourceGroupPager struct {
	client    *ManagersClient
	current   ManagersClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ManagersClientListByResourceGroupPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *ManagersClientListByResourceGroupPager) NextPage(ctx context.Context) (ManagersClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return ManagersClientListByResourceGroupResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ManagersClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ManagersClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ManagersClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return ManagersClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ManagersClientListMetricDefinitionPager provides operations for iterating over paged responses.
type ManagersClientListMetricDefinitionPager struct {
	client    *ManagersClient
	current   ManagersClientListMetricDefinitionResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ManagersClientListMetricDefinitionPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *ManagersClientListMetricDefinitionPager) NextPage(ctx context.Context) (ManagersClientListMetricDefinitionResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return ManagersClientListMetricDefinitionResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ManagersClientListMetricDefinitionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ManagersClientListMetricDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ManagersClientListMetricDefinitionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricDefinitionHandleResponse(resp)
	if err != nil {
		return ManagersClientListMetricDefinitionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ManagersClientListMetricsPager provides operations for iterating over paged responses.
type ManagersClientListMetricsPager struct {
	client    *ManagersClient
	current   ManagersClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ManagersClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *ManagersClientListMetricsPager) NextPage(ctx context.Context) (ManagersClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return ManagersClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ManagersClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ManagersClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ManagersClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return ManagersClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ManagersClientListPager provides operations for iterating over paged responses.
type ManagersClientListPager struct {
	client    *ManagersClient
	current   ManagersClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ManagersClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *ManagersClientListPager) NextPage(ctx context.Context) (ManagersClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return ManagersClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ManagersClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ManagersClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ManagersClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ManagersClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// StorageAccountCredentialsClientListByManagerPager provides operations for iterating over paged responses.
type StorageAccountCredentialsClientListByManagerPager struct {
	client    *StorageAccountCredentialsClient
	current   StorageAccountCredentialsClientListByManagerResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *StorageAccountCredentialsClientListByManagerPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *StorageAccountCredentialsClientListByManagerPager) NextPage(ctx context.Context) (StorageAccountCredentialsClientListByManagerResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return StorageAccountCredentialsClientListByManagerResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return StorageAccountCredentialsClientListByManagerResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return StorageAccountCredentialsClientListByManagerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return StorageAccountCredentialsClientListByManagerResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByManagerHandleResponse(resp)
	if err != nil {
		return StorageAccountCredentialsClientListByManagerResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// StorageDomainsClientListByManagerPager provides operations for iterating over paged responses.
type StorageDomainsClientListByManagerPager struct {
	client    *StorageDomainsClient
	current   StorageDomainsClientListByManagerResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *StorageDomainsClientListByManagerPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *StorageDomainsClientListByManagerPager) NextPage(ctx context.Context) (StorageDomainsClientListByManagerResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return StorageDomainsClientListByManagerResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return StorageDomainsClientListByManagerResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return StorageDomainsClientListByManagerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return StorageDomainsClientListByManagerResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByManagerHandleResponse(resp)
	if err != nil {
		return StorageDomainsClientListByManagerResponse{}, err
	}
	p.current = result
	return p.current, nil
}
