//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armstoragecache_test

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"runtime/debug"
	"testing"

	"encoding/json"
	"reflect"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/resourcemanager/storagecache/armstoragecache"
	"golang.org/x/net/http2"
)

var (
	ctx      context.Context
	options  arm.ClientOptions
	cred     azcore.TokenCredential
	err      error
	mockHost string
)

func TestOperations_List(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Operations_List.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"StorageTargets_List"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewOperationsClient(cred, &options)
	pager := client.List(nil)
	for pager.More() {
		nextResult, err := pager.NextPage(ctx)
		if err != nil {
			t.Fatalf("Failed to advance page for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Operations_List.json: %v", err)
			break
		}
		// Response check
		pagerExampleRes := armstoragecache.APIOperationListResult{
			Value: []*armstoragecache.APIOperation{
				{
					Name: to.Ptr("Microsoft.StorageCache/caches/write"),
					Display: &armstoragecache.APIOperationDisplay{
						Operation: to.Ptr("Create or Update Cache"),
						Provider:  to.Ptr("Azure Storage Cache"),
						Resource:  to.Ptr("Caches"),
					},
				},
				{
					Name: to.Ptr("Microsoft.StorageCache/caches/delete"),
					Display: &armstoragecache.APIOperationDisplay{
						Operation: to.Ptr("Delete Cache"),
						Provider:  to.Ptr("Azure Storage Cache"),
						Resource:  to.Ptr("Caches"),
					},
				},
				{
					Name: to.Ptr("Microsoft.StorageCache/caches/providers/Microsoft.Insights/metricDefinitions/read"),
					Display: &armstoragecache.APIOperationDisplay{
						Description: to.Ptr("Reads Cache Metric Definitions."),
						Operation:   to.Ptr("Get Cache Metric Definitions"),
						Provider:    to.Ptr("Microsoft Azure HPC Cache"),
						Resource:    to.Ptr("StorageCache Metric Definitions"),
					},
					IsDataAction: to.Ptr(false),
					Origin:       to.Ptr("system"),
					Properties: &armstoragecache.APIOperationProperties{
						ServiceSpecification: &armstoragecache.APIOperationPropertiesServiceSpecification{
							MetricSpecifications: []*armstoragecache.MetricSpecification{
								{
									Name:               to.Ptr("ClientIOPS"),
									AggregationType:    to.Ptr("Average"),
									DisplayDescription: to.Ptr("The rate of client file operations processed by the Cache."),
									DisplayName:        to.Ptr("Total Client IOPS"),
									MetricClass:        to.Ptr("Transactions"),
									SupportedAggregationTypes: []*armstoragecache.MetricAggregationType{
										to.Ptr(armstoragecache.MetricAggregationTypeMinimum),
										to.Ptr(armstoragecache.MetricAggregationTypeMaximum),
										to.Ptr(armstoragecache.MetricAggregationTypeAverage)},
									Unit: to.Ptr("Count"),
								},
								{
									Name:               to.Ptr("ClientLatency"),
									AggregationType:    to.Ptr("Average"),
									DisplayDescription: to.Ptr("Average latency of client file operations to the Cache."),
									DisplayName:        to.Ptr("Average Client Latency"),
									MetricClass:        to.Ptr("Latency"),
									SupportedAggregationTypes: []*armstoragecache.MetricAggregationType{
										to.Ptr(armstoragecache.MetricAggregationTypeMinimum),
										to.Ptr(armstoragecache.MetricAggregationTypeMaximum),
										to.Ptr(armstoragecache.MetricAggregationTypeAverage)},
									Unit: to.Ptr("Milliseconds"),
								}},
						},
					},
				}},
		}
		if !reflect.DeepEqual(pagerExampleRes, nextResult.APIOperationListResult) {
			exampleResJson, _ := json.Marshal(pagerExampleRes)
			mockResJson, _ := json.Marshal(nextResult.APIOperationListResult)
			t.Fatalf("Mock response is not equal to example response for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Operations_List.json:\nmock response: %s\nexample response: %s", mockResJson, exampleResJson)
		}
	}
}

func TestSKUs_List(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Skus_List.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"Skus_List"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewSKUsClient("00000000-0000-0000-0000-000000000000", cred, &options)
	pager := client.List(nil)
	for pager.More() {
		nextResult, err := pager.NextPage(ctx)
		if err != nil {
			t.Fatalf("Failed to advance page for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Skus_List.json: %v", err)
			break
		}
		// Response check
		pagerExampleRes := armstoragecache.ResourceSKUsResult{
			Value: []*armstoragecache.ResourceSKU{
				{
					Name: to.Ptr("Standard_2G"),
					Capabilities: []*armstoragecache.ResourceSKUCapabilities{
						{
							Name:  to.Ptr("throughput GB/s"),
							Value: to.Ptr("2"),
						},
						{
							Name:  to.Ptr("cache sizes(GB)"),
							Value: to.Ptr("3072,6144,12288"),
						}},
					LocationInfo: []*armstoragecache.ResourceSKULocationInfo{
						{
							Location: to.Ptr("eastus"),
							Zones:    []*string{},
						}},
					Locations: []*string{
						to.Ptr("eastus")},
					ResourceType: to.Ptr("caches"),
					Restrictions: []*armstoragecache.Restriction{},
				},
				{
					Name: to.Ptr("Standard_4G"),
					Capabilities: []*armstoragecache.ResourceSKUCapabilities{
						{
							Name:  to.Ptr("throughput GB/s"),
							Value: to.Ptr("4"),
						},
						{
							Name:  to.Ptr("cache sizes(GB)"),
							Value: to.Ptr("6144,12288,24576"),
						}},
					LocationInfo: []*armstoragecache.ResourceSKULocationInfo{
						{
							Location: to.Ptr("eastus"),
							Zones:    []*string{},
						}},
					Locations: []*string{
						to.Ptr("eastus")},
					ResourceType: to.Ptr("caches"),
					Restrictions: []*armstoragecache.Restriction{},
				},
				{
					Name: to.Ptr("Standard_8G"),
					Capabilities: []*armstoragecache.ResourceSKUCapabilities{
						{
							Name:  to.Ptr("throughput GB/s"),
							Value: to.Ptr("8"),
						},
						{
							Name:  to.Ptr("cache sizes(GB)"),
							Value: to.Ptr("12288,24576,49152"),
						}},
					LocationInfo: []*armstoragecache.ResourceSKULocationInfo{
						{
							Location: to.Ptr("eastus"),
							Zones:    []*string{},
						}},
					Locations: []*string{
						to.Ptr("eastus")},
					ResourceType: to.Ptr("caches"),
					Restrictions: []*armstoragecache.Restriction{},
				}},
		}
		if !reflect.DeepEqual(pagerExampleRes, nextResult.ResourceSKUsResult) {
			exampleResJson, _ := json.Marshal(pagerExampleRes)
			mockResJson, _ := json.Marshal(nextResult.ResourceSKUsResult)
			t.Fatalf("Mock response is not equal to example response for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Skus_List.json:\nmock response: %s\nexample response: %s", mockResJson, exampleResJson)
		}
	}
}

func TestUsageModels_List(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/UsageModels_List.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"UsageModels_List"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewUsageModelsClient("00000000-0000-0000-0000-000000000000", cred, &options)
	pager := client.List(nil)
	for pager.More() {
		nextResult, err := pager.NextPage(ctx)
		if err != nil {
			t.Fatalf("Failed to advance page for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/UsageModels_List.json: %v", err)
			break
		}
		// Response check
		pagerExampleRes := armstoragecache.UsageModelsResult{
			Value: []*armstoragecache.UsageModel{
				{
					Display: &armstoragecache.UsageModelDisplay{
						Description: to.Ptr("Read heavy, infrequent changes"),
					},
					ModelName:  to.Ptr("READ_HEAVY_INFREQ"),
					TargetType: to.Ptr("nfs3"),
				},
				{
					Display: &armstoragecache.UsageModelDisplay{
						Description: to.Ptr("Clients write directly to storage"),
					},
					ModelName:  to.Ptr("WRITE_AROUND"),
					TargetType: to.Ptr("nfs3"),
				},
				{
					Display: &armstoragecache.UsageModelDisplay{
						Description: to.Ptr("Write workload > 15%"),
					},
					ModelName:  to.Ptr("WRITE_WORKLOAD_15"),
					TargetType: to.Ptr("nfs3"),
				}},
		}
		if !reflect.DeepEqual(pagerExampleRes, nextResult.UsageModelsResult) {
			exampleResJson, _ := json.Marshal(pagerExampleRes)
			mockResJson, _ := json.Marshal(nextResult.UsageModelsResult)
			t.Fatalf("Mock response is not equal to example response for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/UsageModels_List.json:\nmock response: %s\nexample response: %s", mockResJson, exampleResJson)
		}
	}
}

func TestAscOperations_Get(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/AscOperations_Get.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"AscOperations_Get"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewAscOperationsClient("00000000-0000-0000-0000-000000000000", cred, &options)
	res, err := client.Get(ctx,
		"westus",
		"testoperationid",
		nil)
	if err != nil {
		t.Fatalf("Failed to get result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/AscOperations_Get.json: %v", err)
	}
	// Response check
	{
		exampleRes := armstoragecache.AscOperation{
			Name:      to.Ptr("testoperationid"),
			EndTime:   to.Ptr("2021-09-01T16:13:13.933Z"),
			ID:        to.Ptr("/subscriptions/id/locations/westus/ascOperations/testoperationid"),
			StartTime: to.Ptr("2021-09-01T13:13:13.933Z"),
			Status:    to.Ptr("Succeeded"),
		}
		if !reflect.DeepEqual(exampleRes, res.AscOperation) {
			exampleResJson, _ := json.Marshal(exampleRes)
			mockResJson, _ := json.Marshal(res.AscOperation)
			t.Fatalf("Mock response is not equal to example response for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/AscOperations_Get.json:\nmock response: %s\nexample response: %s", mockResJson, exampleResJson)
		}
	}
}

func TestCaches_List(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_List.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"Caches_List"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewCachesClient("00000000-0000-0000-0000-000000000000", cred, &options)
	pager := client.List(nil)
	for pager.More() {
		nextResult, err := pager.NextPage(ctx)
		if err != nil {
			t.Fatalf("Failed to advance page for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_List.json: %v", err)
			break
		}
		// Response check
		pagerExampleRes := armstoragecache.CachesListResult{
			Value: []*armstoragecache.Cache{
				{
					Name:     to.Ptr("sc1"),
					Type:     to.Ptr("Microsoft.StorageCache/Cache"),
					ID:       to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.StorageCache/caches/sc1"),
					Location: to.Ptr("westus"),
					Properties: &armstoragecache.CacheProperties{
						CacheSizeGB: to.Ptr[int32](3072),
						DirectoryServicesSettings: &armstoragecache.CacheDirectorySettings{
							ActiveDirectory: &armstoragecache.CacheActiveDirectorySettings{
								CacheNetBiosName:      to.Ptr("contosoSmb"),
								DomainJoined:          to.Ptr(armstoragecache.DomainJoinedTypeYes),
								DomainName:            to.Ptr("contosoAd.contoso.local"),
								DomainNetBiosName:     to.Ptr("contosoAd"),
								PrimaryDNSIPAddress:   to.Ptr("192.0.2.10"),
								SecondaryDNSIPAddress: to.Ptr("192.0.2.11"),
							},
							UsernameDownload: &armstoragecache.CacheUsernameDownloadSettings{
								AutoDownloadCertificate: to.Ptr(false),
								CaCertificateURI:        to.Ptr(""),
								EncryptLdapConnection:   to.Ptr(false),
								ExtendedGroups:          to.Ptr(true),
								GroupFileURI:            to.Ptr(""),
								LdapBaseDN:              to.Ptr("dc=contosoad,dc=contoso,dc=local"),
								LdapServer:              to.Ptr("192.0.2.12"),
								RequireValidCertificate: to.Ptr(false),
								UserFileURI:             to.Ptr(""),
								UsernameDownloaded:      to.Ptr(armstoragecache.UsernameDownloadedTypeYes),
								UsernameSource:          to.Ptr(armstoragecache.UsernameSourceLDAP),
							},
						},
						EncryptionSettings: &armstoragecache.CacheEncryptionSettings{
							KeyEncryptionKey: &armstoragecache.KeyVaultKeyReference{
								KeyURL: to.Ptr("https://keyvault-cmk.vault.azure.net/keys/key2048/test"),
								SourceVault: &armstoragecache.KeyVaultKeyReferenceSourceVault{
									ID: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.KeyVault/vaults/keyvault-cmk"),
								},
							},
						},
						Health: &armstoragecache.CacheHealth{
							Conditions: []*armstoragecache.Condition{
								{
									Message:   to.Ptr("Cannot contact DNS server"),
									Timestamp: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2021-04-21T18:25:43.511Z"); return t }()),
								}},
							State:             to.Ptr(armstoragecache.HealthStateTypeTransitioning),
							StatusDescription: to.Ptr("Cache is being created."),
						},
						MountAddresses: []*string{
							to.Ptr("192.168.1.1"),
							to.Ptr("192.168.1.2")},
						NetworkSettings: &armstoragecache.CacheNetworkSettings{
							DNSSearchDomain: to.Ptr("contoso.com"),
							DNSServers: []*string{
								to.Ptr("10.1.22.33"),
								to.Ptr("10.1.12.33")},
							Mtu:       to.Ptr[int32](1500),
							NtpServer: to.Ptr("time.contoso.com"),
						},
						ProvisioningState: to.Ptr(armstoragecache.ProvisioningStateTypeSucceeded),
						SecuritySettings: &armstoragecache.CacheSecuritySettings{
							AccessPolicies: []*armstoragecache.NfsAccessPolicy{
								{
									Name: to.Ptr("default"),
									AccessRules: []*armstoragecache.NfsAccessRule{
										{
											Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessRw),
											RootSquash:     to.Ptr(false),
											Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeDefault),
											SubmountAccess: to.Ptr(true),
											Suid:           to.Ptr(false),
										}},
								}},
						},
						Subnet: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.Network/virtualNetworks/scvnet/subnets/sub1"),
						UpgradeStatus: &armstoragecache.CacheUpgradeStatus{
							CurrentFirmwareVersion: to.Ptr("V5.1.12"),
							FirmwareUpdateDeadline: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2019-04-21T18:25:43.511Z"); return t }()),
							FirmwareUpdateStatus:   to.Ptr(armstoragecache.FirmwareStatusTypeAvailable),
							LastFirmwareUpdate:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2019-01-21T18:25:43.511Z"); return t }()),
							PendingFirmwareVersion: to.Ptr("V5.1.15"),
						},
					},
					SKU: &armstoragecache.CacheSKU{
						Name: to.Ptr("Standard_2G"),
					},
					SystemData: &armstoragecache.SystemData{
						CreatedAt:          to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-01T17:18:19.1234567Z"); return t }()),
						CreatedBy:          to.Ptr("user1"),
						CreatedByType:      to.Ptr(armstoragecache.CreatedByTypeUser),
						LastModifiedAt:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-02T17:18:19.1234567Z"); return t }()),
						LastModifiedBy:     to.Ptr("user2"),
						LastModifiedByType: to.Ptr(armstoragecache.CreatedByTypeUser),
					},
					Tags: map[string]*string{
						"Dept": to.Ptr("Contoso"),
					},
				},
				{
					Name:     to.Ptr("sc2"),
					Type:     to.Ptr("Microsoft.StorageCache/Cache"),
					ID:       to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.StorageCache/caches/sc2"),
					Location: to.Ptr("westus"),
					Properties: &armstoragecache.CacheProperties{
						CacheSizeGB: to.Ptr[int32](3072),
						DirectoryServicesSettings: &armstoragecache.CacheDirectorySettings{
							ActiveDirectory: &armstoragecache.CacheActiveDirectorySettings{
								CacheNetBiosName:      to.Ptr("contosoSmb"),
								DomainJoined:          to.Ptr(armstoragecache.DomainJoinedTypeYes),
								DomainName:            to.Ptr("contosoAd.contoso.local"),
								DomainNetBiosName:     to.Ptr("contosoAd"),
								PrimaryDNSIPAddress:   to.Ptr("192.0.2.10"),
								SecondaryDNSIPAddress: to.Ptr("192.0.2.11"),
							},
							UsernameDownload: &armstoragecache.CacheUsernameDownloadSettings{
								AutoDownloadCertificate: to.Ptr(false),
								CaCertificateURI:        to.Ptr(""),
								EncryptLdapConnection:   to.Ptr(false),
								ExtendedGroups:          to.Ptr(true),
								GroupFileURI:            to.Ptr(""),
								LdapBaseDN:              to.Ptr(""),
								LdapServer:              to.Ptr(""),
								RequireValidCertificate: to.Ptr(false),
								UserFileURI:             to.Ptr(""),
								UsernameDownloaded:      to.Ptr(armstoragecache.UsernameDownloadedTypeYes),
								UsernameSource:          to.Ptr(armstoragecache.UsernameSourceAD),
							},
						},
						EncryptionSettings: &armstoragecache.CacheEncryptionSettings{
							KeyEncryptionKey: &armstoragecache.KeyVaultKeyReference{
								KeyURL: to.Ptr("https://keyvault-cmk.vault.azure.net/keys/key2048/test"),
								SourceVault: &armstoragecache.KeyVaultKeyReferenceSourceVault{
									ID: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.KeyVault/vaults/keyvault-cmk"),
								},
							},
						},
						Health: &armstoragecache.CacheHealth{
							Conditions: []*armstoragecache.Condition{
								{
									Message:   to.Ptr("Cannot contact DNS server"),
									Timestamp: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2021-04-21T18:25:43.511Z"); return t }()),
								}},
							State:             to.Ptr(armstoragecache.HealthStateTypeTransitioning),
							StatusDescription: to.Ptr("Cache is being created."),
						},
						MountAddresses: []*string{
							to.Ptr("192.168.1.1"),
							to.Ptr("192.168.1.2")},
						NetworkSettings: &armstoragecache.CacheNetworkSettings{
							DNSSearchDomain: to.Ptr("contoso.com"),
							DNSServers: []*string{
								to.Ptr("10.1.22.33"),
								to.Ptr("10.1.12.33")},
							Mtu:       to.Ptr[int32](1500),
							NtpServer: to.Ptr("time.contoso.com"),
						},
						ProvisioningState: to.Ptr(armstoragecache.ProvisioningStateTypeSucceeded),
						SecuritySettings: &armstoragecache.CacheSecuritySettings{
							AccessPolicies: []*armstoragecache.NfsAccessPolicy{
								{
									Name: to.Ptr("default"),
									AccessRules: []*armstoragecache.NfsAccessRule{
										{
											Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessRw),
											RootSquash:     to.Ptr(false),
											Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeDefault),
											SubmountAccess: to.Ptr(true),
											Suid:           to.Ptr(false),
										}},
								}},
						},
						Subnet: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.Network/virtualNetworks/scvnet/subnets/sub2"),
						UpgradeStatus: &armstoragecache.CacheUpgradeStatus{
							CurrentFirmwareVersion: to.Ptr("V5.1.12"),
							FirmwareUpdateDeadline: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2019-04-21T18:25:43.511Z"); return t }()),
							FirmwareUpdateStatus:   to.Ptr(armstoragecache.FirmwareStatusTypeAvailable),
							LastFirmwareUpdate:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2019-01-21T18:25:43.511Z"); return t }()),
							PendingFirmwareVersion: to.Ptr("V5.1.15"),
						},
					},
					SKU: &armstoragecache.CacheSKU{
						Name: to.Ptr("Standard_2G"),
					},
					SystemData: &armstoragecache.SystemData{
						CreatedAt:          to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-01T17:18:19.1234567Z"); return t }()),
						CreatedBy:          to.Ptr("user1"),
						CreatedByType:      to.Ptr(armstoragecache.CreatedByTypeUser),
						LastModifiedAt:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-02T17:18:19.1234567Z"); return t }()),
						LastModifiedBy:     to.Ptr("user2"),
						LastModifiedByType: to.Ptr(armstoragecache.CreatedByTypeUser),
					},
					Tags: map[string]*string{
						"Dept": to.Ptr("Contoso"),
					},
				}},
		}
		if !reflect.DeepEqual(pagerExampleRes, nextResult.CachesListResult) {
			exampleResJson, _ := json.Marshal(pagerExampleRes)
			mockResJson, _ := json.Marshal(nextResult.CachesListResult)
			t.Fatalf("Mock response is not equal to example response for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_List.json:\nmock response: %s\nexample response: %s", mockResJson, exampleResJson)
		}
	}
}

func TestCaches_ListByResourceGroup(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_ListByResourceGroup.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"Caches_ListByResourceGroup"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewCachesClient("00000000-0000-0000-0000-000000000000", cred, &options)
	pager := client.ListByResourceGroup("scgroup",
		nil)
	for pager.More() {
		nextResult, err := pager.NextPage(ctx)
		if err != nil {
			t.Fatalf("Failed to advance page for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_ListByResourceGroup.json: %v", err)
			break
		}
		// Response check
		pagerExampleRes := armstoragecache.CachesListResult{
			Value: []*armstoragecache.Cache{
				{
					Name:     to.Ptr("sc1"),
					Type:     to.Ptr("Microsoft.StorageCache/Cache"),
					ID:       to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.StorageCache/caches/sc1"),
					Location: to.Ptr("westus"),
					Properties: &armstoragecache.CacheProperties{
						CacheSizeGB: to.Ptr[int32](3072),
						DirectoryServicesSettings: &armstoragecache.CacheDirectorySettings{
							ActiveDirectory: &armstoragecache.CacheActiveDirectorySettings{
								CacheNetBiosName:      to.Ptr("contosoSmb"),
								DomainJoined:          to.Ptr(armstoragecache.DomainJoinedTypeYes),
								DomainName:            to.Ptr("contosoAd.contoso.local"),
								DomainNetBiosName:     to.Ptr("contosoAd"),
								PrimaryDNSIPAddress:   to.Ptr("192.0.2.10"),
								SecondaryDNSIPAddress: to.Ptr("192.0.2.11"),
							},
							UsernameDownload: &armstoragecache.CacheUsernameDownloadSettings{
								AutoDownloadCertificate: to.Ptr(false),
								CaCertificateURI:        to.Ptr(""),
								EncryptLdapConnection:   to.Ptr(false),
								ExtendedGroups:          to.Ptr(true),
								GroupFileURI:            to.Ptr(""),
								LdapBaseDN:              to.Ptr("dc=contosoad,dc=contoso,dc=local"),
								LdapServer:              to.Ptr("192.0.2.12"),
								RequireValidCertificate: to.Ptr(false),
								UserFileURI:             to.Ptr(""),
								UsernameDownloaded:      to.Ptr(armstoragecache.UsernameDownloadedTypeYes),
								UsernameSource:          to.Ptr(armstoragecache.UsernameSourceLDAP),
							},
						},
						EncryptionSettings: &armstoragecache.CacheEncryptionSettings{
							KeyEncryptionKey: &armstoragecache.KeyVaultKeyReference{
								KeyURL: to.Ptr("https://keyvault-cmk.vault.azure.net/keys/key2048/test"),
								SourceVault: &armstoragecache.KeyVaultKeyReferenceSourceVault{
									ID: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.KeyVault/vaults/keyvault-cmk"),
								},
							},
						},
						Health: &armstoragecache.CacheHealth{
							Conditions: []*armstoragecache.Condition{
								{
									Message:   to.Ptr("Cannot contact DNS server"),
									Timestamp: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2021-04-21T18:25:43.511Z"); return t }()),
								}},
							State:             to.Ptr(armstoragecache.HealthStateTypeTransitioning),
							StatusDescription: to.Ptr("Cache is being created."),
						},
						MountAddresses: []*string{
							to.Ptr("192.168.1.1"),
							to.Ptr("192.168.1.2")},
						NetworkSettings: &armstoragecache.CacheNetworkSettings{
							DNSSearchDomain: to.Ptr("contoso.com"),
							DNSServers: []*string{
								to.Ptr("10.1.22.33"),
								to.Ptr("10.1.12.33")},
							Mtu:       to.Ptr[int32](1500),
							NtpServer: to.Ptr("time.contoso.com"),
						},
						ProvisioningState: to.Ptr(armstoragecache.ProvisioningStateTypeSucceeded),
						SecuritySettings: &armstoragecache.CacheSecuritySettings{
							AccessPolicies: []*armstoragecache.NfsAccessPolicy{
								{
									Name: to.Ptr("default"),
									AccessRules: []*armstoragecache.NfsAccessRule{
										{
											Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessRw),
											RootSquash:     to.Ptr(false),
											Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeDefault),
											SubmountAccess: to.Ptr(true),
											Suid:           to.Ptr(false),
										}},
								}},
						},
						Subnet: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.Network/virtualNetworks/scvnet/subnets/sub1"),
						UpgradeStatus: &armstoragecache.CacheUpgradeStatus{
							CurrentFirmwareVersion: to.Ptr("V5.1.12"),
							FirmwareUpdateDeadline: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2019-04-21T18:25:43.511Z"); return t }()),
							FirmwareUpdateStatus:   to.Ptr(armstoragecache.FirmwareStatusTypeAvailable),
							LastFirmwareUpdate:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2019-01-21T18:25:43.511Z"); return t }()),
							PendingFirmwareVersion: to.Ptr("V5.1.15"),
						},
					},
					SKU: &armstoragecache.CacheSKU{
						Name: to.Ptr("Standard_2G"),
					},
					SystemData: &armstoragecache.SystemData{
						CreatedAt:          to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-01T17:18:19.1234567Z"); return t }()),
						CreatedBy:          to.Ptr("user1"),
						CreatedByType:      to.Ptr(armstoragecache.CreatedByTypeUser),
						LastModifiedAt:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-02T17:18:19.1234567Z"); return t }()),
						LastModifiedBy:     to.Ptr("user2"),
						LastModifiedByType: to.Ptr(armstoragecache.CreatedByTypeUser),
					},
					Tags: map[string]*string{
						"Dept": to.Ptr("Contoso"),
					},
				},
				{
					Name:     to.Ptr("sc2"),
					Type:     to.Ptr("Microsoft.StorageCache/Cache"),
					ID:       to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.StorageCache/caches/sc2"),
					Location: to.Ptr("westus"),
					Properties: &armstoragecache.CacheProperties{
						CacheSizeGB: to.Ptr[int32](3072),
						DirectoryServicesSettings: &armstoragecache.CacheDirectorySettings{
							ActiveDirectory: &armstoragecache.CacheActiveDirectorySettings{
								CacheNetBiosName:      to.Ptr("contosoSmb"),
								DomainJoined:          to.Ptr(armstoragecache.DomainJoinedTypeYes),
								DomainName:            to.Ptr("contosoAd.contoso.local"),
								DomainNetBiosName:     to.Ptr("contosoAd"),
								PrimaryDNSIPAddress:   to.Ptr("192.0.2.10"),
								SecondaryDNSIPAddress: to.Ptr("192.0.2.11"),
							},
							UsernameDownload: &armstoragecache.CacheUsernameDownloadSettings{
								AutoDownloadCertificate: to.Ptr(false),
								CaCertificateURI:        to.Ptr(""),
								EncryptLdapConnection:   to.Ptr(false),
								ExtendedGroups:          to.Ptr(true),
								GroupFileURI:            to.Ptr(""),
								LdapBaseDN:              to.Ptr(""),
								LdapServer:              to.Ptr(""),
								RequireValidCertificate: to.Ptr(false),
								UserFileURI:             to.Ptr(""),
								UsernameDownloaded:      to.Ptr(armstoragecache.UsernameDownloadedTypeYes),
								UsernameSource:          to.Ptr(armstoragecache.UsernameSourceAD),
							},
						},
						EncryptionSettings: &armstoragecache.CacheEncryptionSettings{
							KeyEncryptionKey: &armstoragecache.KeyVaultKeyReference{
								KeyURL: to.Ptr("https://keyvault-cmk.vault.azure.net/keys/key2048/test"),
								SourceVault: &armstoragecache.KeyVaultKeyReferenceSourceVault{
									ID: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.KeyVault/vaults/keyvault-cmk"),
								},
							},
						},
						Health: &armstoragecache.CacheHealth{
							Conditions: []*armstoragecache.Condition{
								{
									Message:   to.Ptr("Cannot contact DNS server"),
									Timestamp: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2021-04-21T18:25:43.511Z"); return t }()),
								}},
							State:             to.Ptr(armstoragecache.HealthStateTypeTransitioning),
							StatusDescription: to.Ptr("Cache is being created."),
						},
						MountAddresses: []*string{
							to.Ptr("192.168.1.1"),
							to.Ptr("192.168.1.2")},
						NetworkSettings: &armstoragecache.CacheNetworkSettings{
							DNSSearchDomain: to.Ptr("contoso.com"),
							DNSServers: []*string{
								to.Ptr("10.1.22.33"),
								to.Ptr("10.1.12.33")},
							Mtu:       to.Ptr[int32](1500),
							NtpServer: to.Ptr("time.contoso.com"),
						},
						ProvisioningState: to.Ptr(armstoragecache.ProvisioningStateTypeSucceeded),
						SecuritySettings: &armstoragecache.CacheSecuritySettings{
							AccessPolicies: []*armstoragecache.NfsAccessPolicy{
								{
									Name: to.Ptr("default"),
									AccessRules: []*armstoragecache.NfsAccessRule{
										{
											Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessRw),
											RootSquash:     to.Ptr(false),
											Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeDefault),
											SubmountAccess: to.Ptr(true),
											Suid:           to.Ptr(false),
										}},
								}},
						},
						Subnet: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.Network/virtualNetworks/scvnet/subnets/sub2"),
						UpgradeStatus: &armstoragecache.CacheUpgradeStatus{
							CurrentFirmwareVersion: to.Ptr("V5.1.12"),
							FirmwareUpdateDeadline: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2019-04-21T18:25:43.511Z"); return t }()),
							FirmwareUpdateStatus:   to.Ptr(armstoragecache.FirmwareStatusTypeAvailable),
							LastFirmwareUpdate:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2019-01-21T18:25:43.511Z"); return t }()),
							PendingFirmwareVersion: to.Ptr("V5.1.15"),
						},
					},
					SKU: &armstoragecache.CacheSKU{
						Name: to.Ptr("Standard_2G"),
					},
					SystemData: &armstoragecache.SystemData{
						CreatedAt:          to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-01T17:18:19.1234567Z"); return t }()),
						CreatedBy:          to.Ptr("user1"),
						CreatedByType:      to.Ptr(armstoragecache.CreatedByTypeUser),
						LastModifiedAt:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-02T17:18:19.1234567Z"); return t }()),
						LastModifiedBy:     to.Ptr("user2"),
						LastModifiedByType: to.Ptr(armstoragecache.CreatedByTypeUser),
					},
					Tags: map[string]*string{
						"Dept": to.Ptr("Contoso"),
					},
				}},
		}
		if !reflect.DeepEqual(pagerExampleRes, nextResult.CachesListResult) {
			exampleResJson, _ := json.Marshal(pagerExampleRes)
			mockResJson, _ := json.Marshal(nextResult.CachesListResult)
			t.Fatalf("Mock response is not equal to example response for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_ListByResourceGroup.json:\nmock response: %s\nexample response: %s", mockResJson, exampleResJson)
		}
	}
}

func TestCaches_Delete(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_Delete.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"Caches_Delete"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewCachesClient("00000000-0000-0000-0000-000000000000", cred, &options)
	poller, err := client.BeginDelete(ctx,
		"scgroup",
		"sc",
		&armstoragecache.CachesClientBeginDeleteOptions{ResumeToken: ""})
	if err != nil {
		t.Fatalf("Failed to get result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_Delete.json: %v", err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatalf("Failed to get LRO result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_Delete.json: %v", err)
	}
}

func TestCaches_Get(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_Get.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"Caches_Get"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewCachesClient("00000000-0000-0000-0000-000000000000", cred, &options)
	res, err := client.Get(ctx,
		"scgroup",
		"sc1",
		nil)
	if err != nil {
		t.Fatalf("Failed to get result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_Get.json: %v", err)
	}
	// Response check
	{
		exampleRes := armstoragecache.Cache{
			Name:     to.Ptr("sc1"),
			Type:     to.Ptr("Microsoft.StorageCache/Cache"),
			ID:       to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.StorageCache/caches/sc1"),
			Location: to.Ptr("westus"),
			Properties: &armstoragecache.CacheProperties{
				CacheSizeGB: to.Ptr[int32](3072),
				DirectoryServicesSettings: &armstoragecache.CacheDirectorySettings{
					ActiveDirectory: &armstoragecache.CacheActiveDirectorySettings{
						CacheNetBiosName:      to.Ptr("contosoSmb"),
						DomainJoined:          to.Ptr(armstoragecache.DomainJoinedTypeYes),
						DomainName:            to.Ptr("contosoAd.contoso.local"),
						DomainNetBiosName:     to.Ptr("contosoAd"),
						PrimaryDNSIPAddress:   to.Ptr("192.0.2.10"),
						SecondaryDNSIPAddress: to.Ptr("192.0.2.11"),
					},
					UsernameDownload: &armstoragecache.CacheUsernameDownloadSettings{
						AutoDownloadCertificate: to.Ptr(false),
						CaCertificateURI:        to.Ptr(""),
						EncryptLdapConnection:   to.Ptr(false),
						ExtendedGroups:          to.Ptr(true),
						GroupFileURI:            to.Ptr(""),
						LdapBaseDN:              to.Ptr("dc=contosoad,dc=contoso,dc=local"),
						LdapServer:              to.Ptr("192.0.2.12"),
						RequireValidCertificate: to.Ptr(false),
						UserFileURI:             to.Ptr(""),
						UsernameDownloaded:      to.Ptr(armstoragecache.UsernameDownloadedTypeYes),
						UsernameSource:          to.Ptr(armstoragecache.UsernameSourceLDAP),
					},
				},
				EncryptionSettings: &armstoragecache.CacheEncryptionSettings{
					KeyEncryptionKey: &armstoragecache.KeyVaultKeyReference{
						KeyURL: to.Ptr("https://keyvault-cmk.vault.azure.net/keys/key2048/test"),
						SourceVault: &armstoragecache.KeyVaultKeyReferenceSourceVault{
							ID: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.KeyVault/vaults/keyvault-cmk"),
						},
					},
				},
				Health: &armstoragecache.CacheHealth{
					Conditions: []*armstoragecache.Condition{
						{
							Message:   to.Ptr("Cannot contact DNS server"),
							Timestamp: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2021-04-21T18:25:43.511Z"); return t }()),
						}},
					State:             to.Ptr(armstoragecache.HealthStateTypeTransitioning),
					StatusDescription: to.Ptr("Cache is being created."),
				},
				MountAddresses: []*string{
					to.Ptr("192.168.1.1"),
					to.Ptr("192.168.1.2")},
				NetworkSettings: &armstoragecache.CacheNetworkSettings{
					DNSSearchDomain: to.Ptr("contoso.com"),
					DNSServers: []*string{
						to.Ptr("10.1.22.33"),
						to.Ptr("10.1.12.33")},
					Mtu:       to.Ptr[int32](1500),
					NtpServer: to.Ptr("time.contoso.com"),
				},
				ProvisioningState: to.Ptr(armstoragecache.ProvisioningStateTypeSucceeded),
				SecuritySettings: &armstoragecache.CacheSecuritySettings{
					AccessPolicies: []*armstoragecache.NfsAccessPolicy{
						{
							Name: to.Ptr("default"),
							AccessRules: []*armstoragecache.NfsAccessRule{
								{
									Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessRw),
									RootSquash:     to.Ptr(false),
									Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeDefault),
									SubmountAccess: to.Ptr(true),
									Suid:           to.Ptr(false),
								}},
						}},
				},
				Subnet: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.Network/virtualNetworks/scvnet/subnets/sub1"),
				UpgradeStatus: &armstoragecache.CacheUpgradeStatus{
					CurrentFirmwareVersion: to.Ptr("V5.1.12"),
					FirmwareUpdateDeadline: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2019-04-21T18:25:43.511Z"); return t }()),
					FirmwareUpdateStatus:   to.Ptr(armstoragecache.FirmwareStatusTypeAvailable),
					LastFirmwareUpdate:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2019-01-21T18:25:43.511Z"); return t }()),
					PendingFirmwareVersion: to.Ptr("V5.1.15"),
				},
			},
			SKU: &armstoragecache.CacheSKU{
				Name: to.Ptr("Standard_2G"),
			},
			SystemData: &armstoragecache.SystemData{
				CreatedAt:          to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-01T17:18:19.1234567Z"); return t }()),
				CreatedBy:          to.Ptr("user1"),
				CreatedByType:      to.Ptr(armstoragecache.CreatedByTypeUser),
				LastModifiedAt:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-02T17:18:19.1234567Z"); return t }()),
				LastModifiedBy:     to.Ptr("user2"),
				LastModifiedByType: to.Ptr(armstoragecache.CreatedByTypeUser),
			},
			Tags: map[string]*string{
				"Dept": to.Ptr("Contoso"),
			},
		}
		if !reflect.DeepEqual(exampleRes, res.Cache) {
			exampleResJson, _ := json.Marshal(exampleRes)
			mockResJson, _ := json.Marshal(res.Cache)
			t.Fatalf("Mock response is not equal to example response for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_Get.json:\nmock response: %s\nexample response: %s", mockResJson, exampleResJson)
		}
	}
}

func TestCaches_CreateOrUpdate(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_CreateOrUpdate.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"Caches_CreateOrUpdate"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewCachesClient("00000000-0000-0000-0000-000000000000", cred, &options)
	poller, err := client.BeginCreateOrUpdate(ctx,
		"scgroup",
		"sc1",
		&armstoragecache.CachesClientBeginCreateOrUpdateOptions{Cache: &armstoragecache.Cache{
			Identity: &armstoragecache.CacheIdentity{
				Type: to.Ptr(armstoragecache.CacheIdentityTypeUserAssigned),
				UserAssignedIdentities: map[string]*armstoragecache.UserAssignedIdentitiesValue{
					"/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.ManagedIdentity/userAssignedIdentities/identity1": {},
				},
			},
			Location: to.Ptr("westus"),
			Properties: &armstoragecache.CacheProperties{
				CacheSizeGB: to.Ptr[int32](3072),
				DirectoryServicesSettings: &armstoragecache.CacheDirectorySettings{
					ActiveDirectory: &armstoragecache.CacheActiveDirectorySettings{
						CacheNetBiosName: to.Ptr("contosoSmb"),
						Credentials: &armstoragecache.CacheActiveDirectorySettingsCredentials{
							Password: to.Ptr("<password>"),
							Username: to.Ptr("consotoAdmin"),
						},
						DomainName:            to.Ptr("contosoAd.contoso.local"),
						DomainNetBiosName:     to.Ptr("contosoAd"),
						PrimaryDNSIPAddress:   to.Ptr("192.0.2.10"),
						SecondaryDNSIPAddress: to.Ptr("192.0.2.11"),
					},
					UsernameDownload: &armstoragecache.CacheUsernameDownloadSettings{
						Credentials: &armstoragecache.CacheUsernameDownloadSettingsCredentials{
							BindDn:       to.Ptr("cn=ldapadmin,dc=contosoad,dc=contoso,dc=local"),
							BindPassword: to.Ptr("<bindPassword>"),
						},
						ExtendedGroups: to.Ptr(true),
						LdapBaseDN:     to.Ptr("dc=contosoad,dc=contoso,dc=local"),
						LdapServer:     to.Ptr("192.0.2.12"),
						UsernameSource: to.Ptr(armstoragecache.UsernameSourceLDAP),
					},
				},
				EncryptionSettings: &armstoragecache.CacheEncryptionSettings{
					KeyEncryptionKey: &armstoragecache.KeyVaultKeyReference{
						KeyURL: to.Ptr("https://keyvault-cmk.vault.azure.net/keys/key2047/test"),
						SourceVault: &armstoragecache.KeyVaultKeyReferenceSourceVault{
							ID: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.KeyVault/vaults/keyvault-cmk"),
						},
					},
				},
				SecuritySettings: &armstoragecache.CacheSecuritySettings{
					AccessPolicies: []*armstoragecache.NfsAccessPolicy{
						{
							Name: to.Ptr("default"),
							AccessRules: []*armstoragecache.NfsAccessRule{
								{
									Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessRw),
									RootSquash:     to.Ptr(false),
									Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeDefault),
									SubmountAccess: to.Ptr(true),
									Suid:           to.Ptr(false),
								}},
						}},
				},
				Subnet: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.Network/virtualNetworks/scvnet/subnets/sub1"),
			},
			SKU: &armstoragecache.CacheSKU{
				Name: to.Ptr("Standard_2G"),
			},
			Tags: map[string]*string{
				"Dept": to.Ptr("Contoso"),
			},
		},
			ResumeToken: "",
		})
	if err != nil {
		t.Fatalf("Failed to get result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_CreateOrUpdate.json: %v", err)
	}
	res, err := poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatalf("Failed to get LRO result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_CreateOrUpdate.json: %v", err)
	}
	// Response check
	{
		exampleRes := armstoragecache.Cache{
			Name:     to.Ptr("sc1"),
			Type:     to.Ptr("Microsoft.StorageCache/Cache"),
			ID:       to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.StorageCache/caches/sc1"),
			Location: to.Ptr("westus"),
			Properties: &armstoragecache.CacheProperties{
				CacheSizeGB: to.Ptr[int32](3072),
				DirectoryServicesSettings: &armstoragecache.CacheDirectorySettings{
					ActiveDirectory: &armstoragecache.CacheActiveDirectorySettings{
						CacheNetBiosName:      to.Ptr("contosoSmb"),
						DomainJoined:          to.Ptr(armstoragecache.DomainJoinedTypeYes),
						DomainName:            to.Ptr("contosoAd.contoso.local"),
						DomainNetBiosName:     to.Ptr("contosoAd"),
						PrimaryDNSIPAddress:   to.Ptr("192.0.2.10"),
						SecondaryDNSIPAddress: to.Ptr("192.0.2.11"),
					},
					UsernameDownload: &armstoragecache.CacheUsernameDownloadSettings{
						AutoDownloadCertificate: to.Ptr(false),
						CaCertificateURI:        to.Ptr(""),
						EncryptLdapConnection:   to.Ptr(false),
						ExtendedGroups:          to.Ptr(true),
						GroupFileURI:            to.Ptr(""),
						LdapBaseDN:              to.Ptr("dc=contosoad,dc=contoso,dc=local"),
						LdapServer:              to.Ptr("192.0.2.12"),
						RequireValidCertificate: to.Ptr(false),
						UserFileURI:             to.Ptr(""),
						UsernameDownloaded:      to.Ptr(armstoragecache.UsernameDownloadedTypeYes),
						UsernameSource:          to.Ptr(armstoragecache.UsernameSourceLDAP),
					},
				},
				EncryptionSettings: &armstoragecache.CacheEncryptionSettings{
					KeyEncryptionKey: &armstoragecache.KeyVaultKeyReference{
						KeyURL: to.Ptr("https://keyvault-cmk.vault.azure.net/keys/key2048/test"),
						SourceVault: &armstoragecache.KeyVaultKeyReferenceSourceVault{
							ID: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.KeyVault/vaults/keyvault-cmk"),
						},
					},
				},
				Health: &armstoragecache.CacheHealth{
					Conditions: []*armstoragecache.Condition{
						{
							Message:   to.Ptr("Cannot contact DNS server"),
							Timestamp: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2021-04-21T18:25:43.511Z"); return t }()),
						}},
					State:             to.Ptr(armstoragecache.HealthStateTypeTransitioning),
					StatusDescription: to.Ptr("Cache is being created."),
				},
				MountAddresses: []*string{
					to.Ptr("192.168.1.1"),
					to.Ptr("192.168.1.2")},
				NetworkSettings: &armstoragecache.CacheNetworkSettings{
					DNSSearchDomain: to.Ptr("contoso.com"),
					DNSServers: []*string{
						to.Ptr("10.1.22.33"),
						to.Ptr("10.1.12.33")},
					Mtu:       to.Ptr[int32](1500),
					NtpServer: to.Ptr("time.contoso.com"),
				},
				ProvisioningState: to.Ptr(armstoragecache.ProvisioningStateTypeSucceeded),
				SecuritySettings: &armstoragecache.CacheSecuritySettings{
					AccessPolicies: []*armstoragecache.NfsAccessPolicy{
						{
							Name: to.Ptr("default"),
							AccessRules: []*armstoragecache.NfsAccessRule{
								{
									Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessRw),
									RootSquash:     to.Ptr(false),
									Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeDefault),
									SubmountAccess: to.Ptr(true),
									Suid:           to.Ptr(false),
								}},
						}},
				},
				Subnet: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.Network/virtualNetworks/scvnet/subnets/sub1"),
				UpgradeStatus: &armstoragecache.CacheUpgradeStatus{
					CurrentFirmwareVersion: to.Ptr("V5.1.12"),
					FirmwareUpdateDeadline: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2019-04-21T18:25:43.511Z"); return t }()),
					FirmwareUpdateStatus:   to.Ptr(armstoragecache.FirmwareStatusTypeAvailable),
					LastFirmwareUpdate:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2019-01-21T18:25:43.511Z"); return t }()),
					PendingFirmwareVersion: to.Ptr("V5.1.15"),
				},
			},
			SKU: &armstoragecache.CacheSKU{
				Name: to.Ptr("Standard_2G"),
			},
			SystemData: &armstoragecache.SystemData{
				CreatedAt:          to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-01T17:18:19.1234567Z"); return t }()),
				CreatedBy:          to.Ptr("user1"),
				CreatedByType:      to.Ptr(armstoragecache.CreatedByTypeUser),
				LastModifiedAt:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-02T17:18:19.1234567Z"); return t }()),
				LastModifiedBy:     to.Ptr("user2"),
				LastModifiedByType: to.Ptr(armstoragecache.CreatedByTypeUser),
			},
			Tags: map[string]*string{
				"Dept": to.Ptr("Contoso"),
			},
		}
		if !reflect.DeepEqual(exampleRes, res.Cache) {
			exampleResJson, _ := json.Marshal(exampleRes)
			mockResJson, _ := json.Marshal(res.Cache)
			t.Fatalf("Mock response is not equal to example response for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_CreateOrUpdate.json:\nmock response: %s\nexample response: %s", mockResJson, exampleResJson)
		}
	}

	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_CreateOrUpdate_ldap_only.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"Caches_CreateOrUpdate_ldap_only"},
	})
	client = armstoragecache.NewCachesClient("00000000-0000-0000-0000-000000000000", cred, &options)
	poller, err = client.BeginCreateOrUpdate(ctx,
		"scgroup",
		"sc1",
		&armstoragecache.CachesClientBeginCreateOrUpdateOptions{Cache: &armstoragecache.Cache{
			Location: to.Ptr("westus"),
			Properties: &armstoragecache.CacheProperties{
				CacheSizeGB: to.Ptr[int32](3072),
				DirectoryServicesSettings: &armstoragecache.CacheDirectorySettings{
					UsernameDownload: &armstoragecache.CacheUsernameDownloadSettings{
						Credentials: &armstoragecache.CacheUsernameDownloadSettingsCredentials{
							BindDn:       to.Ptr("cn=ldapadmin,dc=contosoad,dc=contoso,dc=local"),
							BindPassword: to.Ptr("<bindPassword>"),
						},
						ExtendedGroups: to.Ptr(true),
						LdapBaseDN:     to.Ptr("dc=contosoad,dc=contoso,dc=local"),
						LdapServer:     to.Ptr("192.0.2.12"),
						UsernameSource: to.Ptr(armstoragecache.UsernameSourceLDAP),
					},
				},
				EncryptionSettings: &armstoragecache.CacheEncryptionSettings{
					KeyEncryptionKey: &armstoragecache.KeyVaultKeyReference{
						KeyURL: to.Ptr("https://keyvault-cmk.vault.azure.net/keys/key2048/test"),
						SourceVault: &armstoragecache.KeyVaultKeyReferenceSourceVault{
							ID: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.KeyVault/vaults/keyvault-cmk"),
						},
					},
				},
				SecuritySettings: &armstoragecache.CacheSecuritySettings{
					AccessPolicies: []*armstoragecache.NfsAccessPolicy{
						{
							Name: to.Ptr("default"),
							AccessRules: []*armstoragecache.NfsAccessRule{
								{
									Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessRw),
									RootSquash:     to.Ptr(false),
									Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeDefault),
									SubmountAccess: to.Ptr(true),
									Suid:           to.Ptr(false),
								}},
						}},
				},
				Subnet: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.Network/virtualNetworks/scvnet/subnets/sub1"),
			},
			SKU: &armstoragecache.CacheSKU{
				Name: to.Ptr("Standard_2G"),
			},
			Tags: map[string]*string{
				"Dept": to.Ptr("Contoso"),
			},
		},
			ResumeToken: "",
		})
	if err != nil {
		t.Fatalf("Failed to get result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_CreateOrUpdate_ldap_only.json: %v", err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatalf("Failed to get LRO result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_CreateOrUpdate_ldap_only.json: %v", err)
	}
	// Response check
	{
		exampleRes := armstoragecache.Cache{
			Name:     to.Ptr("sc1"),
			Type:     to.Ptr("Microsoft.StorageCache/Cache"),
			ID:       to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.StorageCache/caches/sc1"),
			Location: to.Ptr("westus"),
			Properties: &armstoragecache.CacheProperties{
				CacheSizeGB: to.Ptr[int32](3072),
				DirectoryServicesSettings: &armstoragecache.CacheDirectorySettings{
					UsernameDownload: &armstoragecache.CacheUsernameDownloadSettings{
						AutoDownloadCertificate: to.Ptr(false),
						CaCertificateURI:        to.Ptr(""),
						EncryptLdapConnection:   to.Ptr(false),
						ExtendedGroups:          to.Ptr(true),
						GroupFileURI:            to.Ptr(""),
						LdapBaseDN:              to.Ptr("dc=contosoad,dc=contoso,dc=local"),
						LdapServer:              to.Ptr("192.0.2.12"),
						RequireValidCertificate: to.Ptr(false),
						UserFileURI:             to.Ptr(""),
						UsernameDownloaded:      to.Ptr(armstoragecache.UsernameDownloadedTypeYes),
						UsernameSource:          to.Ptr(armstoragecache.UsernameSourceLDAP),
					},
				},
				EncryptionSettings: &armstoragecache.CacheEncryptionSettings{
					KeyEncryptionKey: &armstoragecache.KeyVaultKeyReference{
						KeyURL: to.Ptr("https://keyvault-cmk.vault.azure.net/keys/key2048/test"),
						SourceVault: &armstoragecache.KeyVaultKeyReferenceSourceVault{
							ID: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.KeyVault/vaults/keyvault-cmk"),
						},
					},
				},
				Health: &armstoragecache.CacheHealth{
					Conditions: []*armstoragecache.Condition{
						{
							Message:   to.Ptr("Cannot contact DNS server"),
							Timestamp: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2021-04-21T18:25:43.511Z"); return t }()),
						}},
					State:             to.Ptr(armstoragecache.HealthStateTypeTransitioning),
					StatusDescription: to.Ptr("Cache is being created."),
				},
				MountAddresses: []*string{
					to.Ptr("192.168.1.1"),
					to.Ptr("192.168.1.2")},
				NetworkSettings: &armstoragecache.CacheNetworkSettings{
					DNSSearchDomain: to.Ptr("contoso.com"),
					DNSServers: []*string{
						to.Ptr("10.1.22.33"),
						to.Ptr("10.1.12.33")},
					Mtu:       to.Ptr[int32](1500),
					NtpServer: to.Ptr("time.contoso.com"),
				},
				ProvisioningState: to.Ptr(armstoragecache.ProvisioningStateTypeSucceeded),
				SecuritySettings: &armstoragecache.CacheSecuritySettings{
					AccessPolicies: []*armstoragecache.NfsAccessPolicy{
						{
							Name: to.Ptr("default"),
							AccessRules: []*armstoragecache.NfsAccessRule{
								{
									Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessRw),
									RootSquash:     to.Ptr(false),
									Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeDefault),
									SubmountAccess: to.Ptr(true),
									Suid:           to.Ptr(false),
								}},
						}},
				},
				Subnet: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.Network/virtualNetworks/scvnet/subnets/sub1"),
				UpgradeStatus: &armstoragecache.CacheUpgradeStatus{
					CurrentFirmwareVersion: to.Ptr("V5.1.12"),
					FirmwareUpdateDeadline: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2019-04-21T18:25:43.511Z"); return t }()),
					FirmwareUpdateStatus:   to.Ptr(armstoragecache.FirmwareStatusTypeAvailable),
					LastFirmwareUpdate:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2019-01-21T18:25:43.511Z"); return t }()),
					PendingFirmwareVersion: to.Ptr("V5.1.15"),
				},
			},
			SKU: &armstoragecache.CacheSKU{
				Name: to.Ptr("Standard_2G"),
			},
			SystemData: &armstoragecache.SystemData{
				CreatedAt:          to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-01T17:18:19.1234567Z"); return t }()),
				CreatedBy:          to.Ptr("user1"),
				CreatedByType:      to.Ptr(armstoragecache.CreatedByTypeUser),
				LastModifiedAt:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-02T17:18:19.1234567Z"); return t }()),
				LastModifiedBy:     to.Ptr("user2"),
				LastModifiedByType: to.Ptr(armstoragecache.CreatedByTypeUser),
			},
			Tags: map[string]*string{
				"Dept": to.Ptr("Contoso"),
			},
		}
		if !reflect.DeepEqual(exampleRes, res.Cache) {
			exampleResJson, _ := json.Marshal(exampleRes)
			mockResJson, _ := json.Marshal(res.Cache)
			t.Fatalf("Mock response is not equal to example response for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_CreateOrUpdate_ldap_only.json:\nmock response: %s\nexample response: %s", mockResJson, exampleResJson)
		}
	}
}

func TestCaches_Update(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_Update.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"Caches_Update"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewCachesClient("00000000-0000-0000-0000-000000000000", cred, &options)
	res, err := client.Update(ctx,
		"scgroup",
		"sc1",
		&armstoragecache.CachesClientUpdateOptions{Cache: &armstoragecache.Cache{
			Location: to.Ptr("westus"),
			Properties: &armstoragecache.CacheProperties{
				CacheSizeGB: to.Ptr[int32](3072),
				DirectoryServicesSettings: &armstoragecache.CacheDirectorySettings{
					ActiveDirectory: &armstoragecache.CacheActiveDirectorySettings{
						CacheNetBiosName:      to.Ptr("contosoSmb"),
						DomainName:            to.Ptr("contosoAd.contoso.local"),
						DomainNetBiosName:     to.Ptr("contosoAd"),
						PrimaryDNSIPAddress:   to.Ptr("192.0.2.10"),
						SecondaryDNSIPAddress: to.Ptr("192.0.2.11"),
					},
					UsernameDownload: &armstoragecache.CacheUsernameDownloadSettings{
						ExtendedGroups: to.Ptr(true),
						UsernameSource: to.Ptr(armstoragecache.UsernameSourceAD),
					},
				},
				NetworkSettings: &armstoragecache.CacheNetworkSettings{
					DNSSearchDomain: to.Ptr("contoso.com"),
					DNSServers: []*string{
						to.Ptr("10.1.22.33"),
						to.Ptr("10.1.12.33")},
					Mtu:       to.Ptr[int32](1500),
					NtpServer: to.Ptr("time.contoso.com"),
				},
				SecuritySettings: &armstoragecache.CacheSecuritySettings{
					AccessPolicies: []*armstoragecache.NfsAccessPolicy{
						{
							Name: to.Ptr("default"),
							AccessRules: []*armstoragecache.NfsAccessRule{
								{
									Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessRw),
									RootSquash:     to.Ptr(false),
									Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeDefault),
									SubmountAccess: to.Ptr(true),
									Suid:           to.Ptr(false),
								}},
						},
						{
							Name: to.Ptr("restrictive"),
							AccessRules: []*armstoragecache.NfsAccessRule{
								{
									Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessRw),
									Filter:         to.Ptr("10.99.3.145"),
									RootSquash:     to.Ptr(false),
									Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeHost),
									SubmountAccess: to.Ptr(true),
									Suid:           to.Ptr(true),
								},
								{
									Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessRw),
									Filter:         to.Ptr("10.99.1.0/24"),
									RootSquash:     to.Ptr(false),
									Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeNetwork),
									SubmountAccess: to.Ptr(true),
									Suid:           to.Ptr(true),
								},
								{
									Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessNo),
									AnonymousGID:   to.Ptr("65534"),
									AnonymousUID:   to.Ptr("65534"),
									RootSquash:     to.Ptr(true),
									Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeDefault),
									SubmountAccess: to.Ptr(true),
									Suid:           to.Ptr(false),
								}},
						}},
				},
				Subnet: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.Network/virtualNetworks/scvnet/subnets/sub1"),
			},
			SKU: &armstoragecache.CacheSKU{
				Name: to.Ptr("Standard_2G"),
			},
			Tags: map[string]*string{
				"Dept": to.Ptr("Contoso"),
			},
		},
		})
	if err != nil {
		t.Fatalf("Failed to get result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_Update.json: %v", err)
	}
	// Response check
	{
		exampleRes := armstoragecache.Cache{
			Name:     to.Ptr("sc1"),
			Type:     to.Ptr("Microsoft.StorageCache/Cache"),
			ID:       to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.StorageCache/caches/sc1"),
			Location: to.Ptr("westus"),
			Properties: &armstoragecache.CacheProperties{
				CacheSizeGB: to.Ptr[int32](3072),
				DirectoryServicesSettings: &armstoragecache.CacheDirectorySettings{
					ActiveDirectory: &armstoragecache.CacheActiveDirectorySettings{
						CacheNetBiosName:      to.Ptr("contosoSmb"),
						DomainJoined:          to.Ptr(armstoragecache.DomainJoinedTypeYes),
						DomainName:            to.Ptr("contosoAd.contoso.local"),
						DomainNetBiosName:     to.Ptr("contosoAd"),
						PrimaryDNSIPAddress:   to.Ptr("192.0.2.10"),
						SecondaryDNSIPAddress: to.Ptr("192.0.2.11"),
					},
					UsernameDownload: &armstoragecache.CacheUsernameDownloadSettings{
						AutoDownloadCertificate: to.Ptr(false),
						CaCertificateURI:        to.Ptr(""),
						EncryptLdapConnection:   to.Ptr(false),
						ExtendedGroups:          to.Ptr(true),
						GroupFileURI:            to.Ptr(""),
						LdapBaseDN:              to.Ptr(""),
						LdapServer:              to.Ptr(""),
						RequireValidCertificate: to.Ptr(false),
						UserFileURI:             to.Ptr(""),
						UsernameDownloaded:      to.Ptr(armstoragecache.UsernameDownloadedTypeYes),
						UsernameSource:          to.Ptr(armstoragecache.UsernameSourceAD),
					},
				},
				Health: &armstoragecache.CacheHealth{
					Conditions: []*armstoragecache.Condition{
						{
							Message:   to.Ptr("Cannot contact DNS server"),
							Timestamp: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2021-04-21T18:25:43.511Z"); return t }()),
						}},
					State:             to.Ptr(armstoragecache.HealthStateTypeTransitioning),
					StatusDescription: to.Ptr("Cache is being created."),
				},
				MountAddresses: []*string{
					to.Ptr("192.168.1.1"),
					to.Ptr("192.168.1.2")},
				NetworkSettings: &armstoragecache.CacheNetworkSettings{
					DNSSearchDomain: to.Ptr("contoso.com"),
					DNSServers: []*string{
						to.Ptr("10.1.22.33"),
						to.Ptr("10.1.12.33")},
					Mtu:       to.Ptr[int32](1500),
					NtpServer: to.Ptr("time.contoso.com"),
				},
				ProvisioningState: to.Ptr(armstoragecache.ProvisioningStateTypeSucceeded),
				SecuritySettings: &armstoragecache.CacheSecuritySettings{
					AccessPolicies: []*armstoragecache.NfsAccessPolicy{
						{
							Name: to.Ptr("default"),
							AccessRules: []*armstoragecache.NfsAccessRule{
								{
									Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessRw),
									RootSquash:     to.Ptr(false),
									Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeDefault),
									SubmountAccess: to.Ptr(true),
									Suid:           to.Ptr(false),
								}},
						},
						{
							Name: to.Ptr("restrictive"),
							AccessRules: []*armstoragecache.NfsAccessRule{
								{
									Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessRw),
									Filter:         to.Ptr("10.99.3.145"),
									RootSquash:     to.Ptr(false),
									Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeHost),
									SubmountAccess: to.Ptr(true),
									Suid:           to.Ptr(true),
								},
								{
									Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessRw),
									Filter:         to.Ptr("10.99.1.0/24"),
									RootSquash:     to.Ptr(false),
									Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeNetwork),
									SubmountAccess: to.Ptr(true),
									Suid:           to.Ptr(true),
								},
								{
									Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessNo),
									AnonymousGID:   to.Ptr("65534"),
									AnonymousUID:   to.Ptr("65534"),
									RootSquash:     to.Ptr(true),
									Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeDefault),
									SubmountAccess: to.Ptr(true),
									Suid:           to.Ptr(false),
								}},
						}},
				},
				Subnet: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.Network/virtualNetworks/scvnet/subnets/sub1"),
				UpgradeStatus: &armstoragecache.CacheUpgradeStatus{
					CurrentFirmwareVersion: to.Ptr("V5.1.12"),
					FirmwareUpdateDeadline: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2019-04-21T18:25:43.511Z"); return t }()),
					FirmwareUpdateStatus:   to.Ptr(armstoragecache.FirmwareStatusTypeAvailable),
					LastFirmwareUpdate:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2019-01-21T18:25:43.511Z"); return t }()),
					PendingFirmwareVersion: to.Ptr("V5.1.15"),
				},
			},
			SKU: &armstoragecache.CacheSKU{
				Name: to.Ptr("Standard_2G"),
			},
			SystemData: &armstoragecache.SystemData{
				CreatedAt:          to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-01T17:18:19.1234567Z"); return t }()),
				CreatedBy:          to.Ptr("user1"),
				CreatedByType:      to.Ptr(armstoragecache.CreatedByTypeUser),
				LastModifiedAt:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-02T17:18:19.1234567Z"); return t }()),
				LastModifiedBy:     to.Ptr("user2"),
				LastModifiedByType: to.Ptr(armstoragecache.CreatedByTypeUser),
			},
			Tags: map[string]*string{
				"Dept": to.Ptr("Contoso"),
			},
		}
		if !reflect.DeepEqual(exampleRes, res.Cache) {
			exampleResJson, _ := json.Marshal(exampleRes)
			mockResJson, _ := json.Marshal(res.Cache)
			t.Fatalf("Mock response is not equal to example response for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_Update.json:\nmock response: %s\nexample response: %s", mockResJson, exampleResJson)
		}
	}

	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_Update_ldap_only.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"Caches_Update_ldap_only"},
	})
	client = armstoragecache.NewCachesClient("00000000-0000-0000-0000-000000000000", cred, &options)
	res, err = client.Update(ctx,
		"scgroup",
		"sc1",
		&armstoragecache.CachesClientUpdateOptions{Cache: &armstoragecache.Cache{
			Location: to.Ptr("westus"),
			Properties: &armstoragecache.CacheProperties{
				CacheSizeGB: to.Ptr[int32](3072),
				DirectoryServicesSettings: &armstoragecache.CacheDirectorySettings{
					UsernameDownload: &armstoragecache.CacheUsernameDownloadSettings{
						Credentials: &armstoragecache.CacheUsernameDownloadSettingsCredentials{
							BindDn:       to.Ptr("cn=ldapadmin,dc=contosoad,dc=contoso,dc=local"),
							BindPassword: to.Ptr("<bindPassword>"),
						},
						ExtendedGroups: to.Ptr(true),
						LdapBaseDN:     to.Ptr("dc=contosoad,dc=contoso,dc=local"),
						LdapServer:     to.Ptr("192.0.2.12"),
						UsernameSource: to.Ptr(armstoragecache.UsernameSourceLDAP),
					},
				},
				NetworkSettings: &armstoragecache.CacheNetworkSettings{
					DNSSearchDomain: to.Ptr("contoso.com"),
					DNSServers: []*string{
						to.Ptr("10.1.22.33"),
						to.Ptr("10.1.12.33")},
					Mtu:       to.Ptr[int32](1500),
					NtpServer: to.Ptr("time.contoso.com"),
				},
				SecuritySettings: &armstoragecache.CacheSecuritySettings{
					AccessPolicies: []*armstoragecache.NfsAccessPolicy{
						{
							Name: to.Ptr("default"),
							AccessRules: []*armstoragecache.NfsAccessRule{
								{
									Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessRw),
									RootSquash:     to.Ptr(false),
									Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeDefault),
									SubmountAccess: to.Ptr(true),
									Suid:           to.Ptr(false),
								}},
						},
						{
							Name: to.Ptr("restrictive"),
							AccessRules: []*armstoragecache.NfsAccessRule{
								{
									Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessRw),
									Filter:         to.Ptr("10.99.3.145"),
									RootSquash:     to.Ptr(false),
									Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeHost),
									SubmountAccess: to.Ptr(true),
									Suid:           to.Ptr(true),
								},
								{
									Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessRw),
									Filter:         to.Ptr("10.99.1.0/24"),
									RootSquash:     to.Ptr(false),
									Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeNetwork),
									SubmountAccess: to.Ptr(true),
									Suid:           to.Ptr(true),
								},
								{
									Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessNo),
									AnonymousGID:   to.Ptr("65534"),
									AnonymousUID:   to.Ptr("65534"),
									RootSquash:     to.Ptr(true),
									Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeDefault),
									SubmountAccess: to.Ptr(true),
									Suid:           to.Ptr(false),
								}},
						}},
				},
				Subnet: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.Network/virtualNetworks/scvnet/subnets/sub1"),
			},
			SKU: &armstoragecache.CacheSKU{
				Name: to.Ptr("Standard_2G"),
			},
			Tags: map[string]*string{
				"Dept": to.Ptr("Contoso"),
			},
		},
		})
	if err != nil {
		t.Fatalf("Failed to get result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_Update_ldap_only.json: %v", err)
	}
	// Response check
	{
		exampleRes := armstoragecache.Cache{
			Name:     to.Ptr("sc1"),
			Type:     to.Ptr("Microsoft.StorageCache/Cache"),
			ID:       to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.StorageCache/caches/sc1"),
			Location: to.Ptr("westus"),
			Properties: &armstoragecache.CacheProperties{
				CacheSizeGB: to.Ptr[int32](3072),
				DirectoryServicesSettings: &armstoragecache.CacheDirectorySettings{
					UsernameDownload: &armstoragecache.CacheUsernameDownloadSettings{
						AutoDownloadCertificate: to.Ptr(false),
						CaCertificateURI:        to.Ptr(""),
						EncryptLdapConnection:   to.Ptr(false),
						ExtendedGroups:          to.Ptr(true),
						GroupFileURI:            to.Ptr(""),
						LdapBaseDN:              to.Ptr("dc=contosoad,dc=contoso,dc=local"),
						LdapServer:              to.Ptr("192.0.2.12"),
						RequireValidCertificate: to.Ptr(false),
						UserFileURI:             to.Ptr(""),
						UsernameDownloaded:      to.Ptr(armstoragecache.UsernameDownloadedTypeNo),
						UsernameSource:          to.Ptr(armstoragecache.UsernameSourceLDAP),
					},
				},
				Health: &armstoragecache.CacheHealth{
					Conditions: []*armstoragecache.Condition{
						{
							Message:   to.Ptr("Cannot contact DNS server"),
							Timestamp: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2021-04-21T18:25:43.511Z"); return t }()),
						}},
					State:             to.Ptr(armstoragecache.HealthStateTypeTransitioning),
					StatusDescription: to.Ptr("Cache is being created."),
				},
				MountAddresses: []*string{
					to.Ptr("192.168.1.1"),
					to.Ptr("192.168.1.2")},
				NetworkSettings: &armstoragecache.CacheNetworkSettings{
					DNSSearchDomain: to.Ptr("contoso.com"),
					DNSServers: []*string{
						to.Ptr("10.1.22.33"),
						to.Ptr("10.1.12.33")},
					Mtu:       to.Ptr[int32](1500),
					NtpServer: to.Ptr("time.contoso.com"),
				},
				ProvisioningState: to.Ptr(armstoragecache.ProvisioningStateTypeSucceeded),
				SecuritySettings: &armstoragecache.CacheSecuritySettings{
					AccessPolicies: []*armstoragecache.NfsAccessPolicy{
						{
							Name: to.Ptr("default"),
							AccessRules: []*armstoragecache.NfsAccessRule{
								{
									Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessRw),
									RootSquash:     to.Ptr(false),
									Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeDefault),
									SubmountAccess: to.Ptr(true),
									Suid:           to.Ptr(false),
								}},
						},
						{
							Name: to.Ptr("restrictive"),
							AccessRules: []*armstoragecache.NfsAccessRule{
								{
									Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessRw),
									Filter:         to.Ptr("10.99.3.145"),
									RootSquash:     to.Ptr(false),
									Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeHost),
									SubmountAccess: to.Ptr(true),
									Suid:           to.Ptr(true),
								},
								{
									Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessRw),
									Filter:         to.Ptr("10.99.1.0/24"),
									RootSquash:     to.Ptr(false),
									Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeNetwork),
									SubmountAccess: to.Ptr(true),
									Suid:           to.Ptr(true),
								},
								{
									Access:         to.Ptr(armstoragecache.NfsAccessRuleAccessNo),
									AnonymousGID:   to.Ptr("65534"),
									AnonymousUID:   to.Ptr("65534"),
									RootSquash:     to.Ptr(true),
									Scope:          to.Ptr(armstoragecache.NfsAccessRuleScopeDefault),
									SubmountAccess: to.Ptr(true),
									Suid:           to.Ptr(false),
								}},
						}},
				},
				Subnet: to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.Network/virtualNetworks/scvnet/subnets/sub1"),
				UpgradeStatus: &armstoragecache.CacheUpgradeStatus{
					CurrentFirmwareVersion: to.Ptr("V5.1.12"),
					FirmwareUpdateDeadline: to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2019-04-21T18:25:43.511Z"); return t }()),
					FirmwareUpdateStatus:   to.Ptr(armstoragecache.FirmwareStatusTypeAvailable),
					LastFirmwareUpdate:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2019-01-21T18:25:43.511Z"); return t }()),
					PendingFirmwareVersion: to.Ptr("V5.1.15"),
				},
			},
			SKU: &armstoragecache.CacheSKU{
				Name: to.Ptr("Standard_2G"),
			},
			SystemData: &armstoragecache.SystemData{
				CreatedAt:          to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-01T17:18:19.1234567Z"); return t }()),
				CreatedBy:          to.Ptr("user1"),
				CreatedByType:      to.Ptr(armstoragecache.CreatedByTypeUser),
				LastModifiedAt:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-02T17:18:19.1234567Z"); return t }()),
				LastModifiedBy:     to.Ptr("user2"),
				LastModifiedByType: to.Ptr(armstoragecache.CreatedByTypeUser),
			},
			Tags: map[string]*string{
				"Dept": to.Ptr("Contoso"),
			},
		}
		if !reflect.DeepEqual(exampleRes, res.Cache) {
			exampleResJson, _ := json.Marshal(exampleRes)
			mockResJson, _ := json.Marshal(res.Cache)
			t.Fatalf("Mock response is not equal to example response for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_Update_ldap_only.json:\nmock response: %s\nexample response: %s", mockResJson, exampleResJson)
		}
	}
}

func TestCaches_DebugInfo(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_DebugInfo.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"Caches_DebugInfo"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewCachesClient("00000000-0000-0000-0000-000000000000", cred, &options)
	poller, err := client.BeginDebugInfo(ctx,
		"scgroup",
		"sc",
		&armstoragecache.CachesClientBeginDebugInfoOptions{ResumeToken: ""})
	if err != nil {
		t.Fatalf("Failed to get result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_DebugInfo.json: %v", err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatalf("Failed to get LRO result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_DebugInfo.json: %v", err)
	}
}

func TestCaches_Flush(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_Flush.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"Caches_Flush"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewCachesClient("00000000-0000-0000-0000-000000000000", cred, &options)
	poller, err := client.BeginFlush(ctx,
		"scgroup",
		"sc",
		&armstoragecache.CachesClientBeginFlushOptions{ResumeToken: ""})
	if err != nil {
		t.Fatalf("Failed to get result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_Flush.json: %v", err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatalf("Failed to get LRO result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_Flush.json: %v", err)
	}
}

func TestCaches_Start(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_Start.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"Caches_Start"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewCachesClient("00000000-0000-0000-0000-000000000000", cred, &options)
	poller, err := client.BeginStart(ctx,
		"scgroup",
		"sc",
		&armstoragecache.CachesClientBeginStartOptions{ResumeToken: ""})
	if err != nil {
		t.Fatalf("Failed to get result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_Start.json: %v", err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatalf("Failed to get LRO result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_Start.json: %v", err)
	}
}

func TestCaches_Stop(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_Stop.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"Caches_Stop"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewCachesClient("00000000-0000-0000-0000-000000000000", cred, &options)
	poller, err := client.BeginStop(ctx,
		"scgroup",
		"sc",
		&armstoragecache.CachesClientBeginStopOptions{ResumeToken: ""})
	if err != nil {
		t.Fatalf("Failed to get result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_Stop.json: %v", err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatalf("Failed to get LRO result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_Stop.json: %v", err)
	}
}

func TestCaches_UpgradeFirmware(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_UpgradeFirmware.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"Caches_UpgradeFirmware"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewCachesClient("00000000-0000-0000-0000-000000000000", cred, &options)
	poller, err := client.BeginUpgradeFirmware(ctx,
		"scgroup",
		"sc1",
		&armstoragecache.CachesClientBeginUpgradeFirmwareOptions{ResumeToken: ""})
	if err != nil {
		t.Fatalf("Failed to get result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_UpgradeFirmware.json: %v", err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatalf("Failed to get LRO result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/Caches_UpgradeFirmware.json: %v", err)
	}
}

func TestStorageTargets_ListByCache(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_ListByCache.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"StorageTargets_List"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewStorageTargetsClient("00000000-0000-0000-0000-000000000000", cred, &options)
	pager := client.ListByCache("scgroup",
		"sc1",
		nil)
	for pager.More() {
		nextResult, err := pager.NextPage(ctx)
		if err != nil {
			t.Fatalf("Failed to advance page for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_ListByCache.json: %v", err)
			break
		}
		// Response check
		pagerExampleRes := armstoragecache.StorageTargetsResult{
			Value: []*armstoragecache.StorageTarget{
				{
					Name: to.Ptr("st1"),
					Type: to.Ptr("Microsoft.StorageCache/Cache/StorageTarget"),
					ID:   to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.StorageCache/caches/sc1/storagetargets/st1"),
					SystemData: &armstoragecache.SystemData{
						CreatedAt:          to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-01T17:18:19.1234567Z"); return t }()),
						CreatedBy:          to.Ptr("user1"),
						CreatedByType:      to.Ptr(armstoragecache.CreatedByTypeUser),
						LastModifiedAt:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-02T17:18:19.1234567Z"); return t }()),
						LastModifiedBy:     to.Ptr("user2"),
						LastModifiedByType: to.Ptr(armstoragecache.CreatedByTypeUser),
					},
					Properties: &armstoragecache.StorageTargetProperties{
						Junctions: []*armstoragecache.NamespaceJunction{
							{
								NamespacePath:   to.Ptr("/path/on/cache"),
								NfsAccessPolicy: to.Ptr("default"),
								NfsExport:       to.Ptr("exp1"),
								TargetPath:      to.Ptr("/path/on/exp1"),
							},
							{
								NamespacePath:   to.Ptr("/path2/on/cache"),
								NfsAccessPolicy: to.Ptr("default"),
								NfsExport:       to.Ptr("exp2"),
								TargetPath:      to.Ptr("/path2/on/exp2"),
							}},
						Nfs3: &armstoragecache.Nfs3Target{
							Target:     to.Ptr("10.0.44.44"),
							UsageModel: to.Ptr("READ_HEAVY_FREQ"),
						},
						State:      to.Ptr(armstoragecache.OperationalStateTypeReady),
						TargetType: to.Ptr(armstoragecache.StorageTargetTypeNfs3),
					},
				},
				{
					Name: to.Ptr("st2"),
					Type: to.Ptr("Microsoft.StorageCache/Cache/StorageTarget"),
					ID:   to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.StorageCache/caches/sc1/storagetargets/st2"),
					SystemData: &armstoragecache.SystemData{
						CreatedAt:          to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-01T17:18:19.1234567Z"); return t }()),
						CreatedBy:          to.Ptr("user1"),
						CreatedByType:      to.Ptr(armstoragecache.CreatedByTypeUser),
						LastModifiedAt:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-02T17:18:19.1234567Z"); return t }()),
						LastModifiedBy:     to.Ptr("user2"),
						LastModifiedByType: to.Ptr(armstoragecache.CreatedByTypeUser),
					},
					Properties: &armstoragecache.StorageTargetProperties{
						Clfs: &armstoragecache.ClfsTarget{
							Target: to.Ptr("https://contoso123.blob.core.windows.net/contoso123"),
						},
						Junctions: []*armstoragecache.NamespaceJunction{
							{
								NamespacePath:   to.Ptr("/some/arbitrary/place/on/cache"),
								NfsAccessPolicy: to.Ptr("default"),
								TargetPath:      to.Ptr("/"),
							}},
						State:      to.Ptr(armstoragecache.OperationalStateTypeReady),
						TargetType: to.Ptr(armstoragecache.StorageTargetTypeClfs),
					},
				},
				{
					Name: to.Ptr("st3"),
					Type: to.Ptr("Microsoft.StorageCache/Cache/StorageTarget"),
					ID:   to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.StorageCache/caches/sc1/storagetargets/st3"),
					SystemData: &armstoragecache.SystemData{
						CreatedAt:          to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-01T17:18:19.1234567Z"); return t }()),
						CreatedBy:          to.Ptr("user1"),
						CreatedByType:      to.Ptr(armstoragecache.CreatedByTypeUser),
						LastModifiedAt:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-02T17:18:19.1234567Z"); return t }()),
						LastModifiedBy:     to.Ptr("user2"),
						LastModifiedByType: to.Ptr(armstoragecache.CreatedByTypeUser),
					},
					Properties: &armstoragecache.StorageTargetProperties{
						Junctions: []*armstoragecache.NamespaceJunction{
							{
								NamespacePath:   to.Ptr("/some/crazier/place/on/cache"),
								NfsAccessPolicy: to.Ptr("default"),
								NfsExport:       to.Ptr(""),
								TargetPath:      to.Ptr("/"),
							}},
						State:      to.Ptr(armstoragecache.OperationalStateTypeReady),
						TargetType: to.Ptr(armstoragecache.StorageTargetTypeUnknown),
						Unknown: &armstoragecache.UnknownTarget{
							Attributes: map[string]*string{
								"foo":  to.Ptr("bar"),
								"foo2": to.Ptr("test"),
							},
						},
					},
				}},
		}
		if !reflect.DeepEqual(pagerExampleRes, nextResult.StorageTargetsResult) {
			exampleResJson, _ := json.Marshal(pagerExampleRes)
			mockResJson, _ := json.Marshal(nextResult.StorageTargetsResult)
			t.Fatalf("Mock response is not equal to example response for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_ListByCache.json:\nmock response: %s\nexample response: %s", mockResJson, exampleResJson)
		}
	}
}

func TestStorageTargets_Delete(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_Delete.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"StorageTargets_Delete"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewStorageTargetsClient("00000000-0000-0000-0000-000000000000", cred, &options)
	poller, err := client.BeginDelete(ctx,
		"scgroup",
		"sc1",
		"st1",
		&armstoragecache.StorageTargetsClientBeginDeleteOptions{Force: nil,
			ResumeToken: "",
		})
	if err != nil {
		t.Fatalf("Failed to get result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_Delete.json: %v", err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatalf("Failed to get LRO result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_Delete.json: %v", err)
	}
}

func TestStorageTargets_Get(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_Get.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"StorageTargets_Get"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewStorageTargetsClient("00000000-0000-0000-0000-000000000000", cred, &options)
	res, err := client.Get(ctx,
		"scgroup",
		"sc1",
		"st1",
		nil)
	if err != nil {
		t.Fatalf("Failed to get result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_Get.json: %v", err)
	}
	// Response check
	{
		exampleRes := armstoragecache.StorageTarget{
			Name: to.Ptr("st1"),
			Type: to.Ptr("Microsoft.StorageCache/Cache/StorageTarget"),
			ID:   to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.StorageCache/caches/sc1/storagetargets/st1"),
			SystemData: &armstoragecache.SystemData{
				CreatedAt:          to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-01T17:18:19.1234567Z"); return t }()),
				CreatedBy:          to.Ptr("user1"),
				CreatedByType:      to.Ptr(armstoragecache.CreatedByTypeUser),
				LastModifiedAt:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-02T17:18:19.1234567Z"); return t }()),
				LastModifiedBy:     to.Ptr("user2"),
				LastModifiedByType: to.Ptr(armstoragecache.CreatedByTypeUser),
			},
			Properties: &armstoragecache.StorageTargetProperties{
				Junctions: []*armstoragecache.NamespaceJunction{
					{
						NamespacePath:   to.Ptr("/path/on/cache"),
						NfsAccessPolicy: to.Ptr("default"),
						NfsExport:       to.Ptr("exp1"),
						TargetPath:      to.Ptr("/path/on/exp1"),
					},
					{
						NamespacePath:   to.Ptr("/path2/on/cache"),
						NfsAccessPolicy: to.Ptr("default"),
						NfsExport:       to.Ptr("exp2"),
						TargetPath:      to.Ptr("/path2/on/exp2"),
					}},
				Nfs3: &armstoragecache.Nfs3Target{
					Target:     to.Ptr("10.0.44.44"),
					UsageModel: to.Ptr("READ_HEAVY_FREQ"),
				},
				State:      to.Ptr(armstoragecache.OperationalStateTypeReady),
				TargetType: to.Ptr(armstoragecache.StorageTargetTypeNfs3),
			},
		}
		if !reflect.DeepEqual(exampleRes, res.StorageTarget) {
			exampleResJson, _ := json.Marshal(exampleRes)
			mockResJson, _ := json.Marshal(res.StorageTarget)
			t.Fatalf("Mock response is not equal to example response for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_Get.json:\nmock response: %s\nexample response: %s", mockResJson, exampleResJson)
		}
	}
}

func TestStorageTargets_CreateOrUpdate(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_CreateOrUpdate.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"StorageTargets_CreateOrUpdate"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewStorageTargetsClient("00000000-0000-0000-0000-000000000000", cred, &options)
	poller, err := client.BeginCreateOrUpdate(ctx,
		"scgroup",
		"sc1",
		"st1",
		&armstoragecache.StorageTargetsClientBeginCreateOrUpdateOptions{Storagetarget: &armstoragecache.StorageTarget{
			Properties: &armstoragecache.StorageTargetProperties{
				Junctions: []*armstoragecache.NamespaceJunction{
					{
						NamespacePath:   to.Ptr("/path/on/cache"),
						NfsAccessPolicy: to.Ptr("default"),
						NfsExport:       to.Ptr("exp1"),
						TargetPath:      to.Ptr("/path/on/exp1"),
					},
					{
						NamespacePath:   to.Ptr("/path2/on/cache"),
						NfsAccessPolicy: to.Ptr("rootSquash"),
						NfsExport:       to.Ptr("exp2"),
						TargetPath:      to.Ptr("/path2/on/exp2"),
					}},
				Nfs3: &armstoragecache.Nfs3Target{
					Target:     to.Ptr("10.0.44.44"),
					UsageModel: to.Ptr("READ_HEAVY_INFREQ"),
				},
				TargetType: to.Ptr(armstoragecache.StorageTargetTypeNfs3),
			},
		},
			ResumeToken: "",
		})
	if err != nil {
		t.Fatalf("Failed to get result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_CreateOrUpdate.json: %v", err)
	}
	res, err := poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatalf("Failed to get LRO result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_CreateOrUpdate.json: %v", err)
	}
	// Response check
	{
		exampleRes := armstoragecache.StorageTarget{
			Name: to.Ptr("st1"),
			Type: to.Ptr("Microsoft.StorageCache/Cache/StorageTarget"),
			ID:   to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.StorageCache/caches/sc1/storagetargets/st1"),
			SystemData: &armstoragecache.SystemData{
				CreatedAt:          to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-01T17:18:19.1234567Z"); return t }()),
				CreatedBy:          to.Ptr("user1"),
				CreatedByType:      to.Ptr(armstoragecache.CreatedByTypeUser),
				LastModifiedAt:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-02T17:18:19.1234567Z"); return t }()),
				LastModifiedBy:     to.Ptr("user2"),
				LastModifiedByType: to.Ptr(armstoragecache.CreatedByTypeUser),
			},
			Properties: &armstoragecache.StorageTargetProperties{
				Junctions: []*armstoragecache.NamespaceJunction{
					{
						NamespacePath:   to.Ptr("/path/on/cache"),
						NfsAccessPolicy: to.Ptr("default"),
						NfsExport:       to.Ptr("exp1"),
						TargetPath:      to.Ptr("/path/on/exp1"),
					},
					{
						NamespacePath:   to.Ptr("/path2/on/cache"),
						NfsAccessPolicy: to.Ptr("rootSquash"),
						NfsExport:       to.Ptr("exp2"),
						TargetPath:      to.Ptr("/path2/on/exp2"),
					}},
				Nfs3: &armstoragecache.Nfs3Target{
					Target:     to.Ptr("10.0.44.44"),
					UsageModel: to.Ptr("READ_HEAVY_INFREQ"),
				},
				State:      to.Ptr(armstoragecache.OperationalStateTypeReady),
				TargetType: to.Ptr(armstoragecache.StorageTargetTypeNfs3),
			},
		}
		if !reflect.DeepEqual(exampleRes, res.StorageTarget) {
			exampleResJson, _ := json.Marshal(exampleRes)
			mockResJson, _ := json.Marshal(res.StorageTarget)
			t.Fatalf("Mock response is not equal to example response for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_CreateOrUpdate.json:\nmock response: %s\nexample response: %s", mockResJson, exampleResJson)
		}
	}

	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_CreateOrUpdate_BlobNfs.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"StorageTargets_CreateOrUpdate_BlobNfs"},
	})
	client = armstoragecache.NewStorageTargetsClient("00000000-0000-0000-0000-000000000000", cred, &options)
	poller, err = client.BeginCreateOrUpdate(ctx,
		"scgroup",
		"sc1",
		"st1",
		&armstoragecache.StorageTargetsClientBeginCreateOrUpdateOptions{Storagetarget: &armstoragecache.StorageTarget{
			Properties: &armstoragecache.StorageTargetProperties{
				BlobNfs: &armstoragecache.BlobNfsTarget{
					Target:     to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.Storage/storageAccounts/blofnfs/blobServices/default/containers/blobnfs"),
					UsageModel: to.Ptr("WRITE_WORKLOAD_15"),
				},
				Junctions: []*armstoragecache.NamespaceJunction{
					{
						NamespacePath: to.Ptr("/blobnfs"),
					}},
				TargetType: to.Ptr(armstoragecache.StorageTargetTypeBlobNfs),
			},
		},
			ResumeToken: "",
		})
	if err != nil {
		t.Fatalf("Failed to get result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_CreateOrUpdate_BlobNfs.json: %v", err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatalf("Failed to get LRO result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_CreateOrUpdate_BlobNfs.json: %v", err)
	}
	// Response check
	{
		exampleRes := armstoragecache.StorageTarget{
			Name: to.Ptr("st1"),
			Type: to.Ptr("Microsoft.StorageCache/Cache/StorageTarget"),
			ID:   to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.StorageCache/caches/sc1/storagetargets/st1"),
			SystemData: &armstoragecache.SystemData{
				CreatedAt:          to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-01T17:18:19.1234567Z"); return t }()),
				CreatedBy:          to.Ptr("user1"),
				CreatedByType:      to.Ptr(armstoragecache.CreatedByTypeUser),
				LastModifiedAt:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-02T17:18:19.1234567Z"); return t }()),
				LastModifiedBy:     to.Ptr("user2"),
				LastModifiedByType: to.Ptr(armstoragecache.CreatedByTypeUser),
			},
			Properties: &armstoragecache.StorageTargetProperties{
				BlobNfs: &armstoragecache.BlobNfsTarget{
					Target:     to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.Storage/storageAccounts/blofnfs/blobServices/default/containers/blobnfs"),
					UsageModel: to.Ptr("WRITE_WORKLOAD_15"),
				},
				Junctions: []*armstoragecache.NamespaceJunction{
					{
						NamespacePath: to.Ptr("/blobnfs"),
					}},
				State:      to.Ptr(armstoragecache.OperationalStateTypeReady),
				TargetType: to.Ptr(armstoragecache.StorageTargetTypeBlobNfs),
			},
		}
		if !reflect.DeepEqual(exampleRes, res.StorageTarget) {
			exampleResJson, _ := json.Marshal(exampleRes)
			mockResJson, _ := json.Marshal(res.StorageTarget)
			t.Fatalf("Mock response is not equal to example response for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_CreateOrUpdate_BlobNfs.json:\nmock response: %s\nexample response: %s", mockResJson, exampleResJson)
		}
	}

	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_CreateOrUpdate_NoJunctions.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"StorageTargets_CreateOrUpdate_NoJunctions"},
	})
	client = armstoragecache.NewStorageTargetsClient("00000000-0000-0000-0000-000000000000", cred, &options)
	poller, err = client.BeginCreateOrUpdate(ctx,
		"scgroup",
		"sc1",
		"st1",
		&armstoragecache.StorageTargetsClientBeginCreateOrUpdateOptions{Storagetarget: &armstoragecache.StorageTarget{
			Properties: &armstoragecache.StorageTargetProperties{
				Nfs3: &armstoragecache.Nfs3Target{
					Target:     to.Ptr("10.0.44.44"),
					UsageModel: to.Ptr("READ_HEAVY_INFREQ"),
				},
				TargetType: to.Ptr(armstoragecache.StorageTargetTypeNfs3),
			},
		},
			ResumeToken: "",
		})
	if err != nil {
		t.Fatalf("Failed to get result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_CreateOrUpdate_NoJunctions.json: %v", err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatalf("Failed to get LRO result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_CreateOrUpdate_NoJunctions.json: %v", err)
	}
	// Response check
	{
		exampleRes := armstoragecache.StorageTarget{
			Name: to.Ptr("st1"),
			Type: to.Ptr("Microsoft.StorageCache/Cache/StorageTarget"),
			ID:   to.Ptr("/subscriptions/00000000-0000-0000-0000-000000000000/resourceGroups/scgroup/providers/Microsoft.StorageCache/caches/sc1/storagetargets/st1"),
			SystemData: &armstoragecache.SystemData{
				CreatedAt:          to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-01T17:18:19.1234567Z"); return t }()),
				CreatedBy:          to.Ptr("user1"),
				CreatedByType:      to.Ptr(armstoragecache.CreatedByTypeUser),
				LastModifiedAt:     to.Ptr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-01-02T17:18:19.1234567Z"); return t }()),
				LastModifiedBy:     to.Ptr("user2"),
				LastModifiedByType: to.Ptr(armstoragecache.CreatedByTypeUser),
			},
			Properties: &armstoragecache.StorageTargetProperties{
				Nfs3: &armstoragecache.Nfs3Target{
					Target:     to.Ptr("10.0.44.44"),
					UsageModel: to.Ptr("READ_HEAVY_INFREQ"),
				},
				State:      to.Ptr(armstoragecache.OperationalStateTypeReady),
				TargetType: to.Ptr(armstoragecache.StorageTargetTypeNfs3),
			},
		}
		if !reflect.DeepEqual(exampleRes, res.StorageTarget) {
			exampleResJson, _ := json.Marshal(exampleRes)
			mockResJson, _ := json.Marshal(res.StorageTarget)
			t.Fatalf("Mock response is not equal to example response for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_CreateOrUpdate_NoJunctions.json:\nmock response: %s\nexample response: %s", mockResJson, exampleResJson)
		}
	}
}

func TestStorageTarget_Flush(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_Flush.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"StorageTargets_Flush"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewStorageTargetClient("00000000-0000-0000-0000-000000000000", cred, &options)
	poller, err := client.BeginFlush(ctx,
		"scgroup",
		"sc",
		"st1",
		&armstoragecache.StorageTargetClientBeginFlushOptions{ResumeToken: ""})
	if err != nil {
		t.Fatalf("Failed to get result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_Flush.json: %v", err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatalf("Failed to get LRO result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_Flush.json: %v", err)
	}
}

func TestStorageTarget_Suspend(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_Suspend.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"StorageTargets_Suspend"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewStorageTargetClient("00000000-0000-0000-0000-000000000000", cred, &options)
	poller, err := client.BeginSuspend(ctx,
		"scgroup",
		"sc",
		"st1",
		&armstoragecache.StorageTargetClientBeginSuspendOptions{ResumeToken: ""})
	if err != nil {
		t.Fatalf("Failed to get result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_Suspend.json: %v", err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatalf("Failed to get LRO result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_Suspend.json: %v", err)
	}
}

func TestStorageTarget_Resume(t *testing.T) {
	// From example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_Resume.json
	ctx = runtime.WithHTTPHeader(ctx, map[string][]string{
		"example-id": {"StorageTargets_Resume"},
	})
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := armstoragecache.NewStorageTargetClient("00000000-0000-0000-0000-000000000000", cred, &options)
	poller, err := client.BeginResume(ctx,
		"scgroup",
		"sc",
		"st1",
		&armstoragecache.StorageTargetClientBeginResumeOptions{ResumeToken: ""})
	if err != nil {
		t.Fatalf("Failed to get result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_Resume.json: %v", err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatalf("Failed to get LRO result for example specification/storagecache/resource-manager/Microsoft.StorageCache/stable/2021-09-01/examples/StorageTargets_Resume.json: %v", err)
	}
}

// TestMain will exec each test
func TestMain(m *testing.M) {
	setUp()
	retCode := m.Run() // exec test and this returns an exit code to pass to os
	tearDown()
	os.Exit(retCode)
}

func getEnv(key, fallback string) string {
	if value, ok := os.LookupEnv(key); ok {
		return value
	}
	return fallback
}

func setUp() {
	ctx = context.Background()
	mockHost = getEnv("AZURE_VIRTUAL_SERVER_HOST", "https://localhost:8443")

	tr := &http.Transport{}
	if err := http2.ConfigureTransport(tr); err != nil {
		fmt.Printf("Failed to configure http2 transport: %v", err)
	}
	tr.TLSClientConfig.InsecureSkipVerify = true
	client := &http.Client{Transport: tr}

	cred = &MockCredential{}

	options = arm.ClientOptions{
		ClientOptions: policy.ClientOptions{
			Logging: policy.LogOptions{
				IncludeBody: true,
			},
			Transport: client,
		},
		Endpoint: arm.Endpoint(mockHost),
	}
}

func tearDown() {

}

type MockCredential struct {
}

func (c *MockCredential) GetToken(ctx context.Context, opts policy.TokenRequestOptions) (*azcore.AccessToken, error) {
	return &azcore.AccessToken{Token: "MockToken", ExpiresOn: time.Now().Add(time.Hour * 24).UTC()}, nil
}
