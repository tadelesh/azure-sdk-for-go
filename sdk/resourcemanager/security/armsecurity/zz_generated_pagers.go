//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armsecurity

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AccountConnectorsClientListPager provides operations for iterating over paged responses.
type AccountConnectorsClientListPager struct {
	client    *AccountConnectorsClient
	current   AccountConnectorsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AccountConnectorsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AccountConnectorsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ConnectorSettingList.NextLink == nil || len(*p.current.ConnectorSettingList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AccountConnectorsClientListPager) NextPage(ctx context.Context) (AccountConnectorsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AccountConnectorsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AccountConnectorsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AccountConnectorsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AccountConnectorsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return AccountConnectorsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AdaptiveNetworkHardeningsClientListByExtendedResourcePager provides operations for iterating over paged responses.
type AdaptiveNetworkHardeningsClientListByExtendedResourcePager struct {
	client    *AdaptiveNetworkHardeningsClient
	current   AdaptiveNetworkHardeningsClientListByExtendedResourceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AdaptiveNetworkHardeningsClientListByExtendedResourceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AdaptiveNetworkHardeningsClientListByExtendedResourcePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AdaptiveNetworkHardeningsList.NextLink == nil || len(*p.current.AdaptiveNetworkHardeningsList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AdaptiveNetworkHardeningsClientListByExtendedResourcePager) NextPage(ctx context.Context) (AdaptiveNetworkHardeningsClientListByExtendedResourceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AdaptiveNetworkHardeningsClientListByExtendedResourceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AdaptiveNetworkHardeningsClientListByExtendedResourceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AdaptiveNetworkHardeningsClientListByExtendedResourceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AdaptiveNetworkHardeningsClientListByExtendedResourceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByExtendedResourceHandleResponse(resp)
	if err != nil {
		return AdaptiveNetworkHardeningsClientListByExtendedResourceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AlertsClientListByResourceGroupPager provides operations for iterating over paged responses.
type AlertsClientListByResourceGroupPager struct {
	client    *AlertsClient
	current   AlertsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AlertsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AlertsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AlertList.NextLink == nil || len(*p.current.AlertList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AlertsClientListByResourceGroupPager) NextPage(ctx context.Context) (AlertsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AlertsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AlertsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AlertsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AlertsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return AlertsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AlertsClientListPager provides operations for iterating over paged responses.
type AlertsClientListPager struct {
	client    *AlertsClient
	current   AlertsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AlertsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AlertsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AlertList.NextLink == nil || len(*p.current.AlertList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AlertsClientListPager) NextPage(ctx context.Context) (AlertsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AlertsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AlertsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AlertsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AlertsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return AlertsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AlertsClientListResourceGroupLevelByRegionPager provides operations for iterating over paged responses.
type AlertsClientListResourceGroupLevelByRegionPager struct {
	client    *AlertsClient
	current   AlertsClientListResourceGroupLevelByRegionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AlertsClientListResourceGroupLevelByRegionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AlertsClientListResourceGroupLevelByRegionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AlertList.NextLink == nil || len(*p.current.AlertList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AlertsClientListResourceGroupLevelByRegionPager) NextPage(ctx context.Context) (AlertsClientListResourceGroupLevelByRegionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AlertsClientListResourceGroupLevelByRegionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AlertsClientListResourceGroupLevelByRegionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AlertsClientListResourceGroupLevelByRegionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AlertsClientListResourceGroupLevelByRegionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listResourceGroupLevelByRegionHandleResponse(resp)
	if err != nil {
		return AlertsClientListResourceGroupLevelByRegionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AlertsClientListSubscriptionLevelByRegionPager provides operations for iterating over paged responses.
type AlertsClientListSubscriptionLevelByRegionPager struct {
	client    *AlertsClient
	current   AlertsClientListSubscriptionLevelByRegionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AlertsClientListSubscriptionLevelByRegionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AlertsClientListSubscriptionLevelByRegionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AlertList.NextLink == nil || len(*p.current.AlertList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AlertsClientListSubscriptionLevelByRegionPager) NextPage(ctx context.Context) (AlertsClientListSubscriptionLevelByRegionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AlertsClientListSubscriptionLevelByRegionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AlertsClientListSubscriptionLevelByRegionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AlertsClientListSubscriptionLevelByRegionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AlertsClientListSubscriptionLevelByRegionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listSubscriptionLevelByRegionHandleResponse(resp)
	if err != nil {
		return AlertsClientListSubscriptionLevelByRegionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AlertsSuppressionRulesClientListPager provides operations for iterating over paged responses.
type AlertsSuppressionRulesClientListPager struct {
	client    *AlertsSuppressionRulesClient
	current   AlertsSuppressionRulesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AlertsSuppressionRulesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AlertsSuppressionRulesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AlertsSuppressionRulesList.NextLink == nil || len(*p.current.AlertsSuppressionRulesList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AlertsSuppressionRulesClientListPager) NextPage(ctx context.Context) (AlertsSuppressionRulesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AlertsSuppressionRulesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AlertsSuppressionRulesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AlertsSuppressionRulesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AlertsSuppressionRulesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return AlertsSuppressionRulesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AllowedConnectionsClientListByHomeRegionPager provides operations for iterating over paged responses.
type AllowedConnectionsClientListByHomeRegionPager struct {
	client    *AllowedConnectionsClient
	current   AllowedConnectionsClientListByHomeRegionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AllowedConnectionsClientListByHomeRegionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AllowedConnectionsClientListByHomeRegionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AllowedConnectionsList.NextLink == nil || len(*p.current.AllowedConnectionsList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AllowedConnectionsClientListByHomeRegionPager) NextPage(ctx context.Context) (AllowedConnectionsClientListByHomeRegionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AllowedConnectionsClientListByHomeRegionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AllowedConnectionsClientListByHomeRegionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AllowedConnectionsClientListByHomeRegionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AllowedConnectionsClientListByHomeRegionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByHomeRegionHandleResponse(resp)
	if err != nil {
		return AllowedConnectionsClientListByHomeRegionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AllowedConnectionsClientListPager provides operations for iterating over paged responses.
type AllowedConnectionsClientListPager struct {
	client    *AllowedConnectionsClient
	current   AllowedConnectionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AllowedConnectionsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AllowedConnectionsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AllowedConnectionsList.NextLink == nil || len(*p.current.AllowedConnectionsList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AllowedConnectionsClientListPager) NextPage(ctx context.Context) (AllowedConnectionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AllowedConnectionsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AllowedConnectionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AllowedConnectionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AllowedConnectionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return AllowedConnectionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AssessmentsClientListPager provides operations for iterating over paged responses.
type AssessmentsClientListPager struct {
	client    *AssessmentsClient
	current   AssessmentsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AssessmentsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AssessmentsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AssessmentList.NextLink == nil || len(*p.current.AssessmentList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AssessmentsClientListPager) NextPage(ctx context.Context) (AssessmentsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AssessmentsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AssessmentsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AssessmentsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AssessmentsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return AssessmentsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AssessmentsMetadataClientListBySubscriptionPager provides operations for iterating over paged responses.
type AssessmentsMetadataClientListBySubscriptionPager struct {
	client    *AssessmentsMetadataClient
	current   AssessmentsMetadataClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AssessmentsMetadataClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AssessmentsMetadataClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AssessmentMetadataResponseList.NextLink == nil || len(*p.current.AssessmentMetadataResponseList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AssessmentsMetadataClientListBySubscriptionPager) NextPage(ctx context.Context) (AssessmentsMetadataClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AssessmentsMetadataClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AssessmentsMetadataClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AssessmentsMetadataClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AssessmentsMetadataClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return AssessmentsMetadataClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AssessmentsMetadataClientListPager provides operations for iterating over paged responses.
type AssessmentsMetadataClientListPager struct {
	client    *AssessmentsMetadataClient
	current   AssessmentsMetadataClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AssessmentsMetadataClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AssessmentsMetadataClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AssessmentMetadataResponseList.NextLink == nil || len(*p.current.AssessmentMetadataResponseList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AssessmentsMetadataClientListPager) NextPage(ctx context.Context) (AssessmentsMetadataClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AssessmentsMetadataClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AssessmentsMetadataClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AssessmentsMetadataClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AssessmentsMetadataClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return AssessmentsMetadataClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AutoProvisioningSettingsClientListPager provides operations for iterating over paged responses.
type AutoProvisioningSettingsClientListPager struct {
	client    *AutoProvisioningSettingsClient
	current   AutoProvisioningSettingsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AutoProvisioningSettingsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AutoProvisioningSettingsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AutoProvisioningSettingList.NextLink == nil || len(*p.current.AutoProvisioningSettingList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AutoProvisioningSettingsClientListPager) NextPage(ctx context.Context) (AutoProvisioningSettingsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AutoProvisioningSettingsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AutoProvisioningSettingsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AutoProvisioningSettingsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AutoProvisioningSettingsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return AutoProvisioningSettingsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AutomationsClientListByResourceGroupPager provides operations for iterating over paged responses.
type AutomationsClientListByResourceGroupPager struct {
	client    *AutomationsClient
	current   AutomationsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AutomationsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AutomationsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AutomationList.NextLink == nil || len(*p.current.AutomationList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AutomationsClientListByResourceGroupPager) NextPage(ctx context.Context) (AutomationsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AutomationsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AutomationsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AutomationsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AutomationsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return AutomationsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AutomationsClientListPager provides operations for iterating over paged responses.
type AutomationsClientListPager struct {
	client    *AutomationsClient
	current   AutomationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AutomationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AutomationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AutomationList.NextLink == nil || len(*p.current.AutomationList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AutomationsClientListPager) NextPage(ctx context.Context) (AutomationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AutomationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AutomationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AutomationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AutomationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return AutomationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ComplianceResultsClientListPager provides operations for iterating over paged responses.
type ComplianceResultsClientListPager struct {
	client    *ComplianceResultsClient
	current   ComplianceResultsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ComplianceResultsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ComplianceResultsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ComplianceResultList.NextLink == nil || len(*p.current.ComplianceResultList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ComplianceResultsClientListPager) NextPage(ctx context.Context) (ComplianceResultsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ComplianceResultsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ComplianceResultsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ComplianceResultsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ComplianceResultsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ComplianceResultsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CompliancesClientListPager provides operations for iterating over paged responses.
type CompliancesClientListPager struct {
	client    *CompliancesClient
	current   CompliancesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CompliancesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CompliancesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ComplianceList.NextLink == nil || len(*p.current.ComplianceList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CompliancesClientListPager) NextPage(ctx context.Context) (CompliancesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CompliancesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CompliancesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CompliancesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CompliancesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return CompliancesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ConnectorsClientListByResourceGroupPager provides operations for iterating over paged responses.
type ConnectorsClientListByResourceGroupPager struct {
	client    *ConnectorsClient
	current   ConnectorsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ConnectorsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ConnectorsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ConnectorsList.NextLink == nil || len(*p.current.ConnectorsList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ConnectorsClientListByResourceGroupPager) NextPage(ctx context.Context) (ConnectorsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ConnectorsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ConnectorsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ConnectorsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ConnectorsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return ConnectorsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ConnectorsClientListPager provides operations for iterating over paged responses.
type ConnectorsClientListPager struct {
	client    *ConnectorsClient
	current   ConnectorsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ConnectorsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ConnectorsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ConnectorsList.NextLink == nil || len(*p.current.ConnectorsList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ConnectorsClientListPager) NextPage(ctx context.Context) (ConnectorsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ConnectorsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ConnectorsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ConnectorsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ConnectorsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ConnectorsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ContactsClientListPager provides operations for iterating over paged responses.
type ContactsClientListPager struct {
	client    *ContactsClient
	current   ContactsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ContactsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ContactsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ContactList.NextLink == nil || len(*p.current.ContactList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ContactsClientListPager) NextPage(ctx context.Context) (ContactsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ContactsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ContactsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ContactsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ContactsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ContactsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CustomAssessmentAutomationsClientListByResourceGroupPager provides operations for iterating over paged responses.
type CustomAssessmentAutomationsClientListByResourceGroupPager struct {
	client    *CustomAssessmentAutomationsClient
	current   CustomAssessmentAutomationsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomAssessmentAutomationsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CustomAssessmentAutomationsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomAssessmentAutomationsListResult.NextLink == nil || len(*p.current.CustomAssessmentAutomationsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CustomAssessmentAutomationsClientListByResourceGroupPager) NextPage(ctx context.Context) (CustomAssessmentAutomationsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CustomAssessmentAutomationsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CustomAssessmentAutomationsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CustomAssessmentAutomationsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CustomAssessmentAutomationsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return CustomAssessmentAutomationsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CustomAssessmentAutomationsClientListBySubscriptionPager provides operations for iterating over paged responses.
type CustomAssessmentAutomationsClientListBySubscriptionPager struct {
	client    *CustomAssessmentAutomationsClient
	current   CustomAssessmentAutomationsClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomAssessmentAutomationsClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CustomAssessmentAutomationsClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomAssessmentAutomationsListResult.NextLink == nil || len(*p.current.CustomAssessmentAutomationsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CustomAssessmentAutomationsClientListBySubscriptionPager) NextPage(ctx context.Context) (CustomAssessmentAutomationsClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CustomAssessmentAutomationsClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CustomAssessmentAutomationsClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CustomAssessmentAutomationsClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CustomAssessmentAutomationsClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return CustomAssessmentAutomationsClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CustomEntityStoreAssignmentsClientListByResourceGroupPager provides operations for iterating over paged responses.
type CustomEntityStoreAssignmentsClientListByResourceGroupPager struct {
	client    *CustomEntityStoreAssignmentsClient
	current   CustomEntityStoreAssignmentsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomEntityStoreAssignmentsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CustomEntityStoreAssignmentsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomEntityStoreAssignmentsListResult.NextLink == nil || len(*p.current.CustomEntityStoreAssignmentsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CustomEntityStoreAssignmentsClientListByResourceGroupPager) NextPage(ctx context.Context) (CustomEntityStoreAssignmentsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CustomEntityStoreAssignmentsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CustomEntityStoreAssignmentsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CustomEntityStoreAssignmentsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CustomEntityStoreAssignmentsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return CustomEntityStoreAssignmentsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CustomEntityStoreAssignmentsClientListBySubscriptionPager provides operations for iterating over paged responses.
type CustomEntityStoreAssignmentsClientListBySubscriptionPager struct {
	client    *CustomEntityStoreAssignmentsClient
	current   CustomEntityStoreAssignmentsClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomEntityStoreAssignmentsClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CustomEntityStoreAssignmentsClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomEntityStoreAssignmentsListResult.NextLink == nil || len(*p.current.CustomEntityStoreAssignmentsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CustomEntityStoreAssignmentsClientListBySubscriptionPager) NextPage(ctx context.Context) (CustomEntityStoreAssignmentsClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CustomEntityStoreAssignmentsClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CustomEntityStoreAssignmentsClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CustomEntityStoreAssignmentsClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CustomEntityStoreAssignmentsClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return CustomEntityStoreAssignmentsClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DeviceSecurityGroupsClientListPager provides operations for iterating over paged responses.
type DeviceSecurityGroupsClientListPager struct {
	client    *DeviceSecurityGroupsClient
	current   DeviceSecurityGroupsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeviceSecurityGroupsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DeviceSecurityGroupsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeviceSecurityGroupList.NextLink == nil || len(*p.current.DeviceSecurityGroupList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DeviceSecurityGroupsClientListPager) NextPage(ctx context.Context) (DeviceSecurityGroupsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DeviceSecurityGroupsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DeviceSecurityGroupsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DeviceSecurityGroupsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DeviceSecurityGroupsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return DeviceSecurityGroupsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DiscoveredSecuritySolutionsClientListByHomeRegionPager provides operations for iterating over paged responses.
type DiscoveredSecuritySolutionsClientListByHomeRegionPager struct {
	client    *DiscoveredSecuritySolutionsClient
	current   DiscoveredSecuritySolutionsClientListByHomeRegionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiscoveredSecuritySolutionsClientListByHomeRegionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DiscoveredSecuritySolutionsClientListByHomeRegionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiscoveredSecuritySolutionList.NextLink == nil || len(*p.current.DiscoveredSecuritySolutionList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DiscoveredSecuritySolutionsClientListByHomeRegionPager) NextPage(ctx context.Context) (DiscoveredSecuritySolutionsClientListByHomeRegionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DiscoveredSecuritySolutionsClientListByHomeRegionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DiscoveredSecuritySolutionsClientListByHomeRegionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DiscoveredSecuritySolutionsClientListByHomeRegionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DiscoveredSecuritySolutionsClientListByHomeRegionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByHomeRegionHandleResponse(resp)
	if err != nil {
		return DiscoveredSecuritySolutionsClientListByHomeRegionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DiscoveredSecuritySolutionsClientListPager provides operations for iterating over paged responses.
type DiscoveredSecuritySolutionsClientListPager struct {
	client    *DiscoveredSecuritySolutionsClient
	current   DiscoveredSecuritySolutionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiscoveredSecuritySolutionsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DiscoveredSecuritySolutionsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiscoveredSecuritySolutionList.NextLink == nil || len(*p.current.DiscoveredSecuritySolutionList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DiscoveredSecuritySolutionsClientListPager) NextPage(ctx context.Context) (DiscoveredSecuritySolutionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DiscoveredSecuritySolutionsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DiscoveredSecuritySolutionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DiscoveredSecuritySolutionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DiscoveredSecuritySolutionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return DiscoveredSecuritySolutionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ExternalSecuritySolutionsClientListByHomeRegionPager provides operations for iterating over paged responses.
type ExternalSecuritySolutionsClientListByHomeRegionPager struct {
	client    *ExternalSecuritySolutionsClient
	current   ExternalSecuritySolutionsClientListByHomeRegionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExternalSecuritySolutionsClientListByHomeRegionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ExternalSecuritySolutionsClientListByHomeRegionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExternalSecuritySolutionList.NextLink == nil || len(*p.current.ExternalSecuritySolutionList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ExternalSecuritySolutionsClientListByHomeRegionPager) NextPage(ctx context.Context) (ExternalSecuritySolutionsClientListByHomeRegionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ExternalSecuritySolutionsClientListByHomeRegionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ExternalSecuritySolutionsClientListByHomeRegionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ExternalSecuritySolutionsClientListByHomeRegionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ExternalSecuritySolutionsClientListByHomeRegionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByHomeRegionHandleResponse(resp)
	if err != nil {
		return ExternalSecuritySolutionsClientListByHomeRegionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ExternalSecuritySolutionsClientListPager provides operations for iterating over paged responses.
type ExternalSecuritySolutionsClientListPager struct {
	client    *ExternalSecuritySolutionsClient
	current   ExternalSecuritySolutionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ExternalSecuritySolutionsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ExternalSecuritySolutionsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExternalSecuritySolutionList.NextLink == nil || len(*p.current.ExternalSecuritySolutionList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ExternalSecuritySolutionsClientListPager) NextPage(ctx context.Context) (ExternalSecuritySolutionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ExternalSecuritySolutionsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ExternalSecuritySolutionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ExternalSecuritySolutionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ExternalSecuritySolutionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ExternalSecuritySolutionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// InformationProtectionPoliciesClientListPager provides operations for iterating over paged responses.
type InformationProtectionPoliciesClientListPager struct {
	client    *InformationProtectionPoliciesClient
	current   InformationProtectionPoliciesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InformationProtectionPoliciesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *InformationProtectionPoliciesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InformationProtectionPolicyList.NextLink == nil || len(*p.current.InformationProtectionPolicyList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *InformationProtectionPoliciesClientListPager) NextPage(ctx context.Context) (InformationProtectionPoliciesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return InformationProtectionPoliciesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return InformationProtectionPoliciesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return InformationProtectionPoliciesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return InformationProtectionPoliciesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return InformationProtectionPoliciesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IngestionSettingsClientListPager provides operations for iterating over paged responses.
type IngestionSettingsClientListPager struct {
	client    *IngestionSettingsClient
	current   IngestionSettingsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IngestionSettingsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IngestionSettingsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IngestionSettingList.NextLink == nil || len(*p.current.IngestionSettingList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IngestionSettingsClientListPager) NextPage(ctx context.Context) (IngestionSettingsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IngestionSettingsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IngestionSettingsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IngestionSettingsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IngestionSettingsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return IngestionSettingsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IotSecuritySolutionClientListByResourceGroupPager provides operations for iterating over paged responses.
type IotSecuritySolutionClientListByResourceGroupPager struct {
	client    *IotSecuritySolutionClient
	current   IotSecuritySolutionClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IotSecuritySolutionClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IotSecuritySolutionClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IoTSecuritySolutionsList.NextLink == nil || len(*p.current.IoTSecuritySolutionsList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IotSecuritySolutionClientListByResourceGroupPager) NextPage(ctx context.Context) (IotSecuritySolutionClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IotSecuritySolutionClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IotSecuritySolutionClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IotSecuritySolutionClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IotSecuritySolutionClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return IotSecuritySolutionClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IotSecuritySolutionClientListBySubscriptionPager provides operations for iterating over paged responses.
type IotSecuritySolutionClientListBySubscriptionPager struct {
	client    *IotSecuritySolutionClient
	current   IotSecuritySolutionClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IotSecuritySolutionClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IotSecuritySolutionClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IoTSecuritySolutionsList.NextLink == nil || len(*p.current.IoTSecuritySolutionsList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IotSecuritySolutionClientListBySubscriptionPager) NextPage(ctx context.Context) (IotSecuritySolutionClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IotSecuritySolutionClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IotSecuritySolutionClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IotSecuritySolutionClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IotSecuritySolutionClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return IotSecuritySolutionClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IotSecuritySolutionsAnalyticsAggregatedAlertClientListPager provides operations for iterating over paged responses.
type IotSecuritySolutionsAnalyticsAggregatedAlertClientListPager struct {
	client    *IotSecuritySolutionsAnalyticsAggregatedAlertClient
	current   IotSecuritySolutionsAnalyticsAggregatedAlertClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IotSecuritySolutionsAnalyticsAggregatedAlertClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IotSecuritySolutionsAnalyticsAggregatedAlertClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IoTSecurityAggregatedAlertList.NextLink == nil || len(*p.current.IoTSecurityAggregatedAlertList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IotSecuritySolutionsAnalyticsAggregatedAlertClientListPager) NextPage(ctx context.Context) (IotSecuritySolutionsAnalyticsAggregatedAlertClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IotSecuritySolutionsAnalyticsAggregatedAlertClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IotSecuritySolutionsAnalyticsAggregatedAlertClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IotSecuritySolutionsAnalyticsAggregatedAlertClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IotSecuritySolutionsAnalyticsAggregatedAlertClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return IotSecuritySolutionsAnalyticsAggregatedAlertClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IotSecuritySolutionsAnalyticsRecommendationClientListPager provides operations for iterating over paged responses.
type IotSecuritySolutionsAnalyticsRecommendationClientListPager struct {
	client    *IotSecuritySolutionsAnalyticsRecommendationClient
	current   IotSecuritySolutionsAnalyticsRecommendationClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IotSecuritySolutionsAnalyticsRecommendationClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IotSecuritySolutionsAnalyticsRecommendationClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IoTSecurityAggregatedRecommendationList.NextLink == nil || len(*p.current.IoTSecurityAggregatedRecommendationList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IotSecuritySolutionsAnalyticsRecommendationClientListPager) NextPage(ctx context.Context) (IotSecuritySolutionsAnalyticsRecommendationClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IotSecuritySolutionsAnalyticsRecommendationClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IotSecuritySolutionsAnalyticsRecommendationClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IotSecuritySolutionsAnalyticsRecommendationClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IotSecuritySolutionsAnalyticsRecommendationClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return IotSecuritySolutionsAnalyticsRecommendationClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// JitNetworkAccessPoliciesClientListByRegionPager provides operations for iterating over paged responses.
type JitNetworkAccessPoliciesClientListByRegionPager struct {
	client    *JitNetworkAccessPoliciesClient
	current   JitNetworkAccessPoliciesClientListByRegionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JitNetworkAccessPoliciesClientListByRegionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *JitNetworkAccessPoliciesClientListByRegionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JitNetworkAccessPoliciesList.NextLink == nil || len(*p.current.JitNetworkAccessPoliciesList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *JitNetworkAccessPoliciesClientListByRegionPager) NextPage(ctx context.Context) (JitNetworkAccessPoliciesClientListByRegionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return JitNetworkAccessPoliciesClientListByRegionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return JitNetworkAccessPoliciesClientListByRegionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return JitNetworkAccessPoliciesClientListByRegionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return JitNetworkAccessPoliciesClientListByRegionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByRegionHandleResponse(resp)
	if err != nil {
		return JitNetworkAccessPoliciesClientListByRegionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// JitNetworkAccessPoliciesClientListByResourceGroupAndRegionPager provides operations for iterating over paged responses.
type JitNetworkAccessPoliciesClientListByResourceGroupAndRegionPager struct {
	client    *JitNetworkAccessPoliciesClient
	current   JitNetworkAccessPoliciesClientListByResourceGroupAndRegionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JitNetworkAccessPoliciesClientListByResourceGroupAndRegionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *JitNetworkAccessPoliciesClientListByResourceGroupAndRegionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JitNetworkAccessPoliciesList.NextLink == nil || len(*p.current.JitNetworkAccessPoliciesList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *JitNetworkAccessPoliciesClientListByResourceGroupAndRegionPager) NextPage(ctx context.Context) (JitNetworkAccessPoliciesClientListByResourceGroupAndRegionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return JitNetworkAccessPoliciesClientListByResourceGroupAndRegionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return JitNetworkAccessPoliciesClientListByResourceGroupAndRegionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return JitNetworkAccessPoliciesClientListByResourceGroupAndRegionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return JitNetworkAccessPoliciesClientListByResourceGroupAndRegionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupAndRegionHandleResponse(resp)
	if err != nil {
		return JitNetworkAccessPoliciesClientListByResourceGroupAndRegionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// JitNetworkAccessPoliciesClientListByResourceGroupPager provides operations for iterating over paged responses.
type JitNetworkAccessPoliciesClientListByResourceGroupPager struct {
	client    *JitNetworkAccessPoliciesClient
	current   JitNetworkAccessPoliciesClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JitNetworkAccessPoliciesClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *JitNetworkAccessPoliciesClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JitNetworkAccessPoliciesList.NextLink == nil || len(*p.current.JitNetworkAccessPoliciesList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *JitNetworkAccessPoliciesClientListByResourceGroupPager) NextPage(ctx context.Context) (JitNetworkAccessPoliciesClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return JitNetworkAccessPoliciesClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return JitNetworkAccessPoliciesClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return JitNetworkAccessPoliciesClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return JitNetworkAccessPoliciesClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return JitNetworkAccessPoliciesClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// JitNetworkAccessPoliciesClientListPager provides operations for iterating over paged responses.
type JitNetworkAccessPoliciesClientListPager struct {
	client    *JitNetworkAccessPoliciesClient
	current   JitNetworkAccessPoliciesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JitNetworkAccessPoliciesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *JitNetworkAccessPoliciesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JitNetworkAccessPoliciesList.NextLink == nil || len(*p.current.JitNetworkAccessPoliciesList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *JitNetworkAccessPoliciesClientListPager) NextPage(ctx context.Context) (JitNetworkAccessPoliciesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return JitNetworkAccessPoliciesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return JitNetworkAccessPoliciesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return JitNetworkAccessPoliciesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return JitNetworkAccessPoliciesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return JitNetworkAccessPoliciesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// LocationsClientListPager provides operations for iterating over paged responses.
type LocationsClientListPager struct {
	client    *LocationsClient
	current   LocationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LocationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *LocationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AscLocationList.NextLink == nil || len(*p.current.AscLocationList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *LocationsClientListPager) NextPage(ctx context.Context) (LocationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return LocationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return LocationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return LocationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return LocationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return LocationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *OperationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationList.NextLink == nil || len(*p.current.OperationList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *OperationsClientListPager) NextPage(ctx context.Context) (OperationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return OperationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return OperationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RegulatoryComplianceAssessmentsClientListPager provides operations for iterating over paged responses.
type RegulatoryComplianceAssessmentsClientListPager struct {
	client    *RegulatoryComplianceAssessmentsClient
	current   RegulatoryComplianceAssessmentsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RegulatoryComplianceAssessmentsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RegulatoryComplianceAssessmentsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RegulatoryComplianceAssessmentList.NextLink == nil || len(*p.current.RegulatoryComplianceAssessmentList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RegulatoryComplianceAssessmentsClientListPager) NextPage(ctx context.Context) (RegulatoryComplianceAssessmentsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RegulatoryComplianceAssessmentsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RegulatoryComplianceAssessmentsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RegulatoryComplianceAssessmentsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RegulatoryComplianceAssessmentsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return RegulatoryComplianceAssessmentsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RegulatoryComplianceControlsClientListPager provides operations for iterating over paged responses.
type RegulatoryComplianceControlsClientListPager struct {
	client    *RegulatoryComplianceControlsClient
	current   RegulatoryComplianceControlsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RegulatoryComplianceControlsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RegulatoryComplianceControlsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RegulatoryComplianceControlList.NextLink == nil || len(*p.current.RegulatoryComplianceControlList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RegulatoryComplianceControlsClientListPager) NextPage(ctx context.Context) (RegulatoryComplianceControlsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RegulatoryComplianceControlsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RegulatoryComplianceControlsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RegulatoryComplianceControlsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RegulatoryComplianceControlsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return RegulatoryComplianceControlsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RegulatoryComplianceStandardsClientListPager provides operations for iterating over paged responses.
type RegulatoryComplianceStandardsClientListPager struct {
	client    *RegulatoryComplianceStandardsClient
	current   RegulatoryComplianceStandardsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RegulatoryComplianceStandardsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RegulatoryComplianceStandardsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RegulatoryComplianceStandardList.NextLink == nil || len(*p.current.RegulatoryComplianceStandardList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RegulatoryComplianceStandardsClientListPager) NextPage(ctx context.Context) (RegulatoryComplianceStandardsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RegulatoryComplianceStandardsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RegulatoryComplianceStandardsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RegulatoryComplianceStandardsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RegulatoryComplianceStandardsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return RegulatoryComplianceStandardsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SecureScoreControlDefinitionsClientListBySubscriptionPager provides operations for iterating over paged responses.
type SecureScoreControlDefinitionsClientListBySubscriptionPager struct {
	client    *SecureScoreControlDefinitionsClient
	current   SecureScoreControlDefinitionsClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecureScoreControlDefinitionsClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SecureScoreControlDefinitionsClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecureScoreControlDefinitionList.NextLink == nil || len(*p.current.SecureScoreControlDefinitionList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SecureScoreControlDefinitionsClientListBySubscriptionPager) NextPage(ctx context.Context) (SecureScoreControlDefinitionsClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SecureScoreControlDefinitionsClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SecureScoreControlDefinitionsClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SecureScoreControlDefinitionsClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SecureScoreControlDefinitionsClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return SecureScoreControlDefinitionsClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SecureScoreControlDefinitionsClientListPager provides operations for iterating over paged responses.
type SecureScoreControlDefinitionsClientListPager struct {
	client    *SecureScoreControlDefinitionsClient
	current   SecureScoreControlDefinitionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecureScoreControlDefinitionsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SecureScoreControlDefinitionsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecureScoreControlDefinitionList.NextLink == nil || len(*p.current.SecureScoreControlDefinitionList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SecureScoreControlDefinitionsClientListPager) NextPage(ctx context.Context) (SecureScoreControlDefinitionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SecureScoreControlDefinitionsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SecureScoreControlDefinitionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SecureScoreControlDefinitionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SecureScoreControlDefinitionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return SecureScoreControlDefinitionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SecureScoreControlsClientListBySecureScorePager provides operations for iterating over paged responses.
type SecureScoreControlsClientListBySecureScorePager struct {
	client    *SecureScoreControlsClient
	current   SecureScoreControlsClientListBySecureScoreResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecureScoreControlsClientListBySecureScoreResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SecureScoreControlsClientListBySecureScorePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecureScoreControlList.NextLink == nil || len(*p.current.SecureScoreControlList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SecureScoreControlsClientListBySecureScorePager) NextPage(ctx context.Context) (SecureScoreControlsClientListBySecureScoreResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SecureScoreControlsClientListBySecureScoreResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SecureScoreControlsClientListBySecureScoreResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SecureScoreControlsClientListBySecureScoreResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SecureScoreControlsClientListBySecureScoreResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySecureScoreHandleResponse(resp)
	if err != nil {
		return SecureScoreControlsClientListBySecureScoreResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SecureScoreControlsClientListPager provides operations for iterating over paged responses.
type SecureScoreControlsClientListPager struct {
	client    *SecureScoreControlsClient
	current   SecureScoreControlsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecureScoreControlsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SecureScoreControlsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecureScoreControlList.NextLink == nil || len(*p.current.SecureScoreControlList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SecureScoreControlsClientListPager) NextPage(ctx context.Context) (SecureScoreControlsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SecureScoreControlsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SecureScoreControlsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SecureScoreControlsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SecureScoreControlsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return SecureScoreControlsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SecureScoresClientListPager provides operations for iterating over paged responses.
type SecureScoresClientListPager struct {
	client    *SecureScoresClient
	current   SecureScoresClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecureScoresClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SecureScoresClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecureScoresList.NextLink == nil || len(*p.current.SecureScoresList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SecureScoresClientListPager) NextPage(ctx context.Context) (SecureScoresClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SecureScoresClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SecureScoresClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SecureScoresClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SecureScoresClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return SecureScoresClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SettingsClientListPager provides operations for iterating over paged responses.
type SettingsClientListPager struct {
	client    *SettingsClient
	current   SettingsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SettingsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SettingsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SettingsList.NextLink == nil || len(*p.current.SettingsList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SettingsClientListPager) NextPage(ctx context.Context) (SettingsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SettingsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SettingsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SettingsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SettingsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return SettingsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SoftwareInventoriesClientListByExtendedResourcePager provides operations for iterating over paged responses.
type SoftwareInventoriesClientListByExtendedResourcePager struct {
	client    *SoftwareInventoriesClient
	current   SoftwareInventoriesClientListByExtendedResourceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SoftwareInventoriesClientListByExtendedResourceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SoftwareInventoriesClientListByExtendedResourcePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SoftwaresList.NextLink == nil || len(*p.current.SoftwaresList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SoftwareInventoriesClientListByExtendedResourcePager) NextPage(ctx context.Context) (SoftwareInventoriesClientListByExtendedResourceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SoftwareInventoriesClientListByExtendedResourceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SoftwareInventoriesClientListByExtendedResourceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SoftwareInventoriesClientListByExtendedResourceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SoftwareInventoriesClientListByExtendedResourceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByExtendedResourceHandleResponse(resp)
	if err != nil {
		return SoftwareInventoriesClientListByExtendedResourceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SoftwareInventoriesClientListBySubscriptionPager provides operations for iterating over paged responses.
type SoftwareInventoriesClientListBySubscriptionPager struct {
	client    *SoftwareInventoriesClient
	current   SoftwareInventoriesClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SoftwareInventoriesClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SoftwareInventoriesClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SoftwaresList.NextLink == nil || len(*p.current.SoftwaresList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SoftwareInventoriesClientListBySubscriptionPager) NextPage(ctx context.Context) (SoftwareInventoriesClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SoftwareInventoriesClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SoftwareInventoriesClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SoftwareInventoriesClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SoftwareInventoriesClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return SoftwareInventoriesClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SolutionsClientListPager provides operations for iterating over paged responses.
type SolutionsClientListPager struct {
	client    *SolutionsClient
	current   SolutionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SolutionsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SolutionsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SolutionList.NextLink == nil || len(*p.current.SolutionList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SolutionsClientListPager) NextPage(ctx context.Context) (SolutionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SolutionsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SolutionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SolutionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SolutionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return SolutionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SubAssessmentsClientListAllPager provides operations for iterating over paged responses.
type SubAssessmentsClientListAllPager struct {
	client    *SubAssessmentsClient
	current   SubAssessmentsClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubAssessmentsClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SubAssessmentsClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubAssessmentList.NextLink == nil || len(*p.current.SubAssessmentList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SubAssessmentsClientListAllPager) NextPage(ctx context.Context) (SubAssessmentsClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SubAssessmentsClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SubAssessmentsClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SubAssessmentsClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SubAssessmentsClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return SubAssessmentsClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SubAssessmentsClientListPager provides operations for iterating over paged responses.
type SubAssessmentsClientListPager struct {
	client    *SubAssessmentsClient
	current   SubAssessmentsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubAssessmentsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SubAssessmentsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubAssessmentList.NextLink == nil || len(*p.current.SubAssessmentList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SubAssessmentsClientListPager) NextPage(ctx context.Context) (SubAssessmentsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SubAssessmentsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SubAssessmentsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SubAssessmentsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SubAssessmentsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return SubAssessmentsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TasksClientListByHomeRegionPager provides operations for iterating over paged responses.
type TasksClientListByHomeRegionPager struct {
	client    *TasksClient
	current   TasksClientListByHomeRegionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TasksClientListByHomeRegionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TasksClientListByHomeRegionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TaskList.NextLink == nil || len(*p.current.TaskList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *TasksClientListByHomeRegionPager) NextPage(ctx context.Context) (TasksClientListByHomeRegionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return TasksClientListByHomeRegionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TasksClientListByHomeRegionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TasksClientListByHomeRegionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TasksClientListByHomeRegionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByHomeRegionHandleResponse(resp)
	if err != nil {
		return TasksClientListByHomeRegionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TasksClientListByResourceGroupPager provides operations for iterating over paged responses.
type TasksClientListByResourceGroupPager struct {
	client    *TasksClient
	current   TasksClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TasksClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TasksClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TaskList.NextLink == nil || len(*p.current.TaskList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *TasksClientListByResourceGroupPager) NextPage(ctx context.Context) (TasksClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return TasksClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TasksClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TasksClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TasksClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return TasksClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TasksClientListPager provides operations for iterating over paged responses.
type TasksClientListPager struct {
	client    *TasksClient
	current   TasksClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TasksClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TasksClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TaskList.NextLink == nil || len(*p.current.TaskList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *TasksClientListPager) NextPage(ctx context.Context) (TasksClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return TasksClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TasksClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TasksClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TasksClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return TasksClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TopologyClientListByHomeRegionPager provides operations for iterating over paged responses.
type TopologyClientListByHomeRegionPager struct {
	client    *TopologyClient
	current   TopologyClientListByHomeRegionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TopologyClientListByHomeRegionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TopologyClientListByHomeRegionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TopologyList.NextLink == nil || len(*p.current.TopologyList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *TopologyClientListByHomeRegionPager) NextPage(ctx context.Context) (TopologyClientListByHomeRegionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return TopologyClientListByHomeRegionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TopologyClientListByHomeRegionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TopologyClientListByHomeRegionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TopologyClientListByHomeRegionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByHomeRegionHandleResponse(resp)
	if err != nil {
		return TopologyClientListByHomeRegionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TopologyClientListPager provides operations for iterating over paged responses.
type TopologyClientListPager struct {
	client    *TopologyClient
	current   TopologyClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TopologyClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TopologyClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TopologyList.NextLink == nil || len(*p.current.TopologyList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *TopologyClientListPager) NextPage(ctx context.Context) (TopologyClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return TopologyClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TopologyClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TopologyClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TopologyClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return TopologyClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkspaceSettingsClientListPager provides operations for iterating over paged responses.
type WorkspaceSettingsClientListPager struct {
	client    *WorkspaceSettingsClient
	current   WorkspaceSettingsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkspaceSettingsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkspaceSettingsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkspaceSettingList.NextLink == nil || len(*p.current.WorkspaceSettingList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WorkspaceSettingsClientListPager) NextPage(ctx context.Context) (WorkspaceSettingsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WorkspaceSettingsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkspaceSettingsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkspaceSettingsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkspaceSettingsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return WorkspaceSettingsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}
