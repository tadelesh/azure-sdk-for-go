//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armlogic

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// IntegrationAccountAgreementsClientListPager provides operations for iterating over paged responses.
type IntegrationAccountAgreementsClientListPager struct {
	client    *IntegrationAccountAgreementsClient
	current   IntegrationAccountAgreementsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationAccountAgreementsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IntegrationAccountAgreementsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationAccountAgreementListResult.NextLink == nil || len(*p.current.IntegrationAccountAgreementListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IntegrationAccountAgreementsClientListPager) NextPage(ctx context.Context) (IntegrationAccountAgreementsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IntegrationAccountAgreementsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IntegrationAccountAgreementsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IntegrationAccountAgreementsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IntegrationAccountAgreementsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return IntegrationAccountAgreementsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IntegrationAccountAssembliesClientListPager provides operations for iterating over paged responses.
type IntegrationAccountAssembliesClientListPager struct {
	client    *IntegrationAccountAssembliesClient
	current   IntegrationAccountAssembliesClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IntegrationAccountAssembliesClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *IntegrationAccountAssembliesClientListPager) NextPage(ctx context.Context) (IntegrationAccountAssembliesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return IntegrationAccountAssembliesClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IntegrationAccountAssembliesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IntegrationAccountAssembliesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IntegrationAccountAssembliesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return IntegrationAccountAssembliesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IntegrationAccountBatchConfigurationsClientListPager provides operations for iterating over paged responses.
type IntegrationAccountBatchConfigurationsClientListPager struct {
	client    *IntegrationAccountBatchConfigurationsClient
	current   IntegrationAccountBatchConfigurationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IntegrationAccountBatchConfigurationsClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *IntegrationAccountBatchConfigurationsClientListPager) NextPage(ctx context.Context) (IntegrationAccountBatchConfigurationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return IntegrationAccountBatchConfigurationsClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IntegrationAccountBatchConfigurationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IntegrationAccountBatchConfigurationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IntegrationAccountBatchConfigurationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return IntegrationAccountBatchConfigurationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IntegrationAccountCertificatesClientListPager provides operations for iterating over paged responses.
type IntegrationAccountCertificatesClientListPager struct {
	client    *IntegrationAccountCertificatesClient
	current   IntegrationAccountCertificatesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationAccountCertificatesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IntegrationAccountCertificatesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationAccountCertificateListResult.NextLink == nil || len(*p.current.IntegrationAccountCertificateListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IntegrationAccountCertificatesClientListPager) NextPage(ctx context.Context) (IntegrationAccountCertificatesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IntegrationAccountCertificatesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IntegrationAccountCertificatesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IntegrationAccountCertificatesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IntegrationAccountCertificatesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return IntegrationAccountCertificatesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IntegrationAccountMapsClientListPager provides operations for iterating over paged responses.
type IntegrationAccountMapsClientListPager struct {
	client    *IntegrationAccountMapsClient
	current   IntegrationAccountMapsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationAccountMapsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IntegrationAccountMapsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationAccountMapListResult.NextLink == nil || len(*p.current.IntegrationAccountMapListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IntegrationAccountMapsClientListPager) NextPage(ctx context.Context) (IntegrationAccountMapsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IntegrationAccountMapsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IntegrationAccountMapsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IntegrationAccountMapsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IntegrationAccountMapsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return IntegrationAccountMapsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IntegrationAccountPartnersClientListPager provides operations for iterating over paged responses.
type IntegrationAccountPartnersClientListPager struct {
	client    *IntegrationAccountPartnersClient
	current   IntegrationAccountPartnersClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationAccountPartnersClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IntegrationAccountPartnersClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationAccountPartnerListResult.NextLink == nil || len(*p.current.IntegrationAccountPartnerListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IntegrationAccountPartnersClientListPager) NextPage(ctx context.Context) (IntegrationAccountPartnersClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IntegrationAccountPartnersClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IntegrationAccountPartnersClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IntegrationAccountPartnersClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IntegrationAccountPartnersClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return IntegrationAccountPartnersClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IntegrationAccountSchemasClientListPager provides operations for iterating over paged responses.
type IntegrationAccountSchemasClientListPager struct {
	client    *IntegrationAccountSchemasClient
	current   IntegrationAccountSchemasClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationAccountSchemasClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IntegrationAccountSchemasClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationAccountSchemaListResult.NextLink == nil || len(*p.current.IntegrationAccountSchemaListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IntegrationAccountSchemasClientListPager) NextPage(ctx context.Context) (IntegrationAccountSchemasClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IntegrationAccountSchemasClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IntegrationAccountSchemasClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IntegrationAccountSchemasClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IntegrationAccountSchemasClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return IntegrationAccountSchemasClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IntegrationAccountSessionsClientListPager provides operations for iterating over paged responses.
type IntegrationAccountSessionsClientListPager struct {
	client    *IntegrationAccountSessionsClient
	current   IntegrationAccountSessionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationAccountSessionsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IntegrationAccountSessionsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationAccountSessionListResult.NextLink == nil || len(*p.current.IntegrationAccountSessionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IntegrationAccountSessionsClientListPager) NextPage(ctx context.Context) (IntegrationAccountSessionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IntegrationAccountSessionsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IntegrationAccountSessionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IntegrationAccountSessionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IntegrationAccountSessionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return IntegrationAccountSessionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IntegrationAccountsClientListByResourceGroupPager provides operations for iterating over paged responses.
type IntegrationAccountsClientListByResourceGroupPager struct {
	client    *IntegrationAccountsClient
	current   IntegrationAccountsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationAccountsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IntegrationAccountsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationAccountListResult.NextLink == nil || len(*p.current.IntegrationAccountListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IntegrationAccountsClientListByResourceGroupPager) NextPage(ctx context.Context) (IntegrationAccountsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IntegrationAccountsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IntegrationAccountsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IntegrationAccountsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IntegrationAccountsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return IntegrationAccountsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IntegrationAccountsClientListBySubscriptionPager provides operations for iterating over paged responses.
type IntegrationAccountsClientListBySubscriptionPager struct {
	client    *IntegrationAccountsClient
	current   IntegrationAccountsClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationAccountsClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IntegrationAccountsClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationAccountListResult.NextLink == nil || len(*p.current.IntegrationAccountListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IntegrationAccountsClientListBySubscriptionPager) NextPage(ctx context.Context) (IntegrationAccountsClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IntegrationAccountsClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IntegrationAccountsClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IntegrationAccountsClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IntegrationAccountsClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return IntegrationAccountsClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IntegrationAccountsClientListKeyVaultKeysPager provides operations for iterating over paged responses.
type IntegrationAccountsClientListKeyVaultKeysPager struct {
	client    *IntegrationAccountsClient
	current   IntegrationAccountsClientListKeyVaultKeysResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IntegrationAccountsClientListKeyVaultKeysPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *IntegrationAccountsClientListKeyVaultKeysPager) NextPage(ctx context.Context) (IntegrationAccountsClientListKeyVaultKeysResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return IntegrationAccountsClientListKeyVaultKeysResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IntegrationAccountsClientListKeyVaultKeysResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IntegrationAccountsClientListKeyVaultKeysResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IntegrationAccountsClientListKeyVaultKeysResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listKeyVaultKeysHandleResponse(resp)
	if err != nil {
		return IntegrationAccountsClientListKeyVaultKeysResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IntegrationServiceEnvironmentManagedAPIOperationsClientListPager provides operations for iterating over paged responses.
type IntegrationServiceEnvironmentManagedAPIOperationsClientListPager struct {
	client    *IntegrationServiceEnvironmentManagedAPIOperationsClient
	current   IntegrationServiceEnvironmentManagedAPIOperationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationServiceEnvironmentManagedAPIOperationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IntegrationServiceEnvironmentManagedAPIOperationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APIOperationListResult.NextLink == nil || len(*p.current.APIOperationListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IntegrationServiceEnvironmentManagedAPIOperationsClientListPager) NextPage(ctx context.Context) (IntegrationServiceEnvironmentManagedAPIOperationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IntegrationServiceEnvironmentManagedAPIOperationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IntegrationServiceEnvironmentManagedAPIOperationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IntegrationServiceEnvironmentManagedAPIOperationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IntegrationServiceEnvironmentManagedAPIOperationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return IntegrationServiceEnvironmentManagedAPIOperationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IntegrationServiceEnvironmentManagedApisClientListPager provides operations for iterating over paged responses.
type IntegrationServiceEnvironmentManagedApisClientListPager struct {
	client    *IntegrationServiceEnvironmentManagedApisClient
	current   IntegrationServiceEnvironmentManagedApisClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationServiceEnvironmentManagedApisClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IntegrationServiceEnvironmentManagedApisClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationServiceEnvironmentManagedAPIListResult.NextLink == nil || len(*p.current.IntegrationServiceEnvironmentManagedAPIListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IntegrationServiceEnvironmentManagedApisClientListPager) NextPage(ctx context.Context) (IntegrationServiceEnvironmentManagedApisClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IntegrationServiceEnvironmentManagedApisClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IntegrationServiceEnvironmentManagedApisClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IntegrationServiceEnvironmentManagedApisClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IntegrationServiceEnvironmentManagedApisClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return IntegrationServiceEnvironmentManagedApisClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IntegrationServiceEnvironmentSKUsClientListPager provides operations for iterating over paged responses.
type IntegrationServiceEnvironmentSKUsClientListPager struct {
	client    *IntegrationServiceEnvironmentSKUsClient
	current   IntegrationServiceEnvironmentSKUsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationServiceEnvironmentSKUsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IntegrationServiceEnvironmentSKUsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationServiceEnvironmentSKUList.NextLink == nil || len(*p.current.IntegrationServiceEnvironmentSKUList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IntegrationServiceEnvironmentSKUsClientListPager) NextPage(ctx context.Context) (IntegrationServiceEnvironmentSKUsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IntegrationServiceEnvironmentSKUsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IntegrationServiceEnvironmentSKUsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IntegrationServiceEnvironmentSKUsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IntegrationServiceEnvironmentSKUsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return IntegrationServiceEnvironmentSKUsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IntegrationServiceEnvironmentsClientListByResourceGroupPager provides operations for iterating over paged responses.
type IntegrationServiceEnvironmentsClientListByResourceGroupPager struct {
	client    *IntegrationServiceEnvironmentsClient
	current   IntegrationServiceEnvironmentsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationServiceEnvironmentsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IntegrationServiceEnvironmentsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationServiceEnvironmentListResult.NextLink == nil || len(*p.current.IntegrationServiceEnvironmentListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IntegrationServiceEnvironmentsClientListByResourceGroupPager) NextPage(ctx context.Context) (IntegrationServiceEnvironmentsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IntegrationServiceEnvironmentsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IntegrationServiceEnvironmentsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IntegrationServiceEnvironmentsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IntegrationServiceEnvironmentsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return IntegrationServiceEnvironmentsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IntegrationServiceEnvironmentsClientListBySubscriptionPager provides operations for iterating over paged responses.
type IntegrationServiceEnvironmentsClientListBySubscriptionPager struct {
	client    *IntegrationServiceEnvironmentsClient
	current   IntegrationServiceEnvironmentsClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IntegrationServiceEnvironmentsClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IntegrationServiceEnvironmentsClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IntegrationServiceEnvironmentListResult.NextLink == nil || len(*p.current.IntegrationServiceEnvironmentListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IntegrationServiceEnvironmentsClientListBySubscriptionPager) NextPage(ctx context.Context) (IntegrationServiceEnvironmentsClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IntegrationServiceEnvironmentsClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IntegrationServiceEnvironmentsClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IntegrationServiceEnvironmentsClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IntegrationServiceEnvironmentsClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return IntegrationServiceEnvironmentsClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *OperationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *OperationsClientListPager) NextPage(ctx context.Context) (OperationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return OperationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return OperationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkflowRunActionRepetitionsClientListExpressionTracesPager provides operations for iterating over paged responses.
type WorkflowRunActionRepetitionsClientListExpressionTracesPager struct {
	client    *WorkflowRunActionRepetitionsClient
	current   WorkflowRunActionRepetitionsClientListExpressionTracesResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkflowRunActionRepetitionsClientListExpressionTracesPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *WorkflowRunActionRepetitionsClientListExpressionTracesPager) NextPage(ctx context.Context) (WorkflowRunActionRepetitionsClientListExpressionTracesResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return WorkflowRunActionRepetitionsClientListExpressionTracesResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkflowRunActionRepetitionsClientListExpressionTracesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkflowRunActionRepetitionsClientListExpressionTracesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkflowRunActionRepetitionsClientListExpressionTracesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listExpressionTracesHandleResponse(resp)
	if err != nil {
		return WorkflowRunActionRepetitionsClientListExpressionTracesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkflowRunActionRepetitionsClientListPager provides operations for iterating over paged responses.
type WorkflowRunActionRepetitionsClientListPager struct {
	client    *WorkflowRunActionRepetitionsClient
	current   WorkflowRunActionRepetitionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkflowRunActionRepetitionsClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *WorkflowRunActionRepetitionsClientListPager) NextPage(ctx context.Context) (WorkflowRunActionRepetitionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return WorkflowRunActionRepetitionsClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkflowRunActionRepetitionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkflowRunActionRepetitionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkflowRunActionRepetitionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return WorkflowRunActionRepetitionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkflowRunActionRepetitionsRequestHistoriesClientListPager provides operations for iterating over paged responses.
type WorkflowRunActionRepetitionsRequestHistoriesClientListPager struct {
	client    *WorkflowRunActionRepetitionsRequestHistoriesClient
	current   WorkflowRunActionRepetitionsRequestHistoriesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkflowRunActionRepetitionsRequestHistoriesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkflowRunActionRepetitionsRequestHistoriesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RequestHistoryListResult.NextLink == nil || len(*p.current.RequestHistoryListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WorkflowRunActionRepetitionsRequestHistoriesClientListPager) NextPage(ctx context.Context) (WorkflowRunActionRepetitionsRequestHistoriesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WorkflowRunActionRepetitionsRequestHistoriesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkflowRunActionRepetitionsRequestHistoriesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkflowRunActionRepetitionsRequestHistoriesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkflowRunActionRepetitionsRequestHistoriesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return WorkflowRunActionRepetitionsRequestHistoriesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkflowRunActionRequestHistoriesClientListPager provides operations for iterating over paged responses.
type WorkflowRunActionRequestHistoriesClientListPager struct {
	client    *WorkflowRunActionRequestHistoriesClient
	current   WorkflowRunActionRequestHistoriesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkflowRunActionRequestHistoriesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkflowRunActionRequestHistoriesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RequestHistoryListResult.NextLink == nil || len(*p.current.RequestHistoryListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WorkflowRunActionRequestHistoriesClientListPager) NextPage(ctx context.Context) (WorkflowRunActionRequestHistoriesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WorkflowRunActionRequestHistoriesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkflowRunActionRequestHistoriesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkflowRunActionRequestHistoriesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkflowRunActionRequestHistoriesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return WorkflowRunActionRequestHistoriesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkflowRunActionScopeRepetitionsClientListPager provides operations for iterating over paged responses.
type WorkflowRunActionScopeRepetitionsClientListPager struct {
	client    *WorkflowRunActionScopeRepetitionsClient
	current   WorkflowRunActionScopeRepetitionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkflowRunActionScopeRepetitionsClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *WorkflowRunActionScopeRepetitionsClientListPager) NextPage(ctx context.Context) (WorkflowRunActionScopeRepetitionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return WorkflowRunActionScopeRepetitionsClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkflowRunActionScopeRepetitionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkflowRunActionScopeRepetitionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkflowRunActionScopeRepetitionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return WorkflowRunActionScopeRepetitionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkflowRunActionsClientListExpressionTracesPager provides operations for iterating over paged responses.
type WorkflowRunActionsClientListExpressionTracesPager struct {
	client    *WorkflowRunActionsClient
	current   WorkflowRunActionsClientListExpressionTracesResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkflowRunActionsClientListExpressionTracesPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *WorkflowRunActionsClientListExpressionTracesPager) NextPage(ctx context.Context) (WorkflowRunActionsClientListExpressionTracesResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return WorkflowRunActionsClientListExpressionTracesResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkflowRunActionsClientListExpressionTracesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkflowRunActionsClientListExpressionTracesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkflowRunActionsClientListExpressionTracesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listExpressionTracesHandleResponse(resp)
	if err != nil {
		return WorkflowRunActionsClientListExpressionTracesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkflowRunActionsClientListPager provides operations for iterating over paged responses.
type WorkflowRunActionsClientListPager struct {
	client    *WorkflowRunActionsClient
	current   WorkflowRunActionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkflowRunActionsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkflowRunActionsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkflowRunActionListResult.NextLink == nil || len(*p.current.WorkflowRunActionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WorkflowRunActionsClientListPager) NextPage(ctx context.Context) (WorkflowRunActionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WorkflowRunActionsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkflowRunActionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkflowRunActionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkflowRunActionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return WorkflowRunActionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkflowRunsClientListPager provides operations for iterating over paged responses.
type WorkflowRunsClientListPager struct {
	client    *WorkflowRunsClient
	current   WorkflowRunsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkflowRunsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkflowRunsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkflowRunListResult.NextLink == nil || len(*p.current.WorkflowRunListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WorkflowRunsClientListPager) NextPage(ctx context.Context) (WorkflowRunsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WorkflowRunsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkflowRunsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkflowRunsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkflowRunsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return WorkflowRunsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkflowTriggerHistoriesClientListPager provides operations for iterating over paged responses.
type WorkflowTriggerHistoriesClientListPager struct {
	client    *WorkflowTriggerHistoriesClient
	current   WorkflowTriggerHistoriesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkflowTriggerHistoriesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkflowTriggerHistoriesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkflowTriggerHistoryListResult.NextLink == nil || len(*p.current.WorkflowTriggerHistoryListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WorkflowTriggerHistoriesClientListPager) NextPage(ctx context.Context) (WorkflowTriggerHistoriesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WorkflowTriggerHistoriesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkflowTriggerHistoriesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkflowTriggerHistoriesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkflowTriggerHistoriesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return WorkflowTriggerHistoriesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkflowTriggersClientListPager provides operations for iterating over paged responses.
type WorkflowTriggersClientListPager struct {
	client    *WorkflowTriggersClient
	current   WorkflowTriggersClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkflowTriggersClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkflowTriggersClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkflowTriggerListResult.NextLink == nil || len(*p.current.WorkflowTriggerListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WorkflowTriggersClientListPager) NextPage(ctx context.Context) (WorkflowTriggersClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WorkflowTriggersClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkflowTriggersClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkflowTriggersClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkflowTriggersClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return WorkflowTriggersClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkflowVersionsClientListPager provides operations for iterating over paged responses.
type WorkflowVersionsClientListPager struct {
	client    *WorkflowVersionsClient
	current   WorkflowVersionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkflowVersionsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkflowVersionsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkflowVersionListResult.NextLink == nil || len(*p.current.WorkflowVersionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WorkflowVersionsClientListPager) NextPage(ctx context.Context) (WorkflowVersionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WorkflowVersionsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkflowVersionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkflowVersionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkflowVersionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return WorkflowVersionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkflowsClientListByResourceGroupPager provides operations for iterating over paged responses.
type WorkflowsClientListByResourceGroupPager struct {
	client    *WorkflowsClient
	current   WorkflowsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkflowsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkflowsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkflowListResult.NextLink == nil || len(*p.current.WorkflowListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WorkflowsClientListByResourceGroupPager) NextPage(ctx context.Context) (WorkflowsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WorkflowsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkflowsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkflowsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkflowsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return WorkflowsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkflowsClientListBySubscriptionPager provides operations for iterating over paged responses.
type WorkflowsClientListBySubscriptionPager struct {
	client    *WorkflowsClient
	current   WorkflowsClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkflowsClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkflowsClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkflowListResult.NextLink == nil || len(*p.current.WorkflowListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WorkflowsClientListBySubscriptionPager) NextPage(ctx context.Context) (WorkflowsClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WorkflowsClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkflowsClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkflowsClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkflowsClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return WorkflowsClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}
