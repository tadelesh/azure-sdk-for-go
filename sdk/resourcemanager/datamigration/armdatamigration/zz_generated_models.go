//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdatamigration

import (
	"encoding/json"
	"reflect"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
)

// APIError - Error information.
// Implements the error and azcore.HTTPResponse interfaces.
type APIError struct {
	raw string
	// Error information in OData format
	InnerError *ODataError `json:"error,omitempty"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// Error implements the error interface for type APIError.
// The contents of the error text are not contractual and subject to change.
func (e APIError) Error() string {
	return e.raw
}

// AvailableServiceSKU - Describes the available service SKU.
type AvailableServiceSKU struct {
	// A description of the scaling capacities of the SKU
	Capacity *AvailableServiceSKUCapacity `json:"capacity,omitempty"`

	// The resource type, including the provider namespace
	ResourceType *string `json:"resourceType,omitempty"`

	// SKU name, tier, etc.
	SKU *AvailableServiceSKUSKU `json:"sku,omitempty"`
}

// AvailableServiceSKUCapacity - A description of the scaling capacities of the SKU
type AvailableServiceSKUCapacity struct {
	// The default capacity
	Default *int32 `json:"default,omitempty"`

	// The maximum capacity
	Maximum *int32 `json:"maximum,omitempty"`

	// The minimum capacity, usually 0 or 1.
	Minimum *int32 `json:"minimum,omitempty"`

	// The scalability approach
	ScaleType *ServiceScalability `json:"scaleType,omitempty"`
}

// AvailableServiceSKUSKU - SKU name, tier, etc.
type AvailableServiceSKUSKU struct {
	// SKU family
	Family *string `json:"family,omitempty"`

	// The name of the SKU
	Name *string `json:"name,omitempty"`

	// SKU size
	Size *string `json:"size,omitempty"`

	// The tier of the SKU, such as "Basic", "General Purpose", or "Business Critical"
	Tier *string `json:"tier,omitempty"`
}

// AzureActiveDirectoryApp - Azure Active Directory Application
type AzureActiveDirectoryApp struct {
	// REQUIRED; Key used to authenticate to the Azure Active Directory Application
	AppKey *string `json:"appKey,omitempty"`

	// REQUIRED; Application ID of the Azure Active Directory Application
	ApplicationID *string `json:"applicationId,omitempty"`

	// REQUIRED; Tenant id of the customer
	TenantID *string `json:"tenantId,omitempty"`
}

// BackupFileInfo - Information of the backup file
type BackupFileInfo struct {
	// Sequence number of the backup file in the backup set
	FamilySequenceNumber *int32 `json:"familySequenceNumber,omitempty"`

	// Location of the backup file in shared folder
	FileLocation *string `json:"fileLocation,omitempty"`

	// Status of the backup file during migration
	Status *BackupFileStatus `json:"status,omitempty"`
}

// BackupSetInfo - Information of backup set
type BackupSetInfo struct {
	// Date and time that the backup operation finished
	BackupFinishedDate *time.Time `json:"backupFinishedDate,omitempty"`

	// Id for the set of backup files
	BackupSetID *string `json:"backupSetId,omitempty"`

	// Date and time that the backup operation began
	BackupStartDate *time.Time `json:"backupStartDate,omitempty"`

	// Enum of the different backup types
	BackupType *BackupType `json:"backupType,omitempty"`

	// Name of the database to which the backup set belongs
	DatabaseName *string `json:"databaseName,omitempty"`

	// First log sequence number of the backup file
	FirstLsn *string `json:"firstLsn,omitempty"`

	// Whether the backup set is restored or not
	IsBackupRestored *bool `json:"isBackupRestored,omitempty"`

	// Last log sequence number of the backup file
	LastLsn *string `json:"lastLsn,omitempty"`

	// Last modified time of the backup file in share location
	LastModifiedTime *time.Time `json:"lastModifiedTime,omitempty"`

	// List of files in the backup set
	ListOfBackupFiles []*BackupFileInfo `json:"listOfBackupFiles,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BackupSetInfo.
func (b BackupSetInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupFinishedDate", (*timeRFC3339)(b.BackupFinishedDate))
	populate(objectMap, "backupSetId", b.BackupSetID)
	populate(objectMap, "backupStartDate", (*timeRFC3339)(b.BackupStartDate))
	populate(objectMap, "backupType", b.BackupType)
	populate(objectMap, "databaseName", b.DatabaseName)
	populate(objectMap, "firstLsn", b.FirstLsn)
	populate(objectMap, "isBackupRestored", b.IsBackupRestored)
	populate(objectMap, "lastLsn", b.LastLsn)
	populate(objectMap, "lastModifiedTime", (*timeRFC3339)(b.LastModifiedTime))
	populate(objectMap, "listOfBackupFiles", b.ListOfBackupFiles)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupSetInfo.
func (b *BackupSetInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupFinishedDate":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			b.BackupFinishedDate = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "backupSetId":
			err = unpopulate(val, &b.BackupSetID)
			delete(rawMsg, key)
		case "backupStartDate":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			b.BackupStartDate = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "backupType":
			err = unpopulate(val, &b.BackupType)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &b.DatabaseName)
			delete(rawMsg, key)
		case "firstLsn":
			err = unpopulate(val, &b.FirstLsn)
			delete(rawMsg, key)
		case "isBackupRestored":
			err = unpopulate(val, &b.IsBackupRestored)
			delete(rawMsg, key)
		case "lastLsn":
			err = unpopulate(val, &b.LastLsn)
			delete(rawMsg, key)
		case "lastModifiedTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			b.LastModifiedTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "listOfBackupFiles":
			err = unpopulate(val, &b.ListOfBackupFiles)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BlobShare - Blob container storage information.
type BlobShare struct {
	// REQUIRED; SAS URI of Azure Storage Account Container.
	SasURI *string `json:"sasUri,omitempty"`
}

// CheckOCIDriverTaskInput - Input for the service task to check for OCI drivers.
type CheckOCIDriverTaskInput struct {
	// Version of the source server to check against. Optional.
	ServerVersion *string `json:"serverVersion,omitempty"`
}

// CheckOCIDriverTaskOutput - Output for the service task to check for OCI drivers.
type CheckOCIDriverTaskOutput struct {
	// Information about the installed driver if found and valid.
	InstalledDriver *OracleOCIDriverInfo `json:"installedDriver,omitempty"`

	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CheckOCIDriverTaskOutput.
func (c CheckOCIDriverTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "installedDriver", c.InstalledDriver)
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

// CheckOCIDriverTaskProperties - Properties for the task that checks for OCI drivers.
type CheckOCIDriverTaskProperties struct {
	ProjectTaskProperties
	// Input for the service task to check for OCI drivers.
	Input *CheckOCIDriverTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*CheckOCIDriverTaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type CheckOCIDriverTaskProperties.
func (c CheckOCIDriverTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ProjectTaskProperties.marshalInternal(objectMap, "Service.Check.OCI")
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CheckOCIDriverTaskProperties.
func (c *CheckOCIDriverTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// CommandPropertiesClassification provides polymorphic access to related types.
// Call the interface's GetCommandProperties() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *CommandProperties, *MigrateMISyncCompleteCommandProperties, *MigrateSyncCompleteCommandProperties, *MongoDbCancelCommand,
// - *MongoDbFinishCommand, *MongoDbRestartCommand
type CommandPropertiesClassification interface {
	// GetCommandProperties returns the CommandProperties content of the underlying type.
	GetCommandProperties() *CommandProperties
}

// CommandProperties - Base class for all types of DMS command properties. If command is not supported by current client, this object is returned.
type CommandProperties struct {
	// REQUIRED; Command type.
	CommandType *string `json:"commandType,omitempty"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; The state of the command. This is ignored if submitted.
	State *CommandState `json:"state,omitempty" azure:"ro"`
}

// GetCommandProperties implements the CommandPropertiesClassification interface for type CommandProperties.
func (c *CommandProperties) GetCommandProperties() *CommandProperties { return c }

// UnmarshalJSON implements the json.Unmarshaller interface for type CommandProperties.
func (c *CommandProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return c.unmarshalInternal(rawMsg)
}

func (c CommandProperties) marshalInternal(objectMap map[string]interface{}, discValue string) {
	c.CommandType = &discValue
	objectMap["commandType"] = c.CommandType
	populate(objectMap, "errors", c.Errors)
	populate(objectMap, "state", c.State)
}

func (c *CommandProperties) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commandType":
			err = unpopulate(val, &c.CommandType)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &c.Errors)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &c.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectToMongoDbTaskProperties - Properties for the task that validates the connection to and provides information about a MongoDB server
type ConnectToMongoDbTaskProperties struct {
	ProjectTaskProperties
	// Describes a connection to a MongoDB data source
	Input *MongoDbConnectionInfo `json:"input,omitempty"`

	// READ-ONLY; An array containing a single MongoDbClusterInfo object
	Output []*MongoDbClusterInfo `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToMongoDbTaskProperties.
func (c ConnectToMongoDbTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ProjectTaskProperties.marshalInternal(objectMap, "Connect.MongoDb")
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToMongoDbTaskProperties.
func (c *ConnectToMongoDbTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ConnectToSourceMySQLTaskInput - Input for the task that validates MySQL database connection
type ConnectToSourceMySQLTaskInput struct {
	// REQUIRED; Information for connecting to MySQL source
	SourceConnectionInfo *MySQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// Permission group for validations
	CheckPermissionsGroup *ServerLevelPermissionsGroup `json:"checkPermissionsGroup,omitempty"`

	// Flag for whether or not the migration is offline
	IsOfflineMigration *bool `json:"isOfflineMigration,omitempty"`

	// Target Platform for the migration
	TargetPlatform *MySQLTargetPlatformType `json:"targetPlatform,omitempty"`
}

// ConnectToSourceMySQLTaskProperties - Properties for the task that validates MySQL database connection
type ConnectToSourceMySQLTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *ConnectToSourceMySQLTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ConnectToSourceNonSQLTaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourceMySQLTaskProperties.
func (c ConnectToSourceMySQLTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ProjectTaskProperties.marshalInternal(objectMap, "ConnectToSource.MySql")
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToSourceMySQLTaskProperties.
func (c *ConnectToSourceMySQLTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ConnectToSourceNonSQLTaskOutput - Output for connect to MySQL type source
type ConnectToSourceNonSQLTaskOutput struct {
	// READ-ONLY; List of databases on the server
	Databases []*string `json:"databases,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Server properties
	ServerProperties *ServerProperties `json:"serverProperties,omitempty" azure:"ro"`

	// READ-ONLY; Server brand version
	SourceServerBrandVersion *string `json:"sourceServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors associated with the task
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourceNonSQLTaskOutput.
func (c ConnectToSourceNonSQLTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databases", c.Databases)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "serverProperties", c.ServerProperties)
	populate(objectMap, "sourceServerBrandVersion", c.SourceServerBrandVersion)
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

// ConnectToSourceOracleSyncTaskInput - Input for the task that validates Oracle database connection
type ConnectToSourceOracleSyncTaskInput struct {
	// REQUIRED; Information for connecting to Oracle source
	SourceConnectionInfo *OracleConnectionInfo `json:"sourceConnectionInfo,omitempty"`
}

// ConnectToSourceOracleSyncTaskOutput - Output for the task that validates Oracle database connection
type ConnectToSourceOracleSyncTaskOutput struct {
	// READ-ONLY; List of schemas on source server
	Databases []*string `json:"databases,omitempty" azure:"ro"`

	// READ-ONLY; Source server brand version
	SourceServerBrandVersion *string `json:"sourceServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Version of the source server
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors associated with the task
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourceOracleSyncTaskOutput.
func (c ConnectToSourceOracleSyncTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databases", c.Databases)
	populate(objectMap, "sourceServerBrandVersion", c.SourceServerBrandVersion)
	populate(objectMap, "sourceServerVersion", c.SourceServerVersion)
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

// ConnectToSourceOracleSyncTaskProperties - Properties for the task that validates Oracle database connection
type ConnectToSourceOracleSyncTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *ConnectToSourceOracleSyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ConnectToSourceOracleSyncTaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourceOracleSyncTaskProperties.
func (c ConnectToSourceOracleSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ProjectTaskProperties.marshalInternal(objectMap, "ConnectToSource.Oracle.Sync")
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToSourceOracleSyncTaskProperties.
func (c *ConnectToSourceOracleSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ConnectToSourcePostgreSQLSyncTaskInput - Input for the task that validates connection to PostgreSQL and source server requirements
type ConnectToSourcePostgreSQLSyncTaskInput struct {
	// REQUIRED; Connection information for source PostgreSQL server
	SourceConnectionInfo *PostgreSQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`
}

// ConnectToSourcePostgreSQLSyncTaskOutput - Output for the task that validates connection to PostgreSQL and source server requirements
type ConnectToSourcePostgreSQLSyncTaskOutput struct {
	// READ-ONLY; List of databases on source server
	Databases []*string `json:"databases,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Source server brand version
	SourceServerBrandVersion *string `json:"sourceServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Version of the source server
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors associated with the task
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourcePostgreSQLSyncTaskOutput.
func (c ConnectToSourcePostgreSQLSyncTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databases", c.Databases)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "sourceServerBrandVersion", c.SourceServerBrandVersion)
	populate(objectMap, "sourceServerVersion", c.SourceServerVersion)
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

// ConnectToSourcePostgreSQLSyncTaskProperties - Properties for the task that validates connection to PostgreSQL server and source server requirements for
// online migration
type ConnectToSourcePostgreSQLSyncTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *ConnectToSourcePostgreSQLSyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ConnectToSourcePostgreSQLSyncTaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourcePostgreSQLSyncTaskProperties.
func (c ConnectToSourcePostgreSQLSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ProjectTaskProperties.marshalInternal(objectMap, "ConnectToSource.PostgreSql.Sync")
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToSourcePostgreSQLSyncTaskProperties.
func (c *ConnectToSourcePostgreSQLSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ConnectToSourceSQLServerSyncTaskProperties - Properties for the task that validates connection to SQL Server and source server requirements for online
// migration
type ConnectToSourceSQLServerSyncTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *ConnectToSourceSQLServerTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []ConnectToSourceSQLServerTaskOutputClassification `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourceSQLServerSyncTaskProperties.
func (c ConnectToSourceSQLServerSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ProjectTaskProperties.marshalInternal(objectMap, "ConnectToSource.SqlServer.Sync")
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToSourceSQLServerSyncTaskProperties.
func (c *ConnectToSourceSQLServerSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			c.Output, err = unmarshalConnectToSourceSQLServerTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ConnectToSourceSQLServerTaskInput - Input for the task that validates connection to SQL Server and also validates source server requirements
type ConnectToSourceSQLServerTaskInput struct {
	// REQUIRED; Connection information for Source SQL Server
	SourceConnectionInfo *SQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// Permission group for validations
	CheckPermissionsGroup *ServerLevelPermissionsGroup `json:"checkPermissionsGroup,omitempty"`

	// Flag for whether to collect agent jobs from source server.
	CollectAgentJobs *bool `json:"collectAgentJobs,omitempty"`

	// Flag for whether to collect databases from source server.
	CollectDatabases *bool `json:"collectDatabases,omitempty"`

	// Flag for whether to collect logins from source server.
	CollectLogins *bool `json:"collectLogins,omitempty"`

	// Flag for whether to collect TDE Certificate names from source server.
	CollectTdeCertificateInfo *bool `json:"collectTdeCertificateInfo,omitempty"`

	// Flag for whether to validate SSIS catalog is reachable on the source server.
	ValidateSsisCatalogOnly *bool `json:"validateSsisCatalogOnly,omitempty"`
}

// ConnectToSourceSQLServerTaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetConnectToSourceSQLServerTaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ConnectToSourceSQLServerTaskOutput, *ConnectToSourceSqlServerTaskOutputAgentJobLevel, *ConnectToSourceSqlServerTaskOutputDatabaseLevel,
// - *ConnectToSourceSqlServerTaskOutputLoginLevel, *ConnectToSourceSqlServerTaskOutputTaskLevel
type ConnectToSourceSQLServerTaskOutputClassification interface {
	// GetConnectToSourceSQLServerTaskOutput returns the ConnectToSourceSQLServerTaskOutput content of the underlying type.
	GetConnectToSourceSQLServerTaskOutput() *ConnectToSourceSQLServerTaskOutput
}

// ConnectToSourceSQLServerTaskOutput - Output for the task that validates connection to SQL Server and also validates source server requirements
type ConnectToSourceSQLServerTaskOutput struct {
	// REQUIRED; Type of result - database level or task level
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetConnectToSourceSQLServerTaskOutput implements the ConnectToSourceSQLServerTaskOutputClassification interface for type ConnectToSourceSQLServerTaskOutput.
func (c *ConnectToSourceSQLServerTaskOutput) GetConnectToSourceSQLServerTaskOutput() *ConnectToSourceSQLServerTaskOutput {
	return c
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToSourceSQLServerTaskOutput.
func (c *ConnectToSourceSQLServerTaskOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return c.unmarshalInternal(rawMsg)
}

func (c ConnectToSourceSQLServerTaskOutput) marshalInternal(objectMap map[string]interface{}, discValue string) {
	populate(objectMap, "id", c.ID)
	c.ResultType = &discValue
	objectMap["resultType"] = c.ResultType
}

func (c *ConnectToSourceSQLServerTaskOutput) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &c.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &c.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ConnectToSourceSQLServerTaskOutputAgentJobLevel - Agent Job level output for the task that validates connection to SQL Server and also validates source
// server requirements
type ConnectToSourceSQLServerTaskOutputAgentJobLevel struct {
	ConnectToSourceSQLServerTaskOutput
	// READ-ONLY; The state of the original Agent Job.
	IsEnabled *bool `json:"isEnabled,omitempty" azure:"ro"`

	// READ-ONLY; The type of Agent Job.
	JobCategory *string `json:"jobCategory,omitempty" azure:"ro"`

	// READ-ONLY; The owner of the Agent Job
	JobOwner *string `json:"jobOwner,omitempty" azure:"ro"`

	// READ-ONLY; UTC Date and time when the Agent Job was last executed.
	LastExecutedOn *time.Time `json:"lastExecutedOn,omitempty" azure:"ro"`

	// READ-ONLY; Information about eligibility of agent job for migration.
	MigrationEligibility *MigrationEligibilityInfo `json:"migrationEligibility,omitempty" azure:"ro"`

	// READ-ONLY; Agent Job name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourceSQLServerTaskOutputAgentJobLevel.
func (c ConnectToSourceSQLServerTaskOutputAgentJobLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ConnectToSourceSQLServerTaskOutput.marshalInternal(objectMap, "AgentJobLevelOutput")
	populate(objectMap, "isEnabled", c.IsEnabled)
	populate(objectMap, "jobCategory", c.JobCategory)
	populate(objectMap, "jobOwner", c.JobOwner)
	populate(objectMap, "lastExecutedOn", (*timeRFC3339)(c.LastExecutedOn))
	populate(objectMap, "migrationEligibility", c.MigrationEligibility)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToSourceSQLServerTaskOutputAgentJobLevel.
func (c *ConnectToSourceSQLServerTaskOutputAgentJobLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isEnabled":
			err = unpopulate(val, &c.IsEnabled)
			delete(rawMsg, key)
		case "jobCategory":
			err = unpopulate(val, &c.JobCategory)
			delete(rawMsg, key)
		case "jobOwner":
			err = unpopulate(val, &c.JobOwner)
			delete(rawMsg, key)
		case "lastExecutedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			c.LastExecutedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "migrationEligibility":
			err = unpopulate(val, &c.MigrationEligibility)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &c.Name)
			delete(rawMsg, key)
		case "validationErrors":
			err = unpopulate(val, &c.ValidationErrors)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ConnectToSourceSQLServerTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ConnectToSourceSQLServerTaskOutputDatabaseLevel - Database level output for the task that validates connection to SQL Server and also validates source
// server requirements
type ConnectToSourceSQLServerTaskOutputDatabaseLevel struct {
	ConnectToSourceSQLServerTaskOutput
	// READ-ONLY; SQL Server compatibility level of database
	CompatibilityLevel *DatabaseCompatLevel `json:"compatibilityLevel,omitempty" azure:"ro"`

	// READ-ONLY; The list of database files
	DatabaseFiles []*DatabaseFileInfo `json:"databaseFiles,omitempty" azure:"ro"`

	// READ-ONLY; State of the database
	DatabaseState *DatabaseState `json:"databaseState,omitempty" azure:"ro"`

	// READ-ONLY; Database name
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Size of the file in megabytes
	SizeMB *float64 `json:"sizeMB,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourceSQLServerTaskOutputDatabaseLevel.
func (c ConnectToSourceSQLServerTaskOutputDatabaseLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ConnectToSourceSQLServerTaskOutput.marshalInternal(objectMap, "DatabaseLevelOutput")
	populate(objectMap, "compatibilityLevel", c.CompatibilityLevel)
	populate(objectMap, "databaseFiles", c.DatabaseFiles)
	populate(objectMap, "databaseState", c.DatabaseState)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "sizeMB", c.SizeMB)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToSourceSQLServerTaskOutputDatabaseLevel.
func (c *ConnectToSourceSQLServerTaskOutputDatabaseLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "compatibilityLevel":
			err = unpopulate(val, &c.CompatibilityLevel)
			delete(rawMsg, key)
		case "databaseFiles":
			err = unpopulate(val, &c.DatabaseFiles)
			delete(rawMsg, key)
		case "databaseState":
			err = unpopulate(val, &c.DatabaseState)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &c.Name)
			delete(rawMsg, key)
		case "sizeMB":
			err = unpopulate(val, &c.SizeMB)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ConnectToSourceSQLServerTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ConnectToSourceSQLServerTaskOutputLoginLevel - Login level output for the task that validates connection to SQL Server and also validates source server
// requirements
type ConnectToSourceSQLServerTaskOutputLoginLevel struct {
	ConnectToSourceSQLServerTaskOutput
	// READ-ONLY; The default database for the login.
	DefaultDatabase *string `json:"defaultDatabase,omitempty" azure:"ro"`

	// READ-ONLY; The state of the login.
	IsEnabled *bool `json:"isEnabled,omitempty" azure:"ro"`

	// READ-ONLY; The type of login.
	LoginType *LoginType `json:"loginType,omitempty" azure:"ro"`

	// READ-ONLY; Information about eligibility of login for migration.
	MigrationEligibility *MigrationEligibilityInfo `json:"migrationEligibility,omitempty" azure:"ro"`

	// READ-ONLY; Login name.
	Name *string `json:"name,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourceSQLServerTaskOutputLoginLevel.
func (c ConnectToSourceSQLServerTaskOutputLoginLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ConnectToSourceSQLServerTaskOutput.marshalInternal(objectMap, "LoginLevelOutput")
	populate(objectMap, "defaultDatabase", c.DefaultDatabase)
	populate(objectMap, "isEnabled", c.IsEnabled)
	populate(objectMap, "loginType", c.LoginType)
	populate(objectMap, "migrationEligibility", c.MigrationEligibility)
	populate(objectMap, "name", c.Name)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToSourceSQLServerTaskOutputLoginLevel.
func (c *ConnectToSourceSQLServerTaskOutputLoginLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "defaultDatabase":
			err = unpopulate(val, &c.DefaultDatabase)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, &c.IsEnabled)
			delete(rawMsg, key)
		case "loginType":
			err = unpopulate(val, &c.LoginType)
			delete(rawMsg, key)
		case "migrationEligibility":
			err = unpopulate(val, &c.MigrationEligibility)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &c.Name)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ConnectToSourceSQLServerTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ConnectToSourceSQLServerTaskOutputTaskLevel - Task level output for the task that validates connection to SQL Server and also validates source server
// requirements
type ConnectToSourceSQLServerTaskOutputTaskLevel struct {
	ConnectToSourceSQLServerTaskOutput
	// READ-ONLY; Source agent jobs as a map from agent job name to id.
	AgentJobs *string `json:"agentJobs,omitempty" azure:"ro"`

	// READ-ONLY; Mapping from database name to TDE certificate name, if applicable
	DatabaseTdeCertificateMapping *string `json:"databaseTdeCertificateMapping,omitempty" azure:"ro"`

	// READ-ONLY; Source databases as a map from database name to database id
	Databases *string `json:"databases,omitempty" azure:"ro"`

	// READ-ONLY; Source logins as a map from login name to login id.
	Logins *string `json:"logins,omitempty" azure:"ro"`

	// READ-ONLY; Source server brand version
	SourceServerBrandVersion *string `json:"sourceServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Source server version
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourceSQLServerTaskOutputTaskLevel.
func (c ConnectToSourceSQLServerTaskOutputTaskLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ConnectToSourceSQLServerTaskOutput.marshalInternal(objectMap, "TaskLevelOutput")
	populate(objectMap, "agentJobs", c.AgentJobs)
	populate(objectMap, "databaseTdeCertificateMapping", c.DatabaseTdeCertificateMapping)
	populate(objectMap, "databases", c.Databases)
	populate(objectMap, "logins", c.Logins)
	populate(objectMap, "sourceServerBrandVersion", c.SourceServerBrandVersion)
	populate(objectMap, "sourceServerVersion", c.SourceServerVersion)
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToSourceSQLServerTaskOutputTaskLevel.
func (c *ConnectToSourceSQLServerTaskOutputTaskLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentJobs":
			err = unpopulate(val, &c.AgentJobs)
			delete(rawMsg, key)
		case "databaseTdeCertificateMapping":
			err = unpopulate(val, &c.DatabaseTdeCertificateMapping)
			delete(rawMsg, key)
		case "databases":
			err = unpopulate(val, &c.Databases)
			delete(rawMsg, key)
		case "logins":
			err = unpopulate(val, &c.Logins)
			delete(rawMsg, key)
		case "sourceServerBrandVersion":
			err = unpopulate(val, &c.SourceServerBrandVersion)
			delete(rawMsg, key)
		case "sourceServerVersion":
			err = unpopulate(val, &c.SourceServerVersion)
			delete(rawMsg, key)
		case "validationErrors":
			err = unpopulate(val, &c.ValidationErrors)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ConnectToSourceSQLServerTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ConnectToSourceSQLServerTaskProperties - Properties for the task that validates connection to SQL Server and also validates source server requirements
type ConnectToSourceSQLServerTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *ConnectToSourceSQLServerTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []ConnectToSourceSQLServerTaskOutputClassification `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToSourceSQLServerTaskProperties.
func (c ConnectToSourceSQLServerTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ProjectTaskProperties.marshalInternal(objectMap, "ConnectToSource.SqlServer")
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToSourceSQLServerTaskProperties.
func (c *ConnectToSourceSQLServerTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			c.Output, err = unmarshalConnectToSourceSQLServerTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ConnectToTargetAzureDbForMySQLTaskInput - Input for the task that validates connection to Azure Database for MySQL and target server requirements
type ConnectToTargetAzureDbForMySQLTaskInput struct {
	// REQUIRED; Connection information for source MySQL server
	SourceConnectionInfo *MySQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Connection information for target Azure Database for MySQL server
	TargetConnectionInfo *MySQLConnectionInfo `json:"targetConnectionInfo,omitempty"`

	// Flag for whether or not the migration is offline
	IsOfflineMigration *bool `json:"isOfflineMigration,omitempty"`
}

// ConnectToTargetAzureDbForMySQLTaskOutput - Output for the task that validates connection to Azure Database for MySQL and target server requirements
type ConnectToTargetAzureDbForMySQLTaskOutput struct {
	// READ-ONLY; List of databases on target server
	Databases []*string `json:"databases,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Version of the target server
	ServerVersion *string `json:"serverVersion,omitempty" azure:"ro"`

	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors associated with the task
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetAzureDbForMySQLTaskOutput.
func (c ConnectToTargetAzureDbForMySQLTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databases", c.Databases)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "serverVersion", c.ServerVersion)
	populate(objectMap, "targetServerBrandVersion", c.TargetServerBrandVersion)
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

// ConnectToTargetAzureDbForMySQLTaskProperties - Properties for the task that validates connection to Azure Database for MySQL and target server requirements
type ConnectToTargetAzureDbForMySQLTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *ConnectToTargetAzureDbForMySQLTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ConnectToTargetAzureDbForMySQLTaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetAzureDbForMySQLTaskProperties.
func (c ConnectToTargetAzureDbForMySQLTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ProjectTaskProperties.marshalInternal(objectMap, "ConnectToTarget.AzureDbForMySql")
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToTargetAzureDbForMySQLTaskProperties.
func (c *ConnectToTargetAzureDbForMySQLTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ConnectToTargetAzureDbForPostgreSQLSyncTaskInput - Input for the task that validates connection to Azure Database for PostgreSQL and target server requirements
type ConnectToTargetAzureDbForPostgreSQLSyncTaskInput struct {
	// REQUIRED; Connection information for source PostgreSQL server
	SourceConnectionInfo *PostgreSQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Connection information for target Azure Database for PostgreSQL server
	TargetConnectionInfo *PostgreSQLConnectionInfo `json:"targetConnectionInfo,omitempty"`
}

// ConnectToTargetAzureDbForPostgreSQLSyncTaskOutput - Output for the task that validates connection to Azure Database for PostgreSQL and target server
// requirements
type ConnectToTargetAzureDbForPostgreSQLSyncTaskOutput struct {
	// READ-ONLY; List of databases on target server
	Databases []*string `json:"databases,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Version of the target server
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors associated with the task
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetAzureDbForPostgreSQLSyncTaskOutput.
func (c ConnectToTargetAzureDbForPostgreSQLSyncTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databases", c.Databases)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "targetServerBrandVersion", c.TargetServerBrandVersion)
	populate(objectMap, "targetServerVersion", c.TargetServerVersion)
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

// ConnectToTargetAzureDbForPostgreSQLSyncTaskProperties - Properties for the task that validates connection to Azure Database For PostgreSQL server and
// target server requirements for online migration
type ConnectToTargetAzureDbForPostgreSQLSyncTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *ConnectToTargetAzureDbForPostgreSQLSyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ConnectToTargetAzureDbForPostgreSQLSyncTaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetAzureDbForPostgreSQLSyncTaskProperties.
func (c ConnectToTargetAzureDbForPostgreSQLSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ProjectTaskProperties.marshalInternal(objectMap, "ConnectToTarget.AzureDbForPostgreSql.Sync")
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToTargetAzureDbForPostgreSQLSyncTaskProperties.
func (c *ConnectToTargetAzureDbForPostgreSQLSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskInput - Input for the task that validates connection to Azure Database for PostgreSQL and target server
// requirements for Oracle source.
type ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskInput struct {
	// REQUIRED; Connection information for target Azure Database for PostgreSQL server
	TargetConnectionInfo *PostgreSQLConnectionInfo `json:"targetConnectionInfo,omitempty"`
}

// ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskOutput - Output for the task that validates connection to Azure Database for PostgreSQL and target server
// requirements for Oracle source.
type ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskOutput struct {
	// Mapping of schemas per database
	DatabaseSchemaMap []*ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskOutputDatabaseSchemaMapItem `json:"databaseSchemaMap,omitempty"`

	// READ-ONLY; List of databases on target server
	Databases []*string `json:"databases,omitempty" azure:"ro"`

	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Version of the target server
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors associated with the task
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskOutput.
func (c ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databaseSchemaMap", c.DatabaseSchemaMap)
	populate(objectMap, "databases", c.Databases)
	populate(objectMap, "targetServerBrandVersion", c.TargetServerBrandVersion)
	populate(objectMap, "targetServerVersion", c.TargetServerVersion)
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

type ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskOutputDatabaseSchemaMapItem struct {
	Database *string   `json:"database,omitempty"`
	Schemas  []*string `json:"schemas,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskOutputDatabaseSchemaMapItem.
func (c ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskOutputDatabaseSchemaMapItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "database", c.Database)
	populate(objectMap, "schemas", c.Schemas)
	return json.Marshal(objectMap)
}

// ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskProperties - Properties for the task that validates connection to Azure Database For PostgreSQL server
// and target server requirements for online migration for Oracle source.
type ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskProperties.
func (c ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ProjectTaskProperties.marshalInternal(objectMap, "ConnectToTarget.Oracle.AzureDbForPostgreSql.Sync")
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskProperties.
func (c *ConnectToTargetOracleAzureDbForPostgreSQLSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ConnectToTargetSQLDbSyncTaskInput - Input for the task that validates connection to Azure SQL DB and target server requirements
type ConnectToTargetSQLDbSyncTaskInput struct {
	// REQUIRED; Connection information for source SQL Server
	SourceConnectionInfo *SQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Connection information for target SQL DB
	TargetConnectionInfo *SQLConnectionInfo `json:"targetConnectionInfo,omitempty"`
}

// ConnectToTargetSQLDbSyncTaskProperties - Properties for the task that validates connection to SQL DB and target server requirements for online migration
type ConnectToTargetSQLDbSyncTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *ConnectToTargetSQLDbSyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ConnectToTargetSQLDbTaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetSQLDbSyncTaskProperties.
func (c ConnectToTargetSQLDbSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ProjectTaskProperties.marshalInternal(objectMap, "ConnectToTarget.SqlDb.Sync")
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToTargetSQLDbSyncTaskProperties.
func (c *ConnectToTargetSQLDbSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ConnectToTargetSQLDbTaskInput - Input for the task that validates connection to SQL DB and target server requirements
type ConnectToTargetSQLDbTaskInput struct {
	// REQUIRED; Connection information for target SQL DB
	TargetConnectionInfo *SQLConnectionInfo `json:"targetConnectionInfo,omitempty"`
}

// ConnectToTargetSQLDbTaskOutput - Output for the task that validates connection to SQL DB and target server requirements
type ConnectToTargetSQLDbTaskOutput struct {
	// READ-ONLY; Source databases as a map from database name to database id
	Databases *string `json:"databases,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Version of the target server
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`
}

// ConnectToTargetSQLDbTaskProperties - Properties for the task that validates connection to SQL DB and target server requirements
type ConnectToTargetSQLDbTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *ConnectToTargetSQLDbTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ConnectToTargetSQLDbTaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetSQLDbTaskProperties.
func (c ConnectToTargetSQLDbTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ProjectTaskProperties.marshalInternal(objectMap, "ConnectToTarget.SqlDb")
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToTargetSQLDbTaskProperties.
func (c *ConnectToTargetSQLDbTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ConnectToTargetSQLMISyncTaskInput - Input for the task that validates connection to Azure SQL Database Managed Instance online scenario.
type ConnectToTargetSQLMISyncTaskInput struct {
	// REQUIRED; Azure Active Directory Application the DMS instance will use to connect to the target instance of Azure SQL Database Managed Instance and the
	// Azure Storage Account
	AzureApp *AzureActiveDirectoryApp `json:"azureApp,omitempty"`

	// REQUIRED; Connection information for Azure SQL Database Managed Instance
	TargetConnectionInfo *MiSQLConnectionInfo `json:"targetConnectionInfo,omitempty"`
}

// ConnectToTargetSQLMISyncTaskOutput - Output for the task that validates connection to Azure SQL Database Managed Instance.
type ConnectToTargetSQLMISyncTaskOutput struct {
	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetSQLMISyncTaskOutput.
func (c ConnectToTargetSQLMISyncTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "targetServerBrandVersion", c.TargetServerBrandVersion)
	populate(objectMap, "targetServerVersion", c.TargetServerVersion)
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

// ConnectToTargetSQLMISyncTaskProperties - Properties for the task that validates connection to Azure SQL Database Managed Instance
type ConnectToTargetSQLMISyncTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *ConnectToTargetSQLMISyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ConnectToTargetSQLMISyncTaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetSQLMISyncTaskProperties.
func (c ConnectToTargetSQLMISyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ProjectTaskProperties.marshalInternal(objectMap, "ConnectToTarget.AzureSqlDbMI.Sync.LRS")
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToTargetSQLMISyncTaskProperties.
func (c *ConnectToTargetSQLMISyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ConnectToTargetSQLMITaskInput - Input for the task that validates connection to Azure SQL Database Managed Instance.
type ConnectToTargetSQLMITaskInput struct {
	// REQUIRED; Connection information for target SQL Server
	TargetConnectionInfo *SQLConnectionInfo `json:"targetConnectionInfo,omitempty"`

	// Flag for whether to collect agent jobs from target SQL MI server.
	CollectAgentJobs *bool `json:"collectAgentJobs,omitempty"`

	// Flag for whether to collect logins from target SQL MI server.
	CollectLogins *bool `json:"collectLogins,omitempty"`

	// Flag for whether to validate SSIS catalog is reachable on the target SQL MI server.
	ValidateSsisCatalogOnly *bool `json:"validateSsisCatalogOnly,omitempty"`
}

// ConnectToTargetSQLMITaskOutput - Output for the task that validates connection to Azure SQL Database Managed Instance.
type ConnectToTargetSQLMITaskOutput struct {
	// READ-ONLY; List of agent jobs on the target server.
	AgentJobs []*string `json:"agentJobs,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; List of logins on the target server.
	Logins []*string `json:"logins,omitempty" azure:"ro"`

	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetSQLMITaskOutput.
func (c ConnectToTargetSQLMITaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentJobs", c.AgentJobs)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "logins", c.Logins)
	populate(objectMap, "targetServerBrandVersion", c.TargetServerBrandVersion)
	populate(objectMap, "targetServerVersion", c.TargetServerVersion)
	populate(objectMap, "validationErrors", c.ValidationErrors)
	return json.Marshal(objectMap)
}

// ConnectToTargetSQLMITaskProperties - Properties for the task that validates connection to Azure SQL Database Managed Instance
type ConnectToTargetSQLMITaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *ConnectToTargetSQLMITaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ConnectToTargetSQLMITaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ConnectToTargetSQLMITaskProperties.
func (c ConnectToTargetSQLMITaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.ProjectTaskProperties.marshalInternal(objectMap, "ConnectToTarget.AzureSqlDbMI")
	populate(objectMap, "input", c.Input)
	populate(objectMap, "output", c.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectToTargetSQLMITaskProperties.
func (c *ConnectToTargetSQLMITaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &c.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &c.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ConnectionInfoClassification provides polymorphic access to related types.
// Call the interface's GetConnectionInfo() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *ConnectionInfo, *MiSqlConnectionInfo, *MongoDbConnectionInfo, *MySqlConnectionInfo, *OracleConnectionInfo, *PostgreSqlConnectionInfo,
// - *SqlConnectionInfo
type ConnectionInfoClassification interface {
	// GetConnectionInfo returns the ConnectionInfo content of the underlying type.
	GetConnectionInfo() *ConnectionInfo
}

// ConnectionInfo - Defines the connection properties of a server
type ConnectionInfo struct {
	// REQUIRED; Type of connection info
	Type *string `json:"type,omitempty"`

	// Password credential.
	Password *string `json:"password,omitempty"`

	// User name
	UserName *string `json:"userName,omitempty"`
}

// GetConnectionInfo implements the ConnectionInfoClassification interface for type ConnectionInfo.
func (c *ConnectionInfo) GetConnectionInfo() *ConnectionInfo { return c }

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionInfo.
func (c *ConnectionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return c.unmarshalInternal(rawMsg)
}

func (c ConnectionInfo) marshalInternal(objectMap map[string]interface{}, discValue string) {
	populate(objectMap, "password", c.Password)
	c.Type = &discValue
	objectMap["type"] = c.Type
	populate(objectMap, "userName", c.UserName)
}

func (c *ConnectionInfo) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "password":
			err = unpopulate(val, &c.Password)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &c.Type)
			delete(rawMsg, key)
		case "userName":
			err = unpopulate(val, &c.UserName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DataIntegrityValidationResult - Results for checksum based Data Integrity validation results
type DataIntegrityValidationResult struct {
	// List of failed table names of source and target pair
	FailedObjects map[string]*string `json:"failedObjects,omitempty"`

	// List of errors that happened while performing data integrity validation
	ValidationErrors *ValidationError `json:"validationErrors,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataIntegrityValidationResult.
func (d DataIntegrityValidationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "failedObjects", d.FailedObjects)
	populate(objectMap, "validationErrors", d.ValidationErrors)
	return json.Marshal(objectMap)
}

// DataItemMigrationSummaryResult - Basic summary of a data item migration
type DataItemMigrationSummaryResult struct {
	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Wildcard string prefix to use for querying all errors of the item
	ErrorPrefix *string `json:"errorPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Number of successfully completed items
	ItemsCompletedCount *int64 `json:"itemsCompletedCount,omitempty" azure:"ro"`

	// READ-ONLY; Number of items
	ItemsCount *int64 `json:"itemsCount,omitempty" azure:"ro"`

	// READ-ONLY; Name of the item
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Wildcard string prefix to use for querying all sub-tem results of the item
	ResultPrefix *string `json:"resultPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Status message
	StatusMessage *string `json:"statusMessage,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataItemMigrationSummaryResult.
func (d DataItemMigrationSummaryResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataItemMigrationSummaryResult.
func (d *DataItemMigrationSummaryResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return d.unmarshalInternal(rawMsg)
}

func (d DataItemMigrationSummaryResult) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "endedOn", (*timeRFC3339)(d.EndedOn))
	populate(objectMap, "errorPrefix", d.ErrorPrefix)
	populate(objectMap, "itemsCompletedCount", d.ItemsCompletedCount)
	populate(objectMap, "itemsCount", d.ItemsCount)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "resultPrefix", d.ResultPrefix)
	populate(objectMap, "startedOn", (*timeRFC3339)(d.StartedOn))
	populate(objectMap, "state", d.State)
	populate(objectMap, "statusMessage", d.StatusMessage)
}

func (d *DataItemMigrationSummaryResult) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			d.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "errorPrefix":
			err = unpopulate(val, &d.ErrorPrefix)
			delete(rawMsg, key)
		case "itemsCompletedCount":
			err = unpopulate(val, &d.ItemsCompletedCount)
			delete(rawMsg, key)
		case "itemsCount":
			err = unpopulate(val, &d.ItemsCount)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &d.Name)
			delete(rawMsg, key)
		case "resultPrefix":
			err = unpopulate(val, &d.ResultPrefix)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			d.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &d.State)
			delete(rawMsg, key)
		case "statusMessage":
			err = unpopulate(val, &d.StatusMessage)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DataMigrationError - Migration Task errors
type DataMigrationError struct {
	// Error type
	Type *ErrorType `json:"type,omitempty"`

	// READ-ONLY; Error description
	Message *string `json:"message,omitempty" azure:"ro"`
}

// DataMigrationProjectMetadata - Common metadata for migration projects
type DataMigrationProjectMetadata struct {
	// READ-ONLY; List of tables selected for migration
	SelectedMigrationTables []*MigrationTableMetadata `json:"selectedMigrationTables,omitempty" azure:"ro"`

	// READ-ONLY; Source server name
	SourceServerName *string `json:"sourceServerName,omitempty" azure:"ro"`

	// READ-ONLY; Source server port number
	SourceServerPort *string `json:"sourceServerPort,omitempty" azure:"ro"`

	// READ-ONLY; Source username
	SourceUsername *string `json:"sourceUsername,omitempty" azure:"ro"`

	// READ-ONLY; Target database name
	TargetDbName *string `json:"targetDbName,omitempty" azure:"ro"`

	// READ-ONLY; Target server name
	TargetServerName *string `json:"targetServerName,omitempty" azure:"ro"`

	// READ-ONLY; Target username
	TargetUsername *string `json:"targetUsername,omitempty" azure:"ro"`

	// READ-ONLY; Whether target connection is Windows authentication
	TargetUsingWinAuth *bool `json:"targetUsingWinAuth,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DataMigrationProjectMetadata.
func (d DataMigrationProjectMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "selectedMigrationTables", d.SelectedMigrationTables)
	populate(objectMap, "sourceServerName", d.SourceServerName)
	populate(objectMap, "sourceServerPort", d.SourceServerPort)
	populate(objectMap, "sourceUsername", d.SourceUsername)
	populate(objectMap, "targetDbName", d.TargetDbName)
	populate(objectMap, "targetServerName", d.TargetServerName)
	populate(objectMap, "targetUsername", d.TargetUsername)
	populate(objectMap, "targetUsingWinAuth", d.TargetUsingWinAuth)
	return json.Marshal(objectMap)
}

// DataMigrationService - A Database Migration Service resource
type DataMigrationService struct {
	TrackedResource
	// HTTP strong entity tag value. Ignored if submitted
	Etag *string `json:"etag,omitempty"`

	// The resource kind. Only 'vm' (the default) is supported.
	Kind *string `json:"kind,omitempty"`

	// Custom service properties
	Properties *DataMigrationServiceProperties `json:"properties,omitempty"`

	// Service SKU
	SKU *ServiceSKU `json:"sku,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataMigrationService.
func (d DataMigrationService) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.TrackedResource.marshalInternal(objectMap)
	populate(objectMap, "etag", d.Etag)
	populate(objectMap, "kind", d.Kind)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "sku", d.SKU)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DataMigrationService.
func (d *DataMigrationService) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &d.Etag)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &d.Kind)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &d.Properties)
			delete(rawMsg, key)
		case "sku":
			err = unpopulate(val, &d.SKU)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.TrackedResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DataMigrationServiceList - OData page of service objects
type DataMigrationServiceList struct {
	// URL to load the next page of services
	NextLink *string `json:"nextLink,omitempty"`

	// List of services
	Value []*DataMigrationService `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataMigrationServiceList.
func (d DataMigrationServiceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DataMigrationServiceProperties - Properties of the Database Migration Service instance
type DataMigrationServiceProperties struct {
	// REQUIRED; The ID of the Microsoft.Network/virtualNetworks/subnets resource to which the service should be joined
	VirtualSubnetID *string `json:"virtualSubnetId,omitempty"`

	// The public key of the service, used to encrypt secrets sent to the service
	PublicKey *string `json:"publicKey,omitempty"`

	// The ID of the Microsoft.Network/networkInterfaces resource which the service have
	VirtualNicID *string `json:"virtualNicId,omitempty"`

	// READ-ONLY; The resource's provisioning state
	ProvisioningState *ServiceProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// DataMigrationServiceStatusResponse - Service health status
type DataMigrationServiceStatusResponse struct {
	// The DMS instance agent version
	AgentVersion *string `json:"agentVersion,omitempty"`

	// The machine-readable status, such as 'Initializing', 'Offline', 'Online', 'Deploying', 'Deleting', 'Stopped', 'Stopping', 'Starting', 'FailedToStart',
	// 'FailedToStop' or 'Failed'
	Status *string `json:"status,omitempty"`

	// The list of supported task types
	SupportedTaskTypes []*string `json:"supportedTaskTypes,omitempty"`

	// The services virtual machine size, such as 'StandardD2v2'
	VMSize *string `json:"vmSize,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DataMigrationServiceStatusResponse.
func (d DataMigrationServiceStatusResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentVersion", d.AgentVersion)
	populate(objectMap, "status", d.Status)
	populate(objectMap, "supportedTaskTypes", d.SupportedTaskTypes)
	populate(objectMap, "vmSize", d.VMSize)
	return json.Marshal(objectMap)
}

// Database - Information about a single database
type Database struct {
	// Collation name of the database
	Collation *string `json:"collation,omitempty"`

	// SQL Server compatibility level of database
	CompatibilityLevel *DatabaseCompatLevel `json:"compatibilityLevel,omitempty"`

	// State of the database
	DatabaseState *DatabaseState `json:"databaseState,omitempty"`

	// Fully qualified name
	Fqdn *string `json:"fqdn,omitempty"`

	// Unique identifier for the database
	ID *string `json:"id,omitempty"`

	// Install id of the database
	InstallID *string `json:"installId,omitempty"`

	// Name of the database
	Name *string `json:"name,omitempty"`

	// Number of cores on the server
	ServerCoreCount *int32 `json:"serverCoreCount,omitempty"`

	// Default path of the backup folder
	ServerDefaultBackupPath *string `json:"serverDefaultBackupPath,omitempty"`

	// Default path of the data files
	ServerDefaultDataPath *string `json:"serverDefaultDataPath,omitempty"`

	// Default path of the log files
	ServerDefaultLogPath *string `json:"serverDefaultLogPath,omitempty"`

	// Edition of the server
	ServerEdition *string `json:"serverEdition,omitempty"`

	// The unique Server Id
	ServerID *string `json:"serverId,omitempty"`

	// Product level of the server (RTM, SP, CTP).
	ServerLevel *string `json:"serverLevel,omitempty"`

	// Name of the server
	ServerName *string `json:"serverName,omitempty"`

	// Version of the server
	ServerVersion *string `json:"serverVersion,omitempty"`

	// Number of cores on the server that have VISIBLE ONLINE status
	ServerVisibleOnlineCoreCount *int32 `json:"serverVisibleOnlineCoreCount,omitempty"`
}

// DatabaseBackupInfo - Information about backup files when existing backup mode is used.
type DatabaseBackupInfo struct {
	// READ-ONLY; The list of backup files for the current database.
	BackupFiles []*string `json:"backupFiles,omitempty" azure:"ro"`

	// READ-ONLY; Date and time when the backup operation finished.
	BackupFinishDate *time.Time `json:"backupFinishDate,omitempty" azure:"ro"`

	// READ-ONLY; Backup Type.
	BackupType *BackupType `json:"backupType,omitempty" azure:"ro"`

	// READ-ONLY; Database name.
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Number of files in the backup set.
	FamilyCount *int32 `json:"familyCount,omitempty" azure:"ro"`

	// READ-ONLY; Whether the backup set is compressed
	IsCompressed *bool `json:"isCompressed,omitempty" azure:"ro"`

	// READ-ONLY; Database was damaged when backed up, but the backup operation was requested to continue despite errors.
	IsDamaged *bool `json:"isDamaged,omitempty" azure:"ro"`

	// READ-ONLY; Position of current database backup in the file.
	Position *int32 `json:"position,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DatabaseBackupInfo.
func (d DatabaseBackupInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupFiles", d.BackupFiles)
	populate(objectMap, "backupFinishDate", (*timeRFC3339)(d.BackupFinishDate))
	populate(objectMap, "backupType", d.BackupType)
	populate(objectMap, "databaseName", d.DatabaseName)
	populate(objectMap, "familyCount", d.FamilyCount)
	populate(objectMap, "isCompressed", d.IsCompressed)
	populate(objectMap, "isDamaged", d.IsDamaged)
	populate(objectMap, "position", d.Position)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabaseBackupInfo.
func (d *DatabaseBackupInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupFiles":
			err = unpopulate(val, &d.BackupFiles)
			delete(rawMsg, key)
		case "backupFinishDate":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			d.BackupFinishDate = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "backupType":
			err = unpopulate(val, &d.BackupType)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &d.DatabaseName)
			delete(rawMsg, key)
		case "familyCount":
			err = unpopulate(val, &d.FamilyCount)
			delete(rawMsg, key)
		case "isCompressed":
			err = unpopulate(val, &d.IsCompressed)
			delete(rawMsg, key)
		case "isDamaged":
			err = unpopulate(val, &d.IsDamaged)
			delete(rawMsg, key)
		case "position":
			err = unpopulate(val, &d.Position)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DatabaseFileInfo - Database file specific information
type DatabaseFileInfo struct {
	// Name of the database
	DatabaseName *string `json:"databaseName,omitempty"`

	// Database file type
	FileType *DatabaseFileType `json:"fileType,omitempty"`

	// Unique identifier for database file
	ID *string `json:"id,omitempty"`

	// Logical name of the file
	LogicalName *string `json:"logicalName,omitempty"`

	// Operating-system full path of the file
	PhysicalFullName *string `json:"physicalFullName,omitempty"`

	// Suggested full path of the file for restoring
	RestoreFullName *string `json:"restoreFullName,omitempty"`

	// Size of the file in megabytes
	SizeMB *float64 `json:"sizeMB,omitempty"`
}

// DatabaseFileInput - Database file specific information for input
type DatabaseFileInput struct {
	// Database file type
	FileType *DatabaseFileType `json:"fileType,omitempty"`

	// Unique identifier for database file
	ID *string `json:"id,omitempty"`

	// Logical name of the file
	LogicalName *string `json:"logicalName,omitempty"`

	// Operating-system full path of the file
	PhysicalFullName *string `json:"physicalFullName,omitempty"`

	// Suggested full path of the file for restoring
	RestoreFullName *string `json:"restoreFullName,omitempty"`
}

// DatabaseInfo - Project Database Details
type DatabaseInfo struct {
	// REQUIRED; Name of the database
	SourceDatabaseName *string `json:"sourceDatabaseName,omitempty"`
}

// DatabaseObjectName - A representation of the name of an object in a database
type DatabaseObjectName struct {
	// Type of the object in the database
	ObjectType *ObjectType `json:"objectType,omitempty"`

	// READ-ONLY; The unescaped name of the database containing the object
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; The unescaped name of the object
	ObjectName *string `json:"objectName,omitempty" azure:"ro"`

	// READ-ONLY; The unescaped name of the schema containing the object
	SchemaName *string `json:"schemaName,omitempty" azure:"ro"`
}

// DatabaseSummaryResult - Summary of database results in the migration
type DatabaseSummaryResult struct {
	DataItemMigrationSummaryResult
	// READ-ONLY; Size of the database in megabytes
	SizeMB *float64 `json:"sizeMB,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DatabaseSummaryResult.
func (d DatabaseSummaryResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.DataItemMigrationSummaryResult.marshalInternal(objectMap)
	populate(objectMap, "sizeMB", d.SizeMB)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatabaseSummaryResult.
func (d *DatabaseSummaryResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "sizeMB":
			err = unpopulate(val, &d.SizeMB)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.DataItemMigrationSummaryResult.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DatabaseTable - Table properties
type DatabaseTable struct {
	// READ-ONLY; Indicates whether table is empty or not
	HasRows *bool `json:"hasRows,omitempty" azure:"ro"`

	// READ-ONLY; Schema-qualified name of the table
	Name *string `json:"name,omitempty" azure:"ro"`
}

// ExecutionStatistics - Description about the errors happen while performing migration validation
type ExecutionStatistics struct {
	// CPU Time in millisecond(s) for the query execution
	CPUTimeMs *float32 `json:"cpuTimeMs,omitempty"`

	// Time taken in millisecond(s) for executing the query
	ElapsedTimeMs *float32 `json:"elapsedTimeMs,omitempty"`

	// No. of query executions
	ExecutionCount *int64 `json:"executionCount,omitempty"`

	// Indicates whether the query resulted in an error
	HasErrors *bool `json:"hasErrors,omitempty"`

	// List of sql Errors
	SQLErrors []*string `json:"sqlErrors,omitempty"`

	// Dictionary of sql query execution wait types and the respective statistics
	WaitStats map[string]*WaitStatistics `json:"waitStats,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ExecutionStatistics.
func (e ExecutionStatistics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cpuTimeMs", e.CPUTimeMs)
	populate(objectMap, "elapsedTimeMs", e.ElapsedTimeMs)
	populate(objectMap, "executionCount", e.ExecutionCount)
	populate(objectMap, "hasErrors", e.HasErrors)
	populate(objectMap, "sqlErrors", e.SQLErrors)
	populate(objectMap, "waitStats", e.WaitStats)
	return json.Marshal(objectMap)
}

// FileList - OData page of files
type FileList struct {
	// URL to load the next page of files
	NextLink *string `json:"nextLink,omitempty"`

	// List of files
	Value []*ProjectFile `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FileList.
func (f FileList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", f.NextLink)
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// FileShare - File share information with Path, Username, and Password.
type FileShare struct {
	// REQUIRED; The folder path for this share.
	Path *string `json:"path,omitempty"`

	// Password credential used to connect to the share location.
	Password *string `json:"password,omitempty"`

	// User name credential to connect to the share location
	UserName *string `json:"userName,omitempty"`
}

// FileStorageInfo - File storage information.
type FileStorageInfo struct {
	// Dictionary of
	Headers map[string]*string `json:"headers,omitempty"`

	// A URI that can be used to access the file content.
	URI *string `json:"uri,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FileStorageInfo.
func (f FileStorageInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "headers", f.Headers)
	populate(objectMap, "uri", f.URI)
	return json.Marshal(objectMap)
}

// FilesCreateOrUpdateOptions contains the optional parameters for the Files.CreateOrUpdate method.
type FilesCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// FilesDeleteOptions contains the optional parameters for the Files.Delete method.
type FilesDeleteOptions struct {
	// placeholder for future optional parameters
}

// FilesGetOptions contains the optional parameters for the Files.Get method.
type FilesGetOptions struct {
	// placeholder for future optional parameters
}

// FilesListOptions contains the optional parameters for the Files.List method.
type FilesListOptions struct {
	// placeholder for future optional parameters
}

// FilesReadOptions contains the optional parameters for the Files.Read method.
type FilesReadOptions struct {
	// placeholder for future optional parameters
}

// FilesReadWriteOptions contains the optional parameters for the Files.ReadWrite method.
type FilesReadWriteOptions struct {
	// placeholder for future optional parameters
}

// FilesUpdateOptions contains the optional parameters for the Files.Update method.
type FilesUpdateOptions struct {
	// placeholder for future optional parameters
}

// GetProjectDetailsNonSQLTaskInput - Input for the task that reads configuration from project artifacts
type GetProjectDetailsNonSQLTaskInput struct {
	// REQUIRED; A URL that points to the location to access project artifacts
	ProjectLocation *string `json:"projectLocation,omitempty"`

	// REQUIRED; Name of the migration project
	ProjectName *string `json:"projectName,omitempty"`
}

// GetTdeCertificatesSQLTaskInput - Input for the task that gets TDE certificates in Base64 encoded format.
type GetTdeCertificatesSQLTaskInput struct {
	// REQUIRED; Backup file share information for file share to be used for temporarily storing files.
	BackupFileShare *FileShare `json:"backupFileShare,omitempty"`

	// REQUIRED; Connection information for SQL Server
	ConnectionInfo *SQLConnectionInfo `json:"connectionInfo,omitempty"`

	// REQUIRED; List containing certificate names and corresponding password to use for encrypting the exported certificate.
	SelectedCertificates []*SelectedCertificateInput `json:"selectedCertificates,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GetTdeCertificatesSQLTaskInput.
func (g GetTdeCertificatesSQLTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupFileShare", g.BackupFileShare)
	populate(objectMap, "connectionInfo", g.ConnectionInfo)
	populate(objectMap, "selectedCertificates", g.SelectedCertificates)
	return json.Marshal(objectMap)
}

// GetTdeCertificatesSQLTaskOutput - Output of the task that gets TDE certificates in Base64 encoded format.
type GetTdeCertificatesSQLTaskOutput struct {
	// READ-ONLY; Mapping from certificate name to base 64 encoded format.
	Base64EncodedCertificates *string `json:"base64EncodedCertificates,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GetTdeCertificatesSQLTaskOutput.
func (g GetTdeCertificatesSQLTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "base64EncodedCertificates", g.Base64EncodedCertificates)
	populate(objectMap, "validationErrors", g.ValidationErrors)
	return json.Marshal(objectMap)
}

// GetTdeCertificatesSQLTaskProperties - Properties for the task that gets TDE certificates in Base64 encoded format.
type GetTdeCertificatesSQLTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *GetTdeCertificatesSQLTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*GetTdeCertificatesSQLTaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GetTdeCertificatesSQLTaskProperties.
func (g GetTdeCertificatesSQLTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	g.ProjectTaskProperties.marshalInternal(objectMap, "GetTDECertificates.Sql")
	populate(objectMap, "input", g.Input)
	populate(objectMap, "output", g.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetTdeCertificatesSQLTaskProperties.
func (g *GetTdeCertificatesSQLTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &g.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &g.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := g.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// GetUserTablesMySQLTaskInput - Input for the task that collects user tables for the given list of databases
type GetUserTablesMySQLTaskInput struct {
	// REQUIRED; Connection information for SQL Server
	ConnectionInfo *MySQLConnectionInfo `json:"connectionInfo,omitempty"`

	// REQUIRED; List of database names to collect tables for
	SelectedDatabases []*string `json:"selectedDatabases,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesMySQLTaskInput.
func (g GetUserTablesMySQLTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "connectionInfo", g.ConnectionInfo)
	populate(objectMap, "selectedDatabases", g.SelectedDatabases)
	return json.Marshal(objectMap)
}

// GetUserTablesMySQLTaskOutput - Output of the task that collects user tables for the given list of databases
type GetUserTablesMySQLTaskOutput struct {
	// READ-ONLY; Mapping from database name to list of tables
	DatabasesToTables *string `json:"databasesToTables,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesMySQLTaskOutput.
func (g GetUserTablesMySQLTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databasesToTables", g.DatabasesToTables)
	populate(objectMap, "id", g.ID)
	populate(objectMap, "validationErrors", g.ValidationErrors)
	return json.Marshal(objectMap)
}

// GetUserTablesMySQLTaskProperties - Properties for the task that collects user tables for the given list of databases
type GetUserTablesMySQLTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *GetUserTablesMySQLTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*GetUserTablesMySQLTaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesMySQLTaskProperties.
func (g GetUserTablesMySQLTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	g.ProjectTaskProperties.marshalInternal(objectMap, "GetUserTablesMySql")
	populate(objectMap, "input", g.Input)
	populate(objectMap, "output", g.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetUserTablesMySQLTaskProperties.
func (g *GetUserTablesMySQLTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &g.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &g.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := g.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// GetUserTablesOracleTaskInput - Input for the task that gets the list of tables contained within a provided list of Oracle schemas.
type GetUserTablesOracleTaskInput struct {
	// REQUIRED; Information for connecting to Oracle source
	ConnectionInfo *OracleConnectionInfo `json:"connectionInfo,omitempty"`

	// REQUIRED; List of Oracle schemas for which to collect tables
	SelectedSchemas []*string `json:"selectedSchemas,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesOracleTaskInput.
func (g GetUserTablesOracleTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "connectionInfo", g.ConnectionInfo)
	populate(objectMap, "selectedSchemas", g.SelectedSchemas)
	return json.Marshal(objectMap)
}

// GetUserTablesOracleTaskOutput - Output for the task that gets the list of tables contained within a provided list of Oracle schemas.
type GetUserTablesOracleTaskOutput struct {
	// READ-ONLY; The schema this result is for
	SchemaName *string `json:"schemaName,omitempty" azure:"ro"`

	// READ-ONLY; List of valid tables found for this schema
	Tables []*DatabaseTable `json:"tables,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors associated with the task
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesOracleTaskOutput.
func (g GetUserTablesOracleTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "schemaName", g.SchemaName)
	populate(objectMap, "tables", g.Tables)
	populate(objectMap, "validationErrors", g.ValidationErrors)
	return json.Marshal(objectMap)
}

// GetUserTablesOracleTaskProperties - Properties for the task that collects user tables for the given list of Oracle schemas
type GetUserTablesOracleTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *GetUserTablesOracleTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*GetUserTablesOracleTaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesOracleTaskProperties.
func (g GetUserTablesOracleTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	g.ProjectTaskProperties.marshalInternal(objectMap, "GetUserTablesOracle")
	populate(objectMap, "input", g.Input)
	populate(objectMap, "output", g.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetUserTablesOracleTaskProperties.
func (g *GetUserTablesOracleTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &g.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &g.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := g.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// GetUserTablesPostgreSQLTaskInput - Input for the task that gets the list of tables for a provided list of PostgreSQL databases.
type GetUserTablesPostgreSQLTaskInput struct {
	// REQUIRED; Information for connecting to PostgreSQL source
	ConnectionInfo *PostgreSQLConnectionInfo `json:"connectionInfo,omitempty"`

	// REQUIRED; List of PostgreSQL databases for which to collect tables
	SelectedDatabases []*string `json:"selectedDatabases,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesPostgreSQLTaskInput.
func (g GetUserTablesPostgreSQLTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "connectionInfo", g.ConnectionInfo)
	populate(objectMap, "selectedDatabases", g.SelectedDatabases)
	return json.Marshal(objectMap)
}

// GetUserTablesPostgreSQLTaskOutput - Output for the task that gets the list of tables for a provided list of PostgreSQL databases.
type GetUserTablesPostgreSQLTaskOutput struct {
	// READ-ONLY; The database this result is for
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; List of valid tables found for this database
	Tables []*DatabaseTable `json:"tables,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors associated with the task
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesPostgreSQLTaskOutput.
func (g GetUserTablesPostgreSQLTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databaseName", g.DatabaseName)
	populate(objectMap, "tables", g.Tables)
	populate(objectMap, "validationErrors", g.ValidationErrors)
	return json.Marshal(objectMap)
}

// GetUserTablesPostgreSQLTaskProperties - Properties for the task that collects user tables for the given list of databases
type GetUserTablesPostgreSQLTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *GetUserTablesPostgreSQLTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*GetUserTablesPostgreSQLTaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesPostgreSQLTaskProperties.
func (g GetUserTablesPostgreSQLTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	g.ProjectTaskProperties.marshalInternal(objectMap, "GetUserTablesPostgreSql")
	populate(objectMap, "input", g.Input)
	populate(objectMap, "output", g.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetUserTablesPostgreSQLTaskProperties.
func (g *GetUserTablesPostgreSQLTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &g.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &g.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := g.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// GetUserTablesSQLSyncTaskInput - Input for the task that collects user tables for the given list of databases
type GetUserTablesSQLSyncTaskInput struct {
	// REQUIRED; List of source database names to collect tables for
	SelectedSourceDatabases []*string `json:"selectedSourceDatabases,omitempty"`

	// REQUIRED; List of target database names to collect tables for
	SelectedTargetDatabases []*string `json:"selectedTargetDatabases,omitempty"`

	// REQUIRED; Connection information for SQL Server
	SourceConnectionInfo *SQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Connection information for SQL DB
	TargetConnectionInfo *SQLConnectionInfo `json:"targetConnectionInfo,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesSQLSyncTaskInput.
func (g GetUserTablesSQLSyncTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "selectedSourceDatabases", g.SelectedSourceDatabases)
	populate(objectMap, "selectedTargetDatabases", g.SelectedTargetDatabases)
	populate(objectMap, "sourceConnectionInfo", g.SourceConnectionInfo)
	populate(objectMap, "targetConnectionInfo", g.TargetConnectionInfo)
	return json.Marshal(objectMap)
}

// GetUserTablesSQLSyncTaskOutput - Output of the task that collects user tables for the given list of databases
type GetUserTablesSQLSyncTaskOutput struct {
	// READ-ONLY; Mapping from database name to list of source tables
	DatabasesToSourceTables *string `json:"databasesToSourceTables,omitempty" azure:"ro"`

	// READ-ONLY; Mapping from database name to list of target tables
	DatabasesToTargetTables *string `json:"databasesToTargetTables,omitempty" azure:"ro"`

	// READ-ONLY; Mapping from database name to list of validation errors
	TableValidationErrors *string `json:"tableValidationErrors,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesSQLSyncTaskOutput.
func (g GetUserTablesSQLSyncTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databasesToSourceTables", g.DatabasesToSourceTables)
	populate(objectMap, "databasesToTargetTables", g.DatabasesToTargetTables)
	populate(objectMap, "tableValidationErrors", g.TableValidationErrors)
	populate(objectMap, "validationErrors", g.ValidationErrors)
	return json.Marshal(objectMap)
}

// GetUserTablesSQLSyncTaskProperties - Properties for the task that collects user tables for the given list of databases
type GetUserTablesSQLSyncTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *GetUserTablesSQLSyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*GetUserTablesSQLSyncTaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesSQLSyncTaskProperties.
func (g GetUserTablesSQLSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	g.ProjectTaskProperties.marshalInternal(objectMap, "GetUserTables.AzureSqlDb.Sync")
	populate(objectMap, "input", g.Input)
	populate(objectMap, "output", g.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetUserTablesSQLSyncTaskProperties.
func (g *GetUserTablesSQLSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &g.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &g.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := g.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// GetUserTablesSQLTaskInput - Input for the task that collects user tables for the given list of databases
type GetUserTablesSQLTaskInput struct {
	// REQUIRED; Connection information for SQL Server
	ConnectionInfo *SQLConnectionInfo `json:"connectionInfo,omitempty"`

	// REQUIRED; List of database names to collect tables for
	SelectedDatabases []*string `json:"selectedDatabases,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesSQLTaskInput.
func (g GetUserTablesSQLTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "connectionInfo", g.ConnectionInfo)
	populate(objectMap, "selectedDatabases", g.SelectedDatabases)
	return json.Marshal(objectMap)
}

// GetUserTablesSQLTaskOutput - Output of the task that collects user tables for the given list of databases
type GetUserTablesSQLTaskOutput struct {
	// READ-ONLY; Mapping from database name to list of tables
	DatabasesToTables *string `json:"databasesToTables,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesSQLTaskOutput.
func (g GetUserTablesSQLTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databasesToTables", g.DatabasesToTables)
	populate(objectMap, "id", g.ID)
	populate(objectMap, "validationErrors", g.ValidationErrors)
	return json.Marshal(objectMap)
}

// GetUserTablesSQLTaskProperties - Properties for the task that collects user tables for the given list of databases
type GetUserTablesSQLTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *GetUserTablesSQLTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*GetUserTablesSQLTaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type GetUserTablesSQLTaskProperties.
func (g GetUserTablesSQLTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	g.ProjectTaskProperties.marshalInternal(objectMap, "GetUserTables.Sql")
	populate(objectMap, "input", g.Input)
	populate(objectMap, "output", g.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GetUserTablesSQLTaskProperties.
func (g *GetUserTablesSQLTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &g.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &g.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := g.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// InstallOCIDriverTaskInput - Input for the service task to install an OCI driver.
type InstallOCIDriverTaskInput struct {
	// Name of the uploaded driver package to install.
	DriverPackageName *string `json:"driverPackageName,omitempty"`
}

// InstallOCIDriverTaskOutput - Output for the service task to install an OCI driver.
type InstallOCIDriverTaskOutput struct {
	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type InstallOCIDriverTaskOutput.
func (i InstallOCIDriverTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "validationErrors", i.ValidationErrors)
	return json.Marshal(objectMap)
}

// InstallOCIDriverTaskProperties - Properties for the task that installs an OCI driver.
type InstallOCIDriverTaskProperties struct {
	ProjectTaskProperties
	// Input for the service task to install an OCI driver.
	Input *InstallOCIDriverTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*InstallOCIDriverTaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type InstallOCIDriverTaskProperties.
func (i InstallOCIDriverTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	i.ProjectTaskProperties.marshalInternal(objectMap, "Service.Install.OCI")
	populate(objectMap, "input", i.Input)
	populate(objectMap, "output", i.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InstallOCIDriverTaskProperties.
func (i *InstallOCIDriverTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &i.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &i.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := i.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MiSQLConnectionInfo - Properties required to create a connection to Azure SQL database Managed instance
type MiSQLConnectionInfo struct {
	ConnectionInfo
	// REQUIRED; Resource id for Azure SQL database Managed instance
	ManagedInstanceResourceID *string `json:"managedInstanceResourceId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MiSQLConnectionInfo.
func (m MiSQLConnectionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ConnectionInfo.marshalInternal(objectMap, "MiSqlConnectionInfo")
	populate(objectMap, "managedInstanceResourceId", m.ManagedInstanceResourceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MiSQLConnectionInfo.
func (m *MiSQLConnectionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "managedInstanceResourceId":
			err = unpopulate(val, &m.ManagedInstanceResourceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ConnectionInfo.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigrateMISyncCompleteCommandInput - Input for command that completes online migration for an Azure SQL Database Managed Instance.
type MigrateMISyncCompleteCommandInput struct {
	// REQUIRED; Name of managed instance database
	SourceDatabaseName *string `json:"sourceDatabaseName,omitempty"`
}

// MigrateMISyncCompleteCommandOutput - Output for command that completes online migration for an Azure SQL Database Managed Instance.
type MigrateMISyncCompleteCommandOutput struct {
	// List of errors that happened during the command execution
	Errors []*ReportableException `json:"errors,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMISyncCompleteCommandOutput.
func (m MigrateMISyncCompleteCommandOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "errors", m.Errors)
	return json.Marshal(objectMap)
}

// MigrateMISyncCompleteCommandProperties - Properties for the command that completes online migration for an Azure SQL Database Managed Instance.
type MigrateMISyncCompleteCommandProperties struct {
	CommandProperties
	// Command input
	Input *MigrateMISyncCompleteCommandInput `json:"input,omitempty"`

	// READ-ONLY; Command output. This is ignored if submitted.
	Output *MigrateMISyncCompleteCommandOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMISyncCompleteCommandProperties.
func (m MigrateMISyncCompleteCommandProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.CommandProperties.marshalInternal(objectMap, "Migrate.SqlServer.AzureDbSqlMi.Complete")
	populate(objectMap, "input", m.Input)
	populate(objectMap, "output", m.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMISyncCompleteCommandProperties.
func (m *MigrateMISyncCompleteCommandProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &m.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.CommandProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigrateMongoDbTaskProperties - Properties for the task that migrates data between MongoDB data sources
type MigrateMongoDbTaskProperties struct {
	ProjectTaskProperties
	// Describes how a MongoDB data migration should be performed
	Input *MongoDbMigrationSettings `json:"input,omitempty"`

	// READ-ONLY
	Output []MongoDbProgressClassification `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMongoDbTaskProperties.
func (m MigrateMongoDbTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ProjectTaskProperties.marshalInternal(objectMap, "Migrate.MongoDb")
	populate(objectMap, "input", m.Input)
	populate(objectMap, "output", m.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMongoDbTaskProperties.
func (m *MigrateMongoDbTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMongoDbProgressClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigrateMySQLAzureDbForMySQLOfflineDatabaseInput - Database specific information for offline MySQL to Azure Database for MySQL migration task inputs
type MigrateMySQLAzureDbForMySQLOfflineDatabaseInput struct {
	// Name of the database
	Name *string `json:"name,omitempty"`

	// Mapping of source to target tables
	TableMap map[string]*string `json:"tableMap,omitempty"`

	// Name of target database. Note: Target database will be truncated before starting migration.
	TargetDatabaseName *string `json:"targetDatabaseName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLOfflineDatabaseInput.
func (m MigrateMySQLAzureDbForMySQLOfflineDatabaseInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "name", m.Name)
	populate(objectMap, "tableMap", m.TableMap)
	populate(objectMap, "targetDatabaseName", m.TargetDatabaseName)
	return json.Marshal(objectMap)
}

// MigrateMySQLAzureDbForMySQLOfflineTaskInput - Input for the task that migrates MySQL databases to Azure Database for MySQL for offline migrations
type MigrateMySQLAzureDbForMySQLOfflineTaskInput struct {
	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateMySQLAzureDbForMySQLOfflineDatabaseInput `json:"selectedDatabases,omitempty"`

	// REQUIRED; Connection information for source MySQL
	SourceConnectionInfo *MySQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Connection information for target Azure Database for MySQL
	TargetConnectionInfo *MySQLConnectionInfo `json:"targetConnectionInfo,omitempty"`

	// Setting to set the source server read only
	MakeSourceServerReadOnly *bool `json:"makeSourceServerReadOnly,omitempty"`

	// Optional parameters for fine tuning the data transfer rate during migration
	OptionalAgentSettings map[string]*string `json:"optionalAgentSettings,omitempty"`

	// Parameter to specify when the migration started
	StartedOn *time.Time `json:"startedOn,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLOfflineTaskInput.
func (m MigrateMySQLAzureDbForMySQLOfflineTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "makeSourceServerReadOnly", m.MakeSourceServerReadOnly)
	populate(objectMap, "optionalAgentSettings", m.OptionalAgentSettings)
	populate(objectMap, "selectedDatabases", m.SelectedDatabases)
	populate(objectMap, "sourceConnectionInfo", m.SourceConnectionInfo)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	populate(objectMap, "targetConnectionInfo", m.TargetConnectionInfo)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMySQLAzureDbForMySQLOfflineTaskInput.
func (m *MigrateMySQLAzureDbForMySQLOfflineTaskInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "makeSourceServerReadOnly":
			err = unpopulate(val, &m.MakeSourceServerReadOnly)
			delete(rawMsg, key)
		case "optionalAgentSettings":
			err = unpopulate(val, &m.OptionalAgentSettings)
			delete(rawMsg, key)
		case "selectedDatabases":
			err = unpopulate(val, &m.SelectedDatabases)
			delete(rawMsg, key)
		case "sourceConnectionInfo":
			err = unpopulate(val, &m.SourceConnectionInfo)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "targetConnectionInfo":
			err = unpopulate(val, &m.TargetConnectionInfo)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateMySQLAzureDbForMySQLOfflineTaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetMigrateMySQLAzureDbForMySQLOfflineTaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MigrateMySQLAzureDbForMySQLOfflineTaskOutput
type MigrateMySQLAzureDbForMySQLOfflineTaskOutputClassification interface {
	// GetMigrateMySQLAzureDbForMySQLOfflineTaskOutput returns the MigrateMySQLAzureDbForMySQLOfflineTaskOutput content of the underlying type.
	GetMigrateMySQLAzureDbForMySQLOfflineTaskOutput() *MigrateMySQLAzureDbForMySQLOfflineTaskOutput
}

// MigrateMySQLAzureDbForMySQLOfflineTaskOutput - Output for the task that migrates MySQL databases to Azure Database for MySQL for offline migrations
type MigrateMySQLAzureDbForMySQLOfflineTaskOutput struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateMySQLAzureDbForMySQLOfflineTaskOutput implements the MigrateMySQLAzureDbForMySQLOfflineTaskOutputClassification interface for type MigrateMySQLAzureDbForMySQLOfflineTaskOutput.
func (m *MigrateMySQLAzureDbForMySQLOfflineTaskOutput) GetMigrateMySQLAzureDbForMySQLOfflineTaskOutput() *MigrateMySQLAzureDbForMySQLOfflineTaskOutput {
	return m
}

// MigrateMySQLAzureDbForMySQLOfflineTaskProperties - Properties for the task that migrates MySQL databases to Azure Database for MySQL for offline migrations
type MigrateMySQLAzureDbForMySQLOfflineTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *MigrateMySQLAzureDbForMySQLOfflineTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []MigrateMySQLAzureDbForMySQLOfflineTaskOutputClassification `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLOfflineTaskProperties.
func (m MigrateMySQLAzureDbForMySQLOfflineTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ProjectTaskProperties.marshalInternal(objectMap, "Migrate.MySql.AzureDbForMySql")
	populate(objectMap, "input", m.Input)
	populate(objectMap, "output", m.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMySQLAzureDbForMySQLOfflineTaskProperties.
func (m *MigrateMySQLAzureDbForMySQLOfflineTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMigrateMySQLAzureDbForMySQLOfflineTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigrateMySQLAzureDbForMySQLSyncDatabaseInput - Database specific information for MySQL to Azure Database for MySQL migration task inputs
type MigrateMySQLAzureDbForMySQLSyncDatabaseInput struct {
	// Migration settings which tune the migration behavior
	MigrationSetting map[string]*string `json:"migrationSetting,omitempty"`

	// Name of the database
	Name *string `json:"name,omitempty"`

	// Source settings to tune source endpoint migration behavior
	SourceSetting map[string]*string `json:"sourceSetting,omitempty"`

	// Mapping of source to target tables
	TableMap map[string]*string `json:"tableMap,omitempty"`

	// Name of target database. Note: Target database will be truncated before starting migration.
	TargetDatabaseName *string `json:"targetDatabaseName,omitempty"`

	// Target settings to tune target endpoint migration behavior
	TargetSetting map[string]*string `json:"targetSetting,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLSyncDatabaseInput.
func (m MigrateMySQLAzureDbForMySQLSyncDatabaseInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "migrationSetting", m.MigrationSetting)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "sourceSetting", m.SourceSetting)
	populate(objectMap, "tableMap", m.TableMap)
	populate(objectMap, "targetDatabaseName", m.TargetDatabaseName)
	populate(objectMap, "targetSetting", m.TargetSetting)
	return json.Marshal(objectMap)
}

// MigrateMySQLAzureDbForMySQLSyncTaskInput - Input for the task that migrates MySQL databases to Azure Database for MySQL for online migrations
type MigrateMySQLAzureDbForMySQLSyncTaskInput struct {
	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateMySQLAzureDbForMySQLSyncDatabaseInput `json:"selectedDatabases,omitempty"`

	// REQUIRED; Connection information for source MySQL
	SourceConnectionInfo *MySQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Connection information for target Azure Database for MySQL
	TargetConnectionInfo *MySQLConnectionInfo `json:"targetConnectionInfo,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskInput.
func (m MigrateMySQLAzureDbForMySQLSyncTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "selectedDatabases", m.SelectedDatabases)
	populate(objectMap, "sourceConnectionInfo", m.SourceConnectionInfo)
	populate(objectMap, "targetConnectionInfo", m.TargetConnectionInfo)
	return json.Marshal(objectMap)
}

// MigrateMySQLAzureDbForMySQLSyncTaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetMigrateMySQLAzureDbForMySQLSyncTaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MigrateMySQLAzureDbForMySQLSyncTaskOutput, *MigrateMySqlAzureDbForMySqlSyncTaskOutputDatabaseError, *MigrateMySqlAzureDbForMySqlSyncTaskOutputDatabaseLevel,
// - *MigrateMySqlAzureDbForMySqlSyncTaskOutputError, *MigrateMySqlAzureDbForMySqlSyncTaskOutputMigrationLevel, *MigrateMySqlAzureDbForMySqlSyncTaskOutputTableLevel
type MigrateMySQLAzureDbForMySQLSyncTaskOutputClassification interface {
	// GetMigrateMySQLAzureDbForMySQLSyncTaskOutput returns the MigrateMySQLAzureDbForMySQLSyncTaskOutput content of the underlying type.
	GetMigrateMySQLAzureDbForMySQLSyncTaskOutput() *MigrateMySQLAzureDbForMySQLSyncTaskOutput
}

// MigrateMySQLAzureDbForMySQLSyncTaskOutput - Output for the task that migrates MySQL databases to Azure Database for MySQL for online migrations
type MigrateMySQLAzureDbForMySQLSyncTaskOutput struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateMySQLAzureDbForMySQLSyncTaskOutput implements the MigrateMySQLAzureDbForMySQLSyncTaskOutputClassification interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutput.
func (m *MigrateMySQLAzureDbForMySQLSyncTaskOutput) GetMigrateMySQLAzureDbForMySQLSyncTaskOutput() *MigrateMySQLAzureDbForMySQLSyncTaskOutput {
	return m
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutput.
func (m *MigrateMySQLAzureDbForMySQLSyncTaskOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return m.unmarshalInternal(rawMsg)
}

func (m MigrateMySQLAzureDbForMySQLSyncTaskOutput) marshalInternal(objectMap map[string]interface{}, discValue string) {
	populate(objectMap, "id", m.ID)
	m.ResultType = &discValue
	objectMap["resultType"] = m.ResultType
}

func (m *MigrateMySQLAzureDbForMySQLSyncTaskOutput) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseError struct {
	MigrateMySQLAzureDbForMySQLSyncTaskOutput
	// Error message
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// List of error events.
	Events []*SyncMigrationDatabaseErrorEvent `json:"events,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseError.
func (m MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateMySQLAzureDbForMySQLSyncTaskOutput.marshalInternal(objectMap, "DatabaseLevelErrorOutput")
	populate(objectMap, "errorMessage", m.ErrorMessage)
	populate(objectMap, "events", m.Events)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseError.
func (m *MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorMessage":
			err = unpopulate(val, &m.ErrorMessage)
			delete(rawMsg, key)
		case "events":
			err = unpopulate(val, &m.Events)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateMySQLAzureDbForMySQLSyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseLevel struct {
	MigrateMySQLAzureDbForMySQLSyncTaskOutput
	// READ-ONLY; Number of applied changes
	AppliedChanges *int64 `json:"appliedChanges,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc deletes
	CdcDeleteCounter *int64 `json:"cdcDeleteCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc inserts
	CdcInsertCounter *int64 `json:"cdcInsertCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc updates
	CdcUpdateCounter *int64 `json:"cdcUpdateCounter,omitempty" azure:"ro"`

	// READ-ONLY; Name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables completed in full load
	FullLoadCompletedTables *int64 `json:"fullLoadCompletedTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables errored in full load
	FullLoadErroredTables *int64 `json:"fullLoadErroredTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables loading in full load
	FullLoadLoadingTables *int64 `json:"fullLoadLoadingTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables queued in full load
	FullLoadQueuedTables *int64 `json:"fullLoadQueuedTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of incoming changes
	IncomingChanges *int64 `json:"incomingChanges,omitempty" azure:"ro"`

	// READ-ONLY; Indicates if initial load (full load) has been completed
	InitializationCompleted *bool `json:"initializationCompleted,omitempty" azure:"ro"`

	// READ-ONLY; CDC apply latency
	Latency *int64 `json:"latency,omitempty" azure:"ro"`

	// READ-ONLY; Migration state that this database is in
	MigrationState *SyncDatabaseMigrationReportingState `json:"migrationState,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseLevel.
func (m MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateMySQLAzureDbForMySQLSyncTaskOutput.marshalInternal(objectMap, "DatabaseLevelOutput")
	populate(objectMap, "appliedChanges", m.AppliedChanges)
	populate(objectMap, "cdcDeleteCounter", m.CdcDeleteCounter)
	populate(objectMap, "cdcInsertCounter", m.CdcInsertCounter)
	populate(objectMap, "cdcUpdateCounter", m.CdcUpdateCounter)
	populate(objectMap, "databaseName", m.DatabaseName)
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "fullLoadCompletedTables", m.FullLoadCompletedTables)
	populate(objectMap, "fullLoadErroredTables", m.FullLoadErroredTables)
	populate(objectMap, "fullLoadLoadingTables", m.FullLoadLoadingTables)
	populate(objectMap, "fullLoadQueuedTables", m.FullLoadQueuedTables)
	populate(objectMap, "incomingChanges", m.IncomingChanges)
	populate(objectMap, "initializationCompleted", m.InitializationCompleted)
	populate(objectMap, "latency", m.Latency)
	populate(objectMap, "migrationState", m.MigrationState)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseLevel.
func (m *MigrateMySQLAzureDbForMySQLSyncTaskOutputDatabaseLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appliedChanges":
			err = unpopulate(val, &m.AppliedChanges)
			delete(rawMsg, key)
		case "cdcDeleteCounter":
			err = unpopulate(val, &m.CdcDeleteCounter)
			delete(rawMsg, key)
		case "cdcInsertCounter":
			err = unpopulate(val, &m.CdcInsertCounter)
			delete(rawMsg, key)
		case "cdcUpdateCounter":
			err = unpopulate(val, &m.CdcUpdateCounter)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "fullLoadCompletedTables":
			err = unpopulate(val, &m.FullLoadCompletedTables)
			delete(rawMsg, key)
		case "fullLoadErroredTables":
			err = unpopulate(val, &m.FullLoadErroredTables)
			delete(rawMsg, key)
		case "fullLoadLoadingTables":
			err = unpopulate(val, &m.FullLoadLoadingTables)
			delete(rawMsg, key)
		case "fullLoadQueuedTables":
			err = unpopulate(val, &m.FullLoadQueuedTables)
			delete(rawMsg, key)
		case "incomingChanges":
			err = unpopulate(val, &m.IncomingChanges)
			delete(rawMsg, key)
		case "initializationCompleted":
			err = unpopulate(val, &m.InitializationCompleted)
			delete(rawMsg, key)
		case "latency":
			err = unpopulate(val, &m.Latency)
			delete(rawMsg, key)
		case "migrationState":
			err = unpopulate(val, &m.MigrationState)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateMySQLAzureDbForMySQLSyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateMySQLAzureDbForMySQLSyncTaskOutputError struct {
	MigrateMySQLAzureDbForMySQLSyncTaskOutput
	// READ-ONLY; Migration error
	Error *ReportableException `json:"error,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutputError.
func (m MigrateMySQLAzureDbForMySQLSyncTaskOutputError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateMySQLAzureDbForMySQLSyncTaskOutput.marshalInternal(objectMap, "ErrorOutput")
	populate(objectMap, "error", m.Error)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutputError.
func (m *MigrateMySQLAzureDbForMySQLSyncTaskOutputError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &m.Error)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateMySQLAzureDbForMySQLSyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateMySQLAzureDbForMySQLSyncTaskOutputMigrationLevel struct {
	MigrateMySQLAzureDbForMySQLSyncTaskOutput
	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Source server name
	SourceServer *string `json:"sourceServer,omitempty" azure:"ro"`

	// READ-ONLY; Source server version
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Target server name
	TargetServer *string `json:"targetServer,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutputMigrationLevel.
func (m MigrateMySQLAzureDbForMySQLSyncTaskOutputMigrationLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateMySQLAzureDbForMySQLSyncTaskOutput.marshalInternal(objectMap, "MigrationLevelOutput")
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "sourceServer", m.SourceServer)
	populate(objectMap, "sourceServerVersion", m.SourceServerVersion)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	populate(objectMap, "targetServer", m.TargetServer)
	populate(objectMap, "targetServerVersion", m.TargetServerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutputMigrationLevel.
func (m *MigrateMySQLAzureDbForMySQLSyncTaskOutputMigrationLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "sourceServer":
			err = unpopulate(val, &m.SourceServer)
			delete(rawMsg, key)
		case "sourceServerVersion":
			err = unpopulate(val, &m.SourceServerVersion)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "targetServer":
			err = unpopulate(val, &m.TargetServer)
			delete(rawMsg, key)
		case "targetServerVersion":
			err = unpopulate(val, &m.TargetServerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateMySQLAzureDbForMySQLSyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateMySQLAzureDbForMySQLSyncTaskOutputTableLevel struct {
	MigrateMySQLAzureDbForMySQLSyncTaskOutput
	// READ-ONLY; Number of applied deletes
	CdcDeleteCounter *string `json:"cdcDeleteCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of applied inserts
	CdcInsertCounter *string `json:"cdcInsertCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of applied updates
	CdcUpdateCounter *string `json:"cdcUpdateCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of data errors occurred
	DataErrorsCounter *int64 `json:"dataErrorsCounter,omitempty" azure:"ro"`

	// READ-ONLY; Name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Full load end time
	FullLoadEndedOn *time.Time `json:"fullLoadEndedOn,omitempty" azure:"ro"`

	// READ-ONLY; Estimate to finish full load
	FullLoadEstFinishTime *time.Time `json:"fullLoadEstFinishTime,omitempty" azure:"ro"`

	// READ-ONLY; Full load start time
	FullLoadStartedOn *time.Time `json:"fullLoadStartedOn,omitempty" azure:"ro"`

	// READ-ONLY; Number of rows applied in full load
	FullLoadTotalRows *int64 `json:"fullLoadTotalRows,omitempty" azure:"ro"`

	// READ-ONLY; Last modified time on target
	LastModifiedTime *time.Time `json:"lastModifiedTime,omitempty" azure:"ro"`

	// READ-ONLY; Current state of the table migration
	State *SyncTableMigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Name of the table
	TableName *string `json:"tableName,omitempty" azure:"ro"`

	// READ-ONLY; Total number of applied changes
	TotalChangesApplied *int64 `json:"totalChangesApplied,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutputTableLevel.
func (m MigrateMySQLAzureDbForMySQLSyncTaskOutputTableLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateMySQLAzureDbForMySQLSyncTaskOutput.marshalInternal(objectMap, "TableLevelOutput")
	populate(objectMap, "cdcDeleteCounter", m.CdcDeleteCounter)
	populate(objectMap, "cdcInsertCounter", m.CdcInsertCounter)
	populate(objectMap, "cdcUpdateCounter", m.CdcUpdateCounter)
	populate(objectMap, "dataErrorsCounter", m.DataErrorsCounter)
	populate(objectMap, "databaseName", m.DatabaseName)
	populate(objectMap, "fullLoadEndedOn", (*timeRFC3339)(m.FullLoadEndedOn))
	populate(objectMap, "fullLoadEstFinishTime", (*timeRFC3339)(m.FullLoadEstFinishTime))
	populate(objectMap, "fullLoadStartedOn", (*timeRFC3339)(m.FullLoadStartedOn))
	populate(objectMap, "fullLoadTotalRows", m.FullLoadTotalRows)
	populate(objectMap, "lastModifiedTime", (*timeRFC3339)(m.LastModifiedTime))
	populate(objectMap, "state", m.State)
	populate(objectMap, "tableName", m.TableName)
	populate(objectMap, "totalChangesApplied", m.TotalChangesApplied)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskOutputTableLevel.
func (m *MigrateMySQLAzureDbForMySQLSyncTaskOutputTableLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cdcDeleteCounter":
			err = unpopulate(val, &m.CdcDeleteCounter)
			delete(rawMsg, key)
		case "cdcInsertCounter":
			err = unpopulate(val, &m.CdcInsertCounter)
			delete(rawMsg, key)
		case "cdcUpdateCounter":
			err = unpopulate(val, &m.CdcUpdateCounter)
			delete(rawMsg, key)
		case "dataErrorsCounter":
			err = unpopulate(val, &m.DataErrorsCounter)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "fullLoadEndedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.FullLoadEndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "fullLoadEstFinishTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.FullLoadEstFinishTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "fullLoadStartedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.FullLoadStartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "fullLoadTotalRows":
			err = unpopulate(val, &m.FullLoadTotalRows)
			delete(rawMsg, key)
		case "lastModifiedTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.LastModifiedTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, &m.TableName)
			delete(rawMsg, key)
		case "totalChangesApplied":
			err = unpopulate(val, &m.TotalChangesApplied)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateMySQLAzureDbForMySQLSyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigrateMySQLAzureDbForMySQLSyncTaskProperties - Properties for the task that migrates MySQL databases to Azure Database for MySQL for online migrations
type MigrateMySQLAzureDbForMySQLSyncTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *MigrateMySQLAzureDbForMySQLSyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []MigrateMySQLAzureDbForMySQLSyncTaskOutputClassification `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskProperties.
func (m MigrateMySQLAzureDbForMySQLSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ProjectTaskProperties.marshalInternal(objectMap, "Migrate.MySql.AzureDbForMySql.Sync")
	populate(objectMap, "input", m.Input)
	populate(objectMap, "output", m.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateMySQLAzureDbForMySQLSyncTaskProperties.
func (m *MigrateMySQLAzureDbForMySQLSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMigrateMySQLAzureDbForMySQLSyncTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigrateOracleAzureDbForPostgreSQLSyncTaskProperties - Properties for the task that migrates Oracle to Azure Database for PostgreSQL for online migrations
type MigrateOracleAzureDbForPostgreSQLSyncTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *MigrateOracleAzureDbPostgreSQLSyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []MigrateOracleAzureDbPostgreSQLSyncTaskOutputClassification `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateOracleAzureDbForPostgreSQLSyncTaskProperties.
func (m MigrateOracleAzureDbForPostgreSQLSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ProjectTaskProperties.marshalInternal(objectMap, "Migrate.Oracle.AzureDbForPostgreSql.Sync")
	populate(objectMap, "input", m.Input)
	populate(objectMap, "output", m.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateOracleAzureDbForPostgreSQLSyncTaskProperties.
func (m *MigrateOracleAzureDbForPostgreSQLSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMigrateOracleAzureDbPostgreSQLSyncTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigrateOracleAzureDbPostgreSQLSyncDatabaseInput - Database specific information for Oracle to Azure Database for PostgreSQL migration task inputs
type MigrateOracleAzureDbPostgreSQLSyncDatabaseInput struct {
	// How to handle object name casing: either Preserve or ToLower
	CaseManipulation *string `json:"caseManipulation,omitempty"`

	// Migration settings which tune the migration behavior
	MigrationSetting map[string]*string `json:"migrationSetting,omitempty"`

	// Name of the migration pipeline
	Name *string `json:"name,omitempty"`

	// Name of the source schema
	SchemaName *string `json:"schemaName,omitempty"`

	// Source settings to tune source endpoint migration behavior
	SourceSetting map[string]*string `json:"sourceSetting,omitempty"`

	// Mapping of source to target tables
	TableMap map[string]*string `json:"tableMap,omitempty"`

	// Name of target database. Note: Target database will be truncated before starting migration.
	TargetDatabaseName *string `json:"targetDatabaseName,omitempty"`

	// Target settings to tune target endpoint migration behavior
	TargetSetting map[string]*string `json:"targetSetting,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateOracleAzureDbPostgreSQLSyncDatabaseInput.
func (m MigrateOracleAzureDbPostgreSQLSyncDatabaseInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "caseManipulation", m.CaseManipulation)
	populate(objectMap, "migrationSetting", m.MigrationSetting)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "schemaName", m.SchemaName)
	populate(objectMap, "sourceSetting", m.SourceSetting)
	populate(objectMap, "tableMap", m.TableMap)
	populate(objectMap, "targetDatabaseName", m.TargetDatabaseName)
	populate(objectMap, "targetSetting", m.TargetSetting)
	return json.Marshal(objectMap)
}

// MigrateOracleAzureDbPostgreSQLSyncTaskInput - Input for the task that migrates Oracle databases to Azure Database for PostgreSQL for online migrations
type MigrateOracleAzureDbPostgreSQLSyncTaskInput struct {
	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateOracleAzureDbPostgreSQLSyncDatabaseInput `json:"selectedDatabases,omitempty"`

	// REQUIRED; Connection information for source Oracle
	SourceConnectionInfo *OracleConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Connection information for target Azure Database for PostgreSQL
	TargetConnectionInfo *PostgreSQLConnectionInfo `json:"targetConnectionInfo,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskInput.
func (m MigrateOracleAzureDbPostgreSQLSyncTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "selectedDatabases", m.SelectedDatabases)
	populate(objectMap, "sourceConnectionInfo", m.SourceConnectionInfo)
	populate(objectMap, "targetConnectionInfo", m.TargetConnectionInfo)
	return json.Marshal(objectMap)
}

// MigrateOracleAzureDbPostgreSQLSyncTaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetMigrateOracleAzureDbPostgreSQLSyncTaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MigrateOracleAzureDbPostgreSQLSyncTaskOutput, *MigrateOracleAzureDbPostgreSqlSyncTaskOutputDatabaseError, *MigrateOracleAzureDbPostgreSqlSyncTaskOutputDatabaseLevel,
// - *MigrateOracleAzureDbPostgreSqlSyncTaskOutputError, *MigrateOracleAzureDbPostgreSqlSyncTaskOutputMigrationLevel, *MigrateOracleAzureDbPostgreSqlSyncTaskOutputTableLevel
type MigrateOracleAzureDbPostgreSQLSyncTaskOutputClassification interface {
	// GetMigrateOracleAzureDbPostgreSQLSyncTaskOutput returns the MigrateOracleAzureDbPostgreSQLSyncTaskOutput content of the underlying type.
	GetMigrateOracleAzureDbPostgreSQLSyncTaskOutput() *MigrateOracleAzureDbPostgreSQLSyncTaskOutput
}

// MigrateOracleAzureDbPostgreSQLSyncTaskOutput - Output for the task that migrates Oracle databases to Azure Database for PostgreSQL for online migrations
type MigrateOracleAzureDbPostgreSQLSyncTaskOutput struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateOracleAzureDbPostgreSQLSyncTaskOutput implements the MigrateOracleAzureDbPostgreSQLSyncTaskOutputClassification interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutput.
func (m *MigrateOracleAzureDbPostgreSQLSyncTaskOutput) GetMigrateOracleAzureDbPostgreSQLSyncTaskOutput() *MigrateOracleAzureDbPostgreSQLSyncTaskOutput {
	return m
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutput.
func (m *MigrateOracleAzureDbPostgreSQLSyncTaskOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return m.unmarshalInternal(rawMsg)
}

func (m MigrateOracleAzureDbPostgreSQLSyncTaskOutput) marshalInternal(objectMap map[string]interface{}, discValue string) {
	populate(objectMap, "id", m.ID)
	m.ResultType = &discValue
	objectMap["resultType"] = m.ResultType
}

func (m *MigrateOracleAzureDbPostgreSQLSyncTaskOutput) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseError struct {
	MigrateOracleAzureDbPostgreSQLSyncTaskOutput
	// Error message
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// List of error events.
	Events []*SyncMigrationDatabaseErrorEvent `json:"events,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseError.
func (m MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateOracleAzureDbPostgreSQLSyncTaskOutput.marshalInternal(objectMap, "DatabaseLevelErrorOutput")
	populate(objectMap, "errorMessage", m.ErrorMessage)
	populate(objectMap, "events", m.Events)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseError.
func (m *MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorMessage":
			err = unpopulate(val, &m.ErrorMessage)
			delete(rawMsg, key)
		case "events":
			err = unpopulate(val, &m.Events)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateOracleAzureDbPostgreSQLSyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseLevel struct {
	MigrateOracleAzureDbPostgreSQLSyncTaskOutput
	// READ-ONLY; Number of applied changes
	AppliedChanges *int64 `json:"appliedChanges,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc deletes
	CdcDeleteCounter *int64 `json:"cdcDeleteCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc inserts
	CdcInsertCounter *int64 `json:"cdcInsertCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc updates
	CdcUpdateCounter *int64 `json:"cdcUpdateCounter,omitempty" azure:"ro"`

	// READ-ONLY; Name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables completed in full load
	FullLoadCompletedTables *int64 `json:"fullLoadCompletedTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables errored in full load
	FullLoadErroredTables *int64 `json:"fullLoadErroredTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables loading in full load
	FullLoadLoadingTables *int64 `json:"fullLoadLoadingTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables queued in full load
	FullLoadQueuedTables *int64 `json:"fullLoadQueuedTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of incoming changes
	IncomingChanges *int64 `json:"incomingChanges,omitempty" azure:"ro"`

	// READ-ONLY; Indicates if initial load (full load) has been completed
	InitializationCompleted *bool `json:"initializationCompleted,omitempty" azure:"ro"`

	// READ-ONLY; CDC apply latency
	Latency *int64 `json:"latency,omitempty" azure:"ro"`

	// READ-ONLY; Migration state that this database is in
	MigrationState *SyncDatabaseMigrationReportingState `json:"migrationState,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseLevel.
func (m MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateOracleAzureDbPostgreSQLSyncTaskOutput.marshalInternal(objectMap, "DatabaseLevelOutput")
	populate(objectMap, "appliedChanges", m.AppliedChanges)
	populate(objectMap, "cdcDeleteCounter", m.CdcDeleteCounter)
	populate(objectMap, "cdcInsertCounter", m.CdcInsertCounter)
	populate(objectMap, "cdcUpdateCounter", m.CdcUpdateCounter)
	populate(objectMap, "databaseName", m.DatabaseName)
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "fullLoadCompletedTables", m.FullLoadCompletedTables)
	populate(objectMap, "fullLoadErroredTables", m.FullLoadErroredTables)
	populate(objectMap, "fullLoadLoadingTables", m.FullLoadLoadingTables)
	populate(objectMap, "fullLoadQueuedTables", m.FullLoadQueuedTables)
	populate(objectMap, "incomingChanges", m.IncomingChanges)
	populate(objectMap, "initializationCompleted", m.InitializationCompleted)
	populate(objectMap, "latency", m.Latency)
	populate(objectMap, "migrationState", m.MigrationState)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseLevel.
func (m *MigrateOracleAzureDbPostgreSQLSyncTaskOutputDatabaseLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appliedChanges":
			err = unpopulate(val, &m.AppliedChanges)
			delete(rawMsg, key)
		case "cdcDeleteCounter":
			err = unpopulate(val, &m.CdcDeleteCounter)
			delete(rawMsg, key)
		case "cdcInsertCounter":
			err = unpopulate(val, &m.CdcInsertCounter)
			delete(rawMsg, key)
		case "cdcUpdateCounter":
			err = unpopulate(val, &m.CdcUpdateCounter)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "fullLoadCompletedTables":
			err = unpopulate(val, &m.FullLoadCompletedTables)
			delete(rawMsg, key)
		case "fullLoadErroredTables":
			err = unpopulate(val, &m.FullLoadErroredTables)
			delete(rawMsg, key)
		case "fullLoadLoadingTables":
			err = unpopulate(val, &m.FullLoadLoadingTables)
			delete(rawMsg, key)
		case "fullLoadQueuedTables":
			err = unpopulate(val, &m.FullLoadQueuedTables)
			delete(rawMsg, key)
		case "incomingChanges":
			err = unpopulate(val, &m.IncomingChanges)
			delete(rawMsg, key)
		case "initializationCompleted":
			err = unpopulate(val, &m.InitializationCompleted)
			delete(rawMsg, key)
		case "latency":
			err = unpopulate(val, &m.Latency)
			delete(rawMsg, key)
		case "migrationState":
			err = unpopulate(val, &m.MigrationState)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateOracleAzureDbPostgreSQLSyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateOracleAzureDbPostgreSQLSyncTaskOutputError struct {
	MigrateOracleAzureDbPostgreSQLSyncTaskOutput
	// READ-ONLY; Migration error
	Error *ReportableException `json:"error,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputError.
func (m MigrateOracleAzureDbPostgreSQLSyncTaskOutputError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateOracleAzureDbPostgreSQLSyncTaskOutput.marshalInternal(objectMap, "ErrorOutput")
	populate(objectMap, "error", m.Error)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputError.
func (m *MigrateOracleAzureDbPostgreSQLSyncTaskOutputError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &m.Error)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateOracleAzureDbPostgreSQLSyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateOracleAzureDbPostgreSQLSyncTaskOutputMigrationLevel struct {
	MigrateOracleAzureDbPostgreSQLSyncTaskOutput
	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Source server name
	SourceServer *string `json:"sourceServer,omitempty" azure:"ro"`

	// READ-ONLY; Source server version
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Target server name
	TargetServer *string `json:"targetServer,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputMigrationLevel.
func (m MigrateOracleAzureDbPostgreSQLSyncTaskOutputMigrationLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateOracleAzureDbPostgreSQLSyncTaskOutput.marshalInternal(objectMap, "MigrationLevelOutput")
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "sourceServer", m.SourceServer)
	populate(objectMap, "sourceServerVersion", m.SourceServerVersion)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	populate(objectMap, "targetServer", m.TargetServer)
	populate(objectMap, "targetServerVersion", m.TargetServerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputMigrationLevel.
func (m *MigrateOracleAzureDbPostgreSQLSyncTaskOutputMigrationLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "sourceServer":
			err = unpopulate(val, &m.SourceServer)
			delete(rawMsg, key)
		case "sourceServerVersion":
			err = unpopulate(val, &m.SourceServerVersion)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "targetServer":
			err = unpopulate(val, &m.TargetServer)
			delete(rawMsg, key)
		case "targetServerVersion":
			err = unpopulate(val, &m.TargetServerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateOracleAzureDbPostgreSQLSyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateOracleAzureDbPostgreSQLSyncTaskOutputTableLevel struct {
	MigrateOracleAzureDbPostgreSQLSyncTaskOutput
	// READ-ONLY; Number of applied deletes
	CdcDeleteCounter *int64 `json:"cdcDeleteCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of applied inserts
	CdcInsertCounter *int64 `json:"cdcInsertCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of applied updates
	CdcUpdateCounter *int64 `json:"cdcUpdateCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of data errors occurred
	DataErrorsCounter *int64 `json:"dataErrorsCounter,omitempty" azure:"ro"`

	// READ-ONLY; Name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Full load end time
	FullLoadEndedOn *time.Time `json:"fullLoadEndedOn,omitempty" azure:"ro"`

	// READ-ONLY; Estimate to finish full load
	FullLoadEstFinishTime *time.Time `json:"fullLoadEstFinishTime,omitempty" azure:"ro"`

	// READ-ONLY; Full load start time
	FullLoadStartedOn *time.Time `json:"fullLoadStartedOn,omitempty" azure:"ro"`

	// READ-ONLY; Number of rows applied in full load
	FullLoadTotalRows *int64 `json:"fullLoadTotalRows,omitempty" azure:"ro"`

	// READ-ONLY; Last modified time on target
	LastModifiedTime *time.Time `json:"lastModifiedTime,omitempty" azure:"ro"`

	// READ-ONLY; Current state of the table migration
	State *SyncTableMigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Name of the table
	TableName *string `json:"tableName,omitempty" azure:"ro"`

	// READ-ONLY; Total number of applied changes
	TotalChangesApplied *int64 `json:"totalChangesApplied,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputTableLevel.
func (m MigrateOracleAzureDbPostgreSQLSyncTaskOutputTableLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateOracleAzureDbPostgreSQLSyncTaskOutput.marshalInternal(objectMap, "TableLevelOutput")
	populate(objectMap, "cdcDeleteCounter", m.CdcDeleteCounter)
	populate(objectMap, "cdcInsertCounter", m.CdcInsertCounter)
	populate(objectMap, "cdcUpdateCounter", m.CdcUpdateCounter)
	populate(objectMap, "dataErrorsCounter", m.DataErrorsCounter)
	populate(objectMap, "databaseName", m.DatabaseName)
	populate(objectMap, "fullLoadEndedOn", (*timeRFC3339)(m.FullLoadEndedOn))
	populate(objectMap, "fullLoadEstFinishTime", (*timeRFC3339)(m.FullLoadEstFinishTime))
	populate(objectMap, "fullLoadStartedOn", (*timeRFC3339)(m.FullLoadStartedOn))
	populate(objectMap, "fullLoadTotalRows", m.FullLoadTotalRows)
	populate(objectMap, "lastModifiedTime", (*timeRFC3339)(m.LastModifiedTime))
	populate(objectMap, "state", m.State)
	populate(objectMap, "tableName", m.TableName)
	populate(objectMap, "totalChangesApplied", m.TotalChangesApplied)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateOracleAzureDbPostgreSQLSyncTaskOutputTableLevel.
func (m *MigrateOracleAzureDbPostgreSQLSyncTaskOutputTableLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cdcDeleteCounter":
			err = unpopulate(val, &m.CdcDeleteCounter)
			delete(rawMsg, key)
		case "cdcInsertCounter":
			err = unpopulate(val, &m.CdcInsertCounter)
			delete(rawMsg, key)
		case "cdcUpdateCounter":
			err = unpopulate(val, &m.CdcUpdateCounter)
			delete(rawMsg, key)
		case "dataErrorsCounter":
			err = unpopulate(val, &m.DataErrorsCounter)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "fullLoadEndedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.FullLoadEndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "fullLoadEstFinishTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.FullLoadEstFinishTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "fullLoadStartedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.FullLoadStartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "fullLoadTotalRows":
			err = unpopulate(val, &m.FullLoadTotalRows)
			delete(rawMsg, key)
		case "lastModifiedTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.LastModifiedTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, &m.TableName)
			delete(rawMsg, key)
		case "totalChangesApplied":
			err = unpopulate(val, &m.TotalChangesApplied)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateOracleAzureDbPostgreSQLSyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigratePostgreSQLAzureDbForPostgreSQLSyncDatabaseInput - Database specific information for PostgreSQL to Azure Database for PostgreSQL migration task
// inputs
type MigratePostgreSQLAzureDbForPostgreSQLSyncDatabaseInput struct {
	// Migration settings which tune the migration behavior
	MigrationSetting map[string]*string `json:"migrationSetting,omitempty"`

	// Name of the database
	Name *string `json:"name,omitempty"`

	// Tables selected for migration
	SelectedTables []*MigratePostgreSQLAzureDbForPostgreSQLSyncDatabaseTableInput `json:"selectedTables,omitempty"`

	// Source settings to tune source endpoint migration behavior
	SourceSetting map[string]*string `json:"sourceSetting,omitempty"`

	// Name of target database. Note: Target database will be truncated before starting migration.
	TargetDatabaseName *string `json:"targetDatabaseName,omitempty"`

	// Target settings to tune target endpoint migration behavior
	TargetSetting map[string]*string `json:"targetSetting,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncDatabaseInput.
func (m MigratePostgreSQLAzureDbForPostgreSQLSyncDatabaseInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "migrationSetting", m.MigrationSetting)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "selectedTables", m.SelectedTables)
	populate(objectMap, "sourceSetting", m.SourceSetting)
	populate(objectMap, "targetDatabaseName", m.TargetDatabaseName)
	populate(objectMap, "targetSetting", m.TargetSetting)
	return json.Marshal(objectMap)
}

// MigratePostgreSQLAzureDbForPostgreSQLSyncDatabaseTableInput - Selected tables for the migration
type MigratePostgreSQLAzureDbForPostgreSQLSyncDatabaseTableInput struct {
	// Name of the table to migrate
	Name *string `json:"name,omitempty"`
}

// MigratePostgreSQLAzureDbForPostgreSQLSyncTaskInput - Input for the task that migrates PostgreSQL databases to Azure Database for PostgreSQL for online
// migrations
type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskInput struct {
	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigratePostgreSQLAzureDbForPostgreSQLSyncDatabaseInput `json:"selectedDatabases,omitempty"`

	// REQUIRED; Connection information for source PostgreSQL
	SourceConnectionInfo *PostgreSQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Connection information for target Azure Database for PostgreSQL
	TargetConnectionInfo *PostgreSQLConnectionInfo `json:"targetConnectionInfo,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskInput.
func (m MigratePostgreSQLAzureDbForPostgreSQLSyncTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "selectedDatabases", m.SelectedDatabases)
	populate(objectMap, "sourceConnectionInfo", m.SourceConnectionInfo)
	populate(objectMap, "targetConnectionInfo", m.TargetConnectionInfo)
	return json.Marshal(objectMap)
}

// MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput, *MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputDatabaseError,
// - *MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputDatabaseLevel, *MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputError,
// - *MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputMigrationLevel, *MigratePostgreSqlAzureDbForPostgreSqlSyncTaskOutputTableLevel
type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputClassification interface {
	// GetMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput returns the MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput content of the underlying type.
	GetMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput() *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput
}

// MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput - Output for the task that migrates PostgreSQL databases to Azure Database for PostgreSQL for online
// migrations
type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput implements the MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputClassification interface for
// type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput) GetMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput() *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput {
	return m
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return m.unmarshalInternal(rawMsg)
}

func (m MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput) marshalInternal(objectMap map[string]interface{}, discValue string) {
	populate(objectMap, "id", m.ID)
	m.ResultType = &discValue
	objectMap["resultType"] = m.ResultType
}

func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseError struct {
	MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput
	// Error message
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// List of error events.
	Events []*SyncMigrationDatabaseErrorEvent `json:"events,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseError.
func (m MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput.marshalInternal(objectMap, "DatabaseLevelErrorOutput")
	populate(objectMap, "errorMessage", m.ErrorMessage)
	populate(objectMap, "events", m.Events)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseError.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorMessage":
			err = unpopulate(val, &m.ErrorMessage)
			delete(rawMsg, key)
		case "events":
			err = unpopulate(val, &m.Events)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseLevel struct {
	MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput
	// READ-ONLY; Number of applied changes
	AppliedChanges *int64 `json:"appliedChanges,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc deletes
	CdcDeleteCounter *int64 `json:"cdcDeleteCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc inserts
	CdcInsertCounter *int64 `json:"cdcInsertCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc updates
	CdcUpdateCounter *int64 `json:"cdcUpdateCounter,omitempty" azure:"ro"`

	// READ-ONLY; Name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables completed in full load
	FullLoadCompletedTables *int64 `json:"fullLoadCompletedTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables errored in full load
	FullLoadErroredTables *int64 `json:"fullLoadErroredTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables loading in full load
	FullLoadLoadingTables *int64 `json:"fullLoadLoadingTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables queued in full load
	FullLoadQueuedTables *int64 `json:"fullLoadQueuedTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of incoming changes
	IncomingChanges *int64 `json:"incomingChanges,omitempty" azure:"ro"`

	// READ-ONLY; Indicates if initial load (full load) has been completed
	InitializationCompleted *bool `json:"initializationCompleted,omitempty" azure:"ro"`

	// READ-ONLY; CDC apply latency
	Latency *int64 `json:"latency,omitempty" azure:"ro"`

	// READ-ONLY; Migration state that this database is in
	MigrationState *SyncDatabaseMigrationReportingState `json:"migrationState,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseLevel.
func (m MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput.marshalInternal(objectMap, "DatabaseLevelOutput")
	populate(objectMap, "appliedChanges", m.AppliedChanges)
	populate(objectMap, "cdcDeleteCounter", m.CdcDeleteCounter)
	populate(objectMap, "cdcInsertCounter", m.CdcInsertCounter)
	populate(objectMap, "cdcUpdateCounter", m.CdcUpdateCounter)
	populate(objectMap, "databaseName", m.DatabaseName)
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "fullLoadCompletedTables", m.FullLoadCompletedTables)
	populate(objectMap, "fullLoadErroredTables", m.FullLoadErroredTables)
	populate(objectMap, "fullLoadLoadingTables", m.FullLoadLoadingTables)
	populate(objectMap, "fullLoadQueuedTables", m.FullLoadQueuedTables)
	populate(objectMap, "incomingChanges", m.IncomingChanges)
	populate(objectMap, "initializationCompleted", m.InitializationCompleted)
	populate(objectMap, "latency", m.Latency)
	populate(objectMap, "migrationState", m.MigrationState)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseLevel.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputDatabaseLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appliedChanges":
			err = unpopulate(val, &m.AppliedChanges)
			delete(rawMsg, key)
		case "cdcDeleteCounter":
			err = unpopulate(val, &m.CdcDeleteCounter)
			delete(rawMsg, key)
		case "cdcInsertCounter":
			err = unpopulate(val, &m.CdcInsertCounter)
			delete(rawMsg, key)
		case "cdcUpdateCounter":
			err = unpopulate(val, &m.CdcUpdateCounter)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "fullLoadCompletedTables":
			err = unpopulate(val, &m.FullLoadCompletedTables)
			delete(rawMsg, key)
		case "fullLoadErroredTables":
			err = unpopulate(val, &m.FullLoadErroredTables)
			delete(rawMsg, key)
		case "fullLoadLoadingTables":
			err = unpopulate(val, &m.FullLoadLoadingTables)
			delete(rawMsg, key)
		case "fullLoadQueuedTables":
			err = unpopulate(val, &m.FullLoadQueuedTables)
			delete(rawMsg, key)
		case "incomingChanges":
			err = unpopulate(val, &m.IncomingChanges)
			delete(rawMsg, key)
		case "initializationCompleted":
			err = unpopulate(val, &m.InitializationCompleted)
			delete(rawMsg, key)
		case "latency":
			err = unpopulate(val, &m.Latency)
			delete(rawMsg, key)
		case "migrationState":
			err = unpopulate(val, &m.MigrationState)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputError struct {
	MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput
	// READ-ONLY; Migration error
	Error *ReportableException `json:"error,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputError.
func (m MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput.marshalInternal(objectMap, "ErrorOutput")
	populate(objectMap, "error", m.Error)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputError.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &m.Error)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputMigrationLevel struct {
	MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput
	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Source server name
	SourceServer *string `json:"sourceServer,omitempty" azure:"ro"`

	// READ-ONLY; Source server type.
	SourceServerType *ScenarioSource `json:"sourceServerType,omitempty" azure:"ro"`

	// READ-ONLY; Source server version
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Migration status
	State *ReplicateMigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Target server name
	TargetServer *string `json:"targetServer,omitempty" azure:"ro"`

	// READ-ONLY; Target server type.
	TargetServerType *ScenarioTarget `json:"targetServerType,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputMigrationLevel.
func (m MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputMigrationLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput.marshalInternal(objectMap, "MigrationLevelOutput")
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "sourceServer", m.SourceServer)
	populate(objectMap, "sourceServerType", m.SourceServerType)
	populate(objectMap, "sourceServerVersion", m.SourceServerVersion)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	populate(objectMap, "state", m.State)
	populate(objectMap, "targetServer", m.TargetServer)
	populate(objectMap, "targetServerType", m.TargetServerType)
	populate(objectMap, "targetServerVersion", m.TargetServerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputMigrationLevel.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputMigrationLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "sourceServer":
			err = unpopulate(val, &m.SourceServer)
			delete(rawMsg, key)
		case "sourceServerType":
			err = unpopulate(val, &m.SourceServerType)
			delete(rawMsg, key)
		case "sourceServerVersion":
			err = unpopulate(val, &m.SourceServerVersion)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "targetServer":
			err = unpopulate(val, &m.TargetServer)
			delete(rawMsg, key)
		case "targetServerType":
			err = unpopulate(val, &m.TargetServerType)
			delete(rawMsg, key)
		case "targetServerVersion":
			err = unpopulate(val, &m.TargetServerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputTableLevel struct {
	MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput
	// READ-ONLY; Number of applied deletes
	CdcDeleteCounter *int64 `json:"cdcDeleteCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of applied inserts
	CdcInsertCounter *int64 `json:"cdcInsertCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of applied updates
	CdcUpdateCounter *int64 `json:"cdcUpdateCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of data errors occurred
	DataErrorsCounter *int64 `json:"dataErrorsCounter,omitempty" azure:"ro"`

	// READ-ONLY; Name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Full load end time
	FullLoadEndedOn *time.Time `json:"fullLoadEndedOn,omitempty" azure:"ro"`

	// READ-ONLY; Estimate to finish full load
	FullLoadEstFinishTime *time.Time `json:"fullLoadEstFinishTime,omitempty" azure:"ro"`

	// READ-ONLY; Full load start time
	FullLoadStartedOn *time.Time `json:"fullLoadStartedOn,omitempty" azure:"ro"`

	// READ-ONLY; Number of rows applied in full load
	FullLoadTotalRows *int64 `json:"fullLoadTotalRows,omitempty" azure:"ro"`

	// READ-ONLY; Last modified time on target
	LastModifiedTime *time.Time `json:"lastModifiedTime,omitempty" azure:"ro"`

	// READ-ONLY; Current state of the table migration
	State *SyncTableMigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Name of the table
	TableName *string `json:"tableName,omitempty" azure:"ro"`

	// READ-ONLY; Total number of applied changes
	TotalChangesApplied *int64 `json:"totalChangesApplied,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputTableLevel.
func (m MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputTableLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput.marshalInternal(objectMap, "TableLevelOutput")
	populate(objectMap, "cdcDeleteCounter", m.CdcDeleteCounter)
	populate(objectMap, "cdcInsertCounter", m.CdcInsertCounter)
	populate(objectMap, "cdcUpdateCounter", m.CdcUpdateCounter)
	populate(objectMap, "dataErrorsCounter", m.DataErrorsCounter)
	populate(objectMap, "databaseName", m.DatabaseName)
	populate(objectMap, "fullLoadEndedOn", (*timeRFC3339)(m.FullLoadEndedOn))
	populate(objectMap, "fullLoadEstFinishTime", (*timeRFC3339)(m.FullLoadEstFinishTime))
	populate(objectMap, "fullLoadStartedOn", (*timeRFC3339)(m.FullLoadStartedOn))
	populate(objectMap, "fullLoadTotalRows", m.FullLoadTotalRows)
	populate(objectMap, "lastModifiedTime", (*timeRFC3339)(m.LastModifiedTime))
	populate(objectMap, "state", m.State)
	populate(objectMap, "tableName", m.TableName)
	populate(objectMap, "totalChangesApplied", m.TotalChangesApplied)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputTableLevel.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputTableLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cdcDeleteCounter":
			err = unpopulate(val, &m.CdcDeleteCounter)
			delete(rawMsg, key)
		case "cdcInsertCounter":
			err = unpopulate(val, &m.CdcInsertCounter)
			delete(rawMsg, key)
		case "cdcUpdateCounter":
			err = unpopulate(val, &m.CdcUpdateCounter)
			delete(rawMsg, key)
		case "dataErrorsCounter":
			err = unpopulate(val, &m.DataErrorsCounter)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "fullLoadEndedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.FullLoadEndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "fullLoadEstFinishTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.FullLoadEstFinishTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "fullLoadStartedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.FullLoadStartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "fullLoadTotalRows":
			err = unpopulate(val, &m.FullLoadTotalRows)
			delete(rawMsg, key)
		case "lastModifiedTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.LastModifiedTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, &m.TableName)
			delete(rawMsg, key)
		case "totalChangesApplied":
			err = unpopulate(val, &m.TotalChangesApplied)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigratePostgreSQLAzureDbForPostgreSQLSyncTaskProperties - Properties for the task that migrates PostgreSQL databases to Azure Database for PostgreSQL
// for online migrations
type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []MigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputClassification `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskProperties.
func (m MigratePostgreSQLAzureDbForPostgreSQLSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ProjectTaskProperties.marshalInternal(objectMap, "Migrate.PostgreSql.AzureDbForPostgreSql.SyncV2")
	populate(objectMap, "input", m.Input)
	populate(objectMap, "output", m.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigratePostgreSQLAzureDbForPostgreSQLSyncTaskProperties.
func (m *MigratePostgreSQLAzureDbForPostgreSQLSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMigratePostgreSQLAzureDbForPostgreSQLSyncTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigrateSQLServerDatabaseInput - Database specific information for SQL to SQL migration task inputs
type MigrateSQLServerDatabaseInput struct {
	// The backup and restore folder
	BackupAndRestoreFolder *string `json:"backupAndRestoreFolder,omitempty"`

	// The list of database files
	DatabaseFiles []*DatabaseFileInput `json:"databaseFiles,omitempty"`

	// Name of the database
	Name *string `json:"name,omitempty"`

	// Name of the database at destination
	RestoreDatabaseName *string `json:"restoreDatabaseName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerDatabaseInput.
func (m MigrateSQLServerDatabaseInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupAndRestoreFolder", m.BackupAndRestoreFolder)
	populate(objectMap, "databaseFiles", m.DatabaseFiles)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "restoreDatabaseName", m.RestoreDatabaseName)
	return json.Marshal(objectMap)
}

// MigrateSQLServerSQLDbDatabaseInput - Database specific information for SQL to Azure SQL DB migration task inputs
type MigrateSQLServerSQLDbDatabaseInput struct {
	// Whether to set database read only before migration
	MakeSourceDbReadOnly *bool `json:"makeSourceDbReadOnly,omitempty"`

	// Name of the database
	Name *string `json:"name,omitempty"`

	// Mapping of source to target tables
	TableMap map[string]*string `json:"tableMap,omitempty"`

	// Name of target database. Note: Target database will be truncated before starting migration.
	TargetDatabaseName *string `json:"targetDatabaseName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbDatabaseInput.
func (m MigrateSQLServerSQLDbDatabaseInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "makeSourceDbReadOnly", m.MakeSourceDbReadOnly)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "tableMap", m.TableMap)
	populate(objectMap, "targetDatabaseName", m.TargetDatabaseName)
	return json.Marshal(objectMap)
}

// MigrateSQLServerSQLDbSyncDatabaseInput - Database specific information for SQL to Azure SQL DB sync migration task inputs
type MigrateSQLServerSQLDbSyncDatabaseInput struct {
	// Unique identifier for database
	ID *string `json:"id,omitempty"`

	// Migration settings which tune the migration behavior
	MigrationSetting map[string]*string `json:"migrationSetting,omitempty"`

	// Name of database
	Name *string `json:"name,omitempty"`

	// Schema name to be migrated
	SchemaName *string `json:"schemaName,omitempty"`

	// Source settings to tune source endpoint migration behavior
	SourceSetting map[string]*string `json:"sourceSetting,omitempty"`

	// Mapping of source to target tables
	TableMap map[string]*string `json:"tableMap,omitempty"`

	// Target database name
	TargetDatabaseName *string `json:"targetDatabaseName,omitempty"`

	// Target settings to tune target endpoint migration behavior
	TargetSetting map[string]*string `json:"targetSetting,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbSyncDatabaseInput.
func (m MigrateSQLServerSQLDbSyncDatabaseInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	populate(objectMap, "migrationSetting", m.MigrationSetting)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "schemaName", m.SchemaName)
	populate(objectMap, "sourceSetting", m.SourceSetting)
	populate(objectMap, "tableMap", m.TableMap)
	populate(objectMap, "targetDatabaseName", m.TargetDatabaseName)
	populate(objectMap, "targetSetting", m.TargetSetting)
	return json.Marshal(objectMap)
}

// MigrateSQLServerSQLDbSyncTaskInput - Input for the task that migrates on-prem SQL Server databases to Azure SQL Database for online migrations
type MigrateSQLServerSQLDbSyncTaskInput struct {
	SQLMigrationTaskInput
	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateSQLServerSQLDbSyncDatabaseInput `json:"selectedDatabases,omitempty"`

	// Validation options
	ValidationOptions *MigrationValidationOptions `json:"validationOptions,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbSyncTaskInput.
func (m MigrateSQLServerSQLDbSyncTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.SQLMigrationTaskInput.marshalInternal(objectMap)
	populate(objectMap, "selectedDatabases", m.SelectedDatabases)
	populate(objectMap, "validationOptions", m.ValidationOptions)
	return json.Marshal(objectMap)
}

// MigrateSQLServerSQLDbSyncTaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetMigrateSQLServerSQLDbSyncTaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MigrateSQLServerSQLDbSyncTaskOutput, *MigrateSqlServerSqlDbSyncTaskOutputDatabaseError, *MigrateSqlServerSqlDbSyncTaskOutputDatabaseLevel,
// - *MigrateSqlServerSqlDbSyncTaskOutputError, *MigrateSqlServerSqlDbSyncTaskOutputMigrationLevel, *MigrateSqlServerSqlDbSyncTaskOutputTableLevel
type MigrateSQLServerSQLDbSyncTaskOutputClassification interface {
	// GetMigrateSQLServerSQLDbSyncTaskOutput returns the MigrateSQLServerSQLDbSyncTaskOutput content of the underlying type.
	GetMigrateSQLServerSQLDbSyncTaskOutput() *MigrateSQLServerSQLDbSyncTaskOutput
}

// MigrateSQLServerSQLDbSyncTaskOutput - Output for the task that migrates on-prem SQL Server databases to Azure SQL Database for online migrations
type MigrateSQLServerSQLDbSyncTaskOutput struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLDbSyncTaskOutput implements the MigrateSQLServerSQLDbSyncTaskOutputClassification interface for type MigrateSQLServerSQLDbSyncTaskOutput.
func (m *MigrateSQLServerSQLDbSyncTaskOutput) GetMigrateSQLServerSQLDbSyncTaskOutput() *MigrateSQLServerSQLDbSyncTaskOutput {
	return m
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbSyncTaskOutput.
func (m *MigrateSQLServerSQLDbSyncTaskOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return m.unmarshalInternal(rawMsg)
}

func (m MigrateSQLServerSQLDbSyncTaskOutput) marshalInternal(objectMap map[string]interface{}, discValue string) {
	populate(objectMap, "id", m.ID)
	m.ResultType = &discValue
	objectMap["resultType"] = m.ResultType
}

func (m *MigrateSQLServerSQLDbSyncTaskOutput) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSQLServerSQLDbSyncTaskOutputDatabaseError struct {
	MigrateSQLServerSQLDbSyncTaskOutput
	// Error message
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// List of error events.
	Events []*SyncMigrationDatabaseErrorEvent `json:"events,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbSyncTaskOutputDatabaseError.
func (m MigrateSQLServerSQLDbSyncTaskOutputDatabaseError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSQLServerSQLDbSyncTaskOutput.marshalInternal(objectMap, "DatabaseLevelErrorOutput")
	populate(objectMap, "errorMessage", m.ErrorMessage)
	populate(objectMap, "events", m.Events)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbSyncTaskOutputDatabaseError.
func (m *MigrateSQLServerSQLDbSyncTaskOutputDatabaseError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "errorMessage":
			err = unpopulate(val, &m.ErrorMessage)
			delete(rawMsg, key)
		case "events":
			err = unpopulate(val, &m.Events)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSQLServerSQLDbSyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateSQLServerSQLDbSyncTaskOutputDatabaseLevel struct {
	MigrateSQLServerSQLDbSyncTaskOutput
	// READ-ONLY; Number of applied changes
	AppliedChanges *int64 `json:"appliedChanges,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc deletes
	CdcDeleteCounter *int64 `json:"cdcDeleteCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc inserts
	CdcInsertCounter *int64 `json:"cdcInsertCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of cdc updates
	CdcUpdateCounter *int64 `json:"cdcUpdateCounter,omitempty" azure:"ro"`

	// READ-ONLY; Name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables completed in full load
	FullLoadCompletedTables *int64 `json:"fullLoadCompletedTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables errored in full load
	FullLoadErroredTables *int64 `json:"fullLoadErroredTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables loading in full load
	FullLoadLoadingTables *int64 `json:"fullLoadLoadingTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of tables queued in full load
	FullLoadQueuedTables *int64 `json:"fullLoadQueuedTables,omitempty" azure:"ro"`

	// READ-ONLY; Number of incoming changes
	IncomingChanges *int64 `json:"incomingChanges,omitempty" azure:"ro"`

	// READ-ONLY; Indicates if initial load (full load) has been completed
	InitializationCompleted *bool `json:"initializationCompleted,omitempty" azure:"ro"`

	// READ-ONLY; CDC apply latency
	Latency *int64 `json:"latency,omitempty" azure:"ro"`

	// READ-ONLY; Migration state that this database is in
	MigrationState *SyncDatabaseMigrationReportingState `json:"migrationState,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbSyncTaskOutputDatabaseLevel.
func (m MigrateSQLServerSQLDbSyncTaskOutputDatabaseLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSQLServerSQLDbSyncTaskOutput.marshalInternal(objectMap, "DatabaseLevelOutput")
	populate(objectMap, "appliedChanges", m.AppliedChanges)
	populate(objectMap, "cdcDeleteCounter", m.CdcDeleteCounter)
	populate(objectMap, "cdcInsertCounter", m.CdcInsertCounter)
	populate(objectMap, "cdcUpdateCounter", m.CdcUpdateCounter)
	populate(objectMap, "databaseName", m.DatabaseName)
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "fullLoadCompletedTables", m.FullLoadCompletedTables)
	populate(objectMap, "fullLoadErroredTables", m.FullLoadErroredTables)
	populate(objectMap, "fullLoadLoadingTables", m.FullLoadLoadingTables)
	populate(objectMap, "fullLoadQueuedTables", m.FullLoadQueuedTables)
	populate(objectMap, "incomingChanges", m.IncomingChanges)
	populate(objectMap, "initializationCompleted", m.InitializationCompleted)
	populate(objectMap, "latency", m.Latency)
	populate(objectMap, "migrationState", m.MigrationState)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbSyncTaskOutputDatabaseLevel.
func (m *MigrateSQLServerSQLDbSyncTaskOutputDatabaseLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appliedChanges":
			err = unpopulate(val, &m.AppliedChanges)
			delete(rawMsg, key)
		case "cdcDeleteCounter":
			err = unpopulate(val, &m.CdcDeleteCounter)
			delete(rawMsg, key)
		case "cdcInsertCounter":
			err = unpopulate(val, &m.CdcInsertCounter)
			delete(rawMsg, key)
		case "cdcUpdateCounter":
			err = unpopulate(val, &m.CdcUpdateCounter)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "fullLoadCompletedTables":
			err = unpopulate(val, &m.FullLoadCompletedTables)
			delete(rawMsg, key)
		case "fullLoadErroredTables":
			err = unpopulate(val, &m.FullLoadErroredTables)
			delete(rawMsg, key)
		case "fullLoadLoadingTables":
			err = unpopulate(val, &m.FullLoadLoadingTables)
			delete(rawMsg, key)
		case "fullLoadQueuedTables":
			err = unpopulate(val, &m.FullLoadQueuedTables)
			delete(rawMsg, key)
		case "incomingChanges":
			err = unpopulate(val, &m.IncomingChanges)
			delete(rawMsg, key)
		case "initializationCompleted":
			err = unpopulate(val, &m.InitializationCompleted)
			delete(rawMsg, key)
		case "latency":
			err = unpopulate(val, &m.Latency)
			delete(rawMsg, key)
		case "migrationState":
			err = unpopulate(val, &m.MigrationState)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSQLServerSQLDbSyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateSQLServerSQLDbSyncTaskOutputError struct {
	MigrateSQLServerSQLDbSyncTaskOutput
	// READ-ONLY; Migration error
	Error *ReportableException `json:"error,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbSyncTaskOutputError.
func (m MigrateSQLServerSQLDbSyncTaskOutputError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSQLServerSQLDbSyncTaskOutput.marshalInternal(objectMap, "ErrorOutput")
	populate(objectMap, "error", m.Error)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbSyncTaskOutputError.
func (m *MigrateSQLServerSQLDbSyncTaskOutputError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &m.Error)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSQLServerSQLDbSyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateSQLServerSQLDbSyncTaskOutputMigrationLevel struct {
	MigrateSQLServerSQLDbSyncTaskOutput
	// READ-ONLY; Count of databases
	DatabaseCount *int32 `json:"databaseCount,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Source server name
	SourceServer *string `json:"sourceServer,omitempty" azure:"ro"`

	// READ-ONLY; Source server version
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Target server name
	TargetServer *string `json:"targetServer,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbSyncTaskOutputMigrationLevel.
func (m MigrateSQLServerSQLDbSyncTaskOutputMigrationLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSQLServerSQLDbSyncTaskOutput.marshalInternal(objectMap, "MigrationLevelOutput")
	populate(objectMap, "databaseCount", m.DatabaseCount)
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "sourceServer", m.SourceServer)
	populate(objectMap, "sourceServerVersion", m.SourceServerVersion)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	populate(objectMap, "targetServer", m.TargetServer)
	populate(objectMap, "targetServerVersion", m.TargetServerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbSyncTaskOutputMigrationLevel.
func (m *MigrateSQLServerSQLDbSyncTaskOutputMigrationLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databaseCount":
			err = unpopulate(val, &m.DatabaseCount)
			delete(rawMsg, key)
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "sourceServer":
			err = unpopulate(val, &m.SourceServer)
			delete(rawMsg, key)
		case "sourceServerVersion":
			err = unpopulate(val, &m.SourceServerVersion)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "targetServer":
			err = unpopulate(val, &m.TargetServer)
			delete(rawMsg, key)
		case "targetServerVersion":
			err = unpopulate(val, &m.TargetServerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSQLServerSQLDbSyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateSQLServerSQLDbSyncTaskOutputTableLevel struct {
	MigrateSQLServerSQLDbSyncTaskOutput
	// READ-ONLY; Number of applied deletes
	CdcDeleteCounter *int64 `json:"cdcDeleteCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of applied inserts
	CdcInsertCounter *int64 `json:"cdcInsertCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of applied updates
	CdcUpdateCounter *int64 `json:"cdcUpdateCounter,omitempty" azure:"ro"`

	// READ-ONLY; Number of data errors occurred
	DataErrorsCounter *int64 `json:"dataErrorsCounter,omitempty" azure:"ro"`

	// READ-ONLY; Name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Full load end time
	FullLoadEndedOn *time.Time `json:"fullLoadEndedOn,omitempty" azure:"ro"`

	// READ-ONLY; Estimate to finish full load
	FullLoadEstFinishTime *time.Time `json:"fullLoadEstFinishTime,omitempty" azure:"ro"`

	// READ-ONLY; Full load start time
	FullLoadStartedOn *time.Time `json:"fullLoadStartedOn,omitempty" azure:"ro"`

	// READ-ONLY; Number of rows applied in full load
	FullLoadTotalRows *int64 `json:"fullLoadTotalRows,omitempty" azure:"ro"`

	// READ-ONLY; Last modified time on target
	LastModifiedTime *time.Time `json:"lastModifiedTime,omitempty" azure:"ro"`

	// READ-ONLY; Current state of the table migration
	State *SyncTableMigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Name of the table
	TableName *string `json:"tableName,omitempty" azure:"ro"`

	// READ-ONLY; Total number of applied changes
	TotalChangesApplied *int64 `json:"totalChangesApplied,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbSyncTaskOutputTableLevel.
func (m MigrateSQLServerSQLDbSyncTaskOutputTableLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSQLServerSQLDbSyncTaskOutput.marshalInternal(objectMap, "TableLevelOutput")
	populate(objectMap, "cdcDeleteCounter", m.CdcDeleteCounter)
	populate(objectMap, "cdcInsertCounter", m.CdcInsertCounter)
	populate(objectMap, "cdcUpdateCounter", m.CdcUpdateCounter)
	populate(objectMap, "dataErrorsCounter", m.DataErrorsCounter)
	populate(objectMap, "databaseName", m.DatabaseName)
	populate(objectMap, "fullLoadEndedOn", (*timeRFC3339)(m.FullLoadEndedOn))
	populate(objectMap, "fullLoadEstFinishTime", (*timeRFC3339)(m.FullLoadEstFinishTime))
	populate(objectMap, "fullLoadStartedOn", (*timeRFC3339)(m.FullLoadStartedOn))
	populate(objectMap, "fullLoadTotalRows", m.FullLoadTotalRows)
	populate(objectMap, "lastModifiedTime", (*timeRFC3339)(m.LastModifiedTime))
	populate(objectMap, "state", m.State)
	populate(objectMap, "tableName", m.TableName)
	populate(objectMap, "totalChangesApplied", m.TotalChangesApplied)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbSyncTaskOutputTableLevel.
func (m *MigrateSQLServerSQLDbSyncTaskOutputTableLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cdcDeleteCounter":
			err = unpopulate(val, &m.CdcDeleteCounter)
			delete(rawMsg, key)
		case "cdcInsertCounter":
			err = unpopulate(val, &m.CdcInsertCounter)
			delete(rawMsg, key)
		case "cdcUpdateCounter":
			err = unpopulate(val, &m.CdcUpdateCounter)
			delete(rawMsg, key)
		case "dataErrorsCounter":
			err = unpopulate(val, &m.DataErrorsCounter)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "fullLoadEndedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.FullLoadEndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "fullLoadEstFinishTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.FullLoadEstFinishTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "fullLoadStartedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.FullLoadStartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "fullLoadTotalRows":
			err = unpopulate(val, &m.FullLoadTotalRows)
			delete(rawMsg, key)
		case "lastModifiedTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.LastModifiedTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "tableName":
			err = unpopulate(val, &m.TableName)
			delete(rawMsg, key)
		case "totalChangesApplied":
			err = unpopulate(val, &m.TotalChangesApplied)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSQLServerSQLDbSyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigrateSQLServerSQLDbSyncTaskProperties - Properties for the task that migrates on-prem SQL Server databases to Azure SQL Database for online migrations
type MigrateSQLServerSQLDbSyncTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *MigrateSQLServerSQLDbSyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []MigrateSQLServerSQLDbSyncTaskOutputClassification `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbSyncTaskProperties.
func (m MigrateSQLServerSQLDbSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ProjectTaskProperties.marshalInternal(objectMap, "Migrate.SqlServer.AzureSqlDb.Sync")
	populate(objectMap, "input", m.Input)
	populate(objectMap, "output", m.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbSyncTaskProperties.
func (m *MigrateSQLServerSQLDbSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMigrateSQLServerSQLDbSyncTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigrateSQLServerSQLDbTaskInput - Input for the task that migrates on-prem SQL Server databases to Azure SQL Database
type MigrateSQLServerSQLDbTaskInput struct {
	SQLMigrationTaskInput
	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateSQLServerSQLDbDatabaseInput `json:"selectedDatabases,omitempty"`

	// Options for enabling various post migration validations. Available options, 1.) Data Integrity Check: Performs a checksum based comparison on source
	// and target tables after the migration to ensure the
	// correctness of the data. 2.) Schema Validation: Performs a thorough schema comparison between the source and target tables and provides a list of differences
	// between the source and target database,
	// 3.) Query Analysis: Executes a set of queries picked up automatically either from the Query Plan Cache or Query Store and execute them and compares the
	// execution time between the source and target
	// database.
	ValidationOptions *MigrationValidationOptions `json:"validationOptions,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbTaskInput.
func (m MigrateSQLServerSQLDbTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.SQLMigrationTaskInput.marshalInternal(objectMap)
	populate(objectMap, "selectedDatabases", m.SelectedDatabases)
	populate(objectMap, "validationOptions", m.ValidationOptions)
	return json.Marshal(objectMap)
}

// MigrateSQLServerSQLDbTaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetMigrateSQLServerSQLDbTaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MigrateSQLServerSQLDbTaskOutput, *MigrateSqlServerSqlDbTaskOutputDatabaseLevel, *MigrateSqlServerSqlDbTaskOutputDatabaseLevelValidationResult,
// - *MigrateSqlServerSqlDbTaskOutputError, *MigrateSqlServerSqlDbTaskOutputMigrationLevel, *MigrateSqlServerSqlDbTaskOutputTableLevel,
// - *MigrateSqlServerSqlDbTaskOutputValidationResult
type MigrateSQLServerSQLDbTaskOutputClassification interface {
	// GetMigrateSQLServerSQLDbTaskOutput returns the MigrateSQLServerSQLDbTaskOutput content of the underlying type.
	GetMigrateSQLServerSQLDbTaskOutput() *MigrateSQLServerSQLDbTaskOutput
}

// MigrateSQLServerSQLDbTaskOutput - Output for the task that migrates on-prem SQL Server databases to Azure SQL Database
type MigrateSQLServerSQLDbTaskOutput struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLDbTaskOutput implements the MigrateSQLServerSQLDbTaskOutputClassification interface for type MigrateSQLServerSQLDbTaskOutput.
func (m *MigrateSQLServerSQLDbTaskOutput) GetMigrateSQLServerSQLDbTaskOutput() *MigrateSQLServerSQLDbTaskOutput {
	return m
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbTaskOutput.
func (m *MigrateSQLServerSQLDbTaskOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return m.unmarshalInternal(rawMsg)
}

func (m MigrateSQLServerSQLDbTaskOutput) marshalInternal(objectMap map[string]interface{}, discValue string) {
	populate(objectMap, "id", m.ID)
	m.ResultType = &discValue
	objectMap["resultType"] = m.ResultType
}

func (m *MigrateSQLServerSQLDbTaskOutput) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSQLServerSQLDbTaskOutputDatabaseLevel struct {
	MigrateSQLServerSQLDbTaskOutput
	// READ-ONLY; Name of the item
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Number of database/object errors.
	ErrorCount *int64 `json:"errorCount,omitempty" azure:"ro"`

	// READ-ONLY; Wildcard string prefix to use for querying all errors of the item
	ErrorPrefix *string `json:"errorPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Migration exceptions and warnings.
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; Migration progress message
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Number of objects
	NumberOfObjects *int64 `json:"numberOfObjects,omitempty" azure:"ro"`

	// READ-ONLY; Number of successfully completed objects
	NumberOfObjectsCompleted *int64 `json:"numberOfObjectsCompleted,omitempty" azure:"ro"`

	// READ-ONLY; Summary of object results in the migration
	ObjectSummary *string `json:"objectSummary,omitempty" azure:"ro"`

	// READ-ONLY; Wildcard string prefix to use for querying all sub-tem results of the item
	ResultPrefix *string `json:"resultPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Migration stage that this database is in
	Stage *DatabaseMigrationStage `json:"stage,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Status message
	StatusMessage *string `json:"statusMessage,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbTaskOutputDatabaseLevel.
func (m MigrateSQLServerSQLDbTaskOutputDatabaseLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSQLServerSQLDbTaskOutput.marshalInternal(objectMap, "DatabaseLevelOutput")
	populate(objectMap, "databaseName", m.DatabaseName)
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "errorCount", m.ErrorCount)
	populate(objectMap, "errorPrefix", m.ErrorPrefix)
	populate(objectMap, "exceptionsAndWarnings", m.ExceptionsAndWarnings)
	populate(objectMap, "message", m.Message)
	populate(objectMap, "numberOfObjects", m.NumberOfObjects)
	populate(objectMap, "numberOfObjectsCompleted", m.NumberOfObjectsCompleted)
	populate(objectMap, "objectSummary", m.ObjectSummary)
	populate(objectMap, "resultPrefix", m.ResultPrefix)
	populate(objectMap, "stage", m.Stage)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	populate(objectMap, "state", m.State)
	populate(objectMap, "statusMessage", m.StatusMessage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbTaskOutputDatabaseLevel.
func (m *MigrateSQLServerSQLDbTaskOutputDatabaseLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "errorCount":
			err = unpopulate(val, &m.ErrorCount)
			delete(rawMsg, key)
		case "errorPrefix":
			err = unpopulate(val, &m.ErrorPrefix)
			delete(rawMsg, key)
		case "exceptionsAndWarnings":
			err = unpopulate(val, &m.ExceptionsAndWarnings)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &m.Message)
			delete(rawMsg, key)
		case "numberOfObjects":
			err = unpopulate(val, &m.NumberOfObjects)
			delete(rawMsg, key)
		case "numberOfObjectsCompleted":
			err = unpopulate(val, &m.NumberOfObjectsCompleted)
			delete(rawMsg, key)
		case "objectSummary":
			err = unpopulate(val, &m.ObjectSummary)
			delete(rawMsg, key)
		case "resultPrefix":
			err = unpopulate(val, &m.ResultPrefix)
			delete(rawMsg, key)
		case "stage":
			err = unpopulate(val, &m.Stage)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "statusMessage":
			err = unpopulate(val, &m.StatusMessage)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSQLServerSQLDbTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateSQLServerSQLDbTaskOutputDatabaseLevelValidationResult struct {
	MigrateSQLServerSQLDbTaskOutput
	MigrationValidationDatabaseLevelResult
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbTaskOutputDatabaseLevelValidationResult.
func (m MigrateSQLServerSQLDbTaskOutputDatabaseLevelValidationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSQLServerSQLDbTaskOutput.marshalInternal(objectMap, "MigrationDatabaseLevelValidationOutput")
	m.MigrationValidationDatabaseLevelResult.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

type MigrateSQLServerSQLDbTaskOutputError struct {
	MigrateSQLServerSQLDbTaskOutput
	// READ-ONLY; Migration error
	Error *ReportableException `json:"error,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbTaskOutputError.
func (m MigrateSQLServerSQLDbTaskOutputError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSQLServerSQLDbTaskOutput.marshalInternal(objectMap, "ErrorOutput")
	populate(objectMap, "error", m.Error)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbTaskOutputError.
func (m *MigrateSQLServerSQLDbTaskOutputError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &m.Error)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSQLServerSQLDbTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateSQLServerSQLDbTaskOutputMigrationLevel struct {
	MigrateSQLServerSQLDbTaskOutput
	// Migration Report Result, provides unique url for downloading your migration report.
	MigrationReportResult *MigrationReportResult `json:"migrationReportResult,omitempty"`

	// Migration Validation Results
	MigrationValidationResult *MigrationValidationResult `json:"migrationValidationResult,omitempty"`

	// READ-ONLY; Summary of database results in the migration
	DatabaseSummary *string `json:"databaseSummary,omitempty" azure:"ro"`

	// READ-ONLY; Selected databases as a map from database name to database id
	Databases *string `json:"databases,omitempty" azure:"ro"`

	// READ-ONLY; Duration of task execution in seconds.
	DurationInSeconds *int64 `json:"durationInSeconds,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Migration exceptions and warnings.
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; Migration progress message
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Source server brand version
	SourceServerBrandVersion *string `json:"sourceServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Source server version
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current status of migration
	Status *MigrationStatus `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; Migration status message
	StatusMessage *string `json:"statusMessage,omitempty" azure:"ro"`

	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbTaskOutputMigrationLevel.
func (m MigrateSQLServerSQLDbTaskOutputMigrationLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSQLServerSQLDbTaskOutput.marshalInternal(objectMap, "MigrationLevelOutput")
	populate(objectMap, "databaseSummary", m.DatabaseSummary)
	populate(objectMap, "databases", m.Databases)
	populate(objectMap, "durationInSeconds", m.DurationInSeconds)
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "exceptionsAndWarnings", m.ExceptionsAndWarnings)
	populate(objectMap, "message", m.Message)
	populate(objectMap, "migrationReportResult", m.MigrationReportResult)
	populate(objectMap, "migrationValidationResult", m.MigrationValidationResult)
	populate(objectMap, "sourceServerBrandVersion", m.SourceServerBrandVersion)
	populate(objectMap, "sourceServerVersion", m.SourceServerVersion)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	populate(objectMap, "status", m.Status)
	populate(objectMap, "statusMessage", m.StatusMessage)
	populate(objectMap, "targetServerBrandVersion", m.TargetServerBrandVersion)
	populate(objectMap, "targetServerVersion", m.TargetServerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbTaskOutputMigrationLevel.
func (m *MigrateSQLServerSQLDbTaskOutputMigrationLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databaseSummary":
			err = unpopulate(val, &m.DatabaseSummary)
			delete(rawMsg, key)
		case "databases":
			err = unpopulate(val, &m.Databases)
			delete(rawMsg, key)
		case "durationInSeconds":
			err = unpopulate(val, &m.DurationInSeconds)
			delete(rawMsg, key)
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "exceptionsAndWarnings":
			err = unpopulate(val, &m.ExceptionsAndWarnings)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &m.Message)
			delete(rawMsg, key)
		case "migrationReportResult":
			err = unpopulate(val, &m.MigrationReportResult)
			delete(rawMsg, key)
		case "migrationValidationResult":
			err = unpopulate(val, &m.MigrationValidationResult)
			delete(rawMsg, key)
		case "sourceServerBrandVersion":
			err = unpopulate(val, &m.SourceServerBrandVersion)
			delete(rawMsg, key)
		case "sourceServerVersion":
			err = unpopulate(val, &m.SourceServerVersion)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &m.Status)
			delete(rawMsg, key)
		case "statusMessage":
			err = unpopulate(val, &m.StatusMessage)
			delete(rawMsg, key)
		case "targetServerBrandVersion":
			err = unpopulate(val, &m.TargetServerBrandVersion)
			delete(rawMsg, key)
		case "targetServerVersion":
			err = unpopulate(val, &m.TargetServerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSQLServerSQLDbTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateSQLServerSQLDbTaskOutputTableLevel struct {
	MigrateSQLServerSQLDbTaskOutput
	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Wildcard string prefix to use for querying all errors of the item
	ErrorPrefix *string `json:"errorPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Number of successfully completed items
	ItemsCompletedCount *int64 `json:"itemsCompletedCount,omitempty" azure:"ro"`

	// READ-ONLY; Number of items
	ItemsCount *int64 `json:"itemsCount,omitempty" azure:"ro"`

	// READ-ONLY; Name of the item
	ObjectName *string `json:"objectName,omitempty" azure:"ro"`

	// READ-ONLY; Wildcard string prefix to use for querying all sub-tem results of the item
	ResultPrefix *string `json:"resultPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Status message
	StatusMessage *string `json:"statusMessage,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbTaskOutputTableLevel.
func (m MigrateSQLServerSQLDbTaskOutputTableLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSQLServerSQLDbTaskOutput.marshalInternal(objectMap, "TableLevelOutput")
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "errorPrefix", m.ErrorPrefix)
	populate(objectMap, "itemsCompletedCount", m.ItemsCompletedCount)
	populate(objectMap, "itemsCount", m.ItemsCount)
	populate(objectMap, "objectName", m.ObjectName)
	populate(objectMap, "resultPrefix", m.ResultPrefix)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	populate(objectMap, "state", m.State)
	populate(objectMap, "statusMessage", m.StatusMessage)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbTaskOutputTableLevel.
func (m *MigrateSQLServerSQLDbTaskOutputTableLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "errorPrefix":
			err = unpopulate(val, &m.ErrorPrefix)
			delete(rawMsg, key)
		case "itemsCompletedCount":
			err = unpopulate(val, &m.ItemsCompletedCount)
			delete(rawMsg, key)
		case "itemsCount":
			err = unpopulate(val, &m.ItemsCount)
			delete(rawMsg, key)
		case "objectName":
			err = unpopulate(val, &m.ObjectName)
			delete(rawMsg, key)
		case "resultPrefix":
			err = unpopulate(val, &m.ResultPrefix)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "statusMessage":
			err = unpopulate(val, &m.StatusMessage)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSQLServerSQLDbTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateSQLServerSQLDbTaskOutputValidationResult struct {
	MigrateSQLServerSQLDbTaskOutput
	MigrationValidationResult
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbTaskOutputValidationResult.
func (m MigrateSQLServerSQLDbTaskOutputValidationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSQLServerSQLDbTaskOutput.marshalInternal(objectMap, "MigrationValidationOutput")
	m.MigrationValidationResult.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// MigrateSQLServerSQLDbTaskProperties - Properties for the task that migrates on-prem SQL Server databases to Azure SQL Database
type MigrateSQLServerSQLDbTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *MigrateSQLServerSQLDbTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []MigrateSQLServerSQLDbTaskOutputClassification `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLDbTaskProperties.
func (m MigrateSQLServerSQLDbTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ProjectTaskProperties.marshalInternal(objectMap, "Migrate.SqlServer.SqlDb")
	populate(objectMap, "input", m.Input)
	populate(objectMap, "output", m.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLDbTaskProperties.
func (m *MigrateSQLServerSQLDbTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMigrateSQLServerSQLDbTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigrateSQLServerSQLMIDatabaseInput - Database specific information for SQL to Azure SQL DB Managed Instance migration task inputs
type MigrateSQLServerSQLMIDatabaseInput struct {
	// REQUIRED; Name of the database
	Name *string `json:"name,omitempty"`

	// REQUIRED; Name of the database at destination
	RestoreDatabaseName *string `json:"restoreDatabaseName,omitempty"`

	// The list of backup files to be used in case of existing backups.
	BackupFilePaths []*string `json:"backupFilePaths,omitempty"`

	// Backup file share information for backing up this database.
	BackupFileShare *FileShare `json:"backupFileShare,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMIDatabaseInput.
func (m MigrateSQLServerSQLMIDatabaseInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupFilePaths", m.BackupFilePaths)
	populate(objectMap, "backupFileShare", m.BackupFileShare)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "restoreDatabaseName", m.RestoreDatabaseName)
	return json.Marshal(objectMap)
}

// MigrateSQLServerSQLMISyncTaskInput - Input for task that migrates SQL Server databases to Azure SQL Database Managed Instance online scenario.
type MigrateSQLServerSQLMISyncTaskInput struct {
	SQLServerSQLMISyncTaskInput
}

// MigrateSQLServerSQLMISyncTaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetMigrateSQLServerSQLMISyncTaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MigrateSQLServerSQLMISyncTaskOutput, *MigrateSqlServerSqlMISyncTaskOutputDatabaseLevel, *MigrateSqlServerSqlMISyncTaskOutputError,
// - *MigrateSqlServerSqlMISyncTaskOutputMigrationLevel
type MigrateSQLServerSQLMISyncTaskOutputClassification interface {
	// GetMigrateSQLServerSQLMISyncTaskOutput returns the MigrateSQLServerSQLMISyncTaskOutput content of the underlying type.
	GetMigrateSQLServerSQLMISyncTaskOutput() *MigrateSQLServerSQLMISyncTaskOutput
}

// MigrateSQLServerSQLMISyncTaskOutput - Output for task that migrates SQL Server databases to Azure SQL Database Managed Instance using Log Replay Service.
type MigrateSQLServerSQLMISyncTaskOutput struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLMISyncTaskOutput implements the MigrateSQLServerSQLMISyncTaskOutputClassification interface for type MigrateSQLServerSQLMISyncTaskOutput.
func (m *MigrateSQLServerSQLMISyncTaskOutput) GetMigrateSQLServerSQLMISyncTaskOutput() *MigrateSQLServerSQLMISyncTaskOutput {
	return m
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMISyncTaskOutput.
func (m *MigrateSQLServerSQLMISyncTaskOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return m.unmarshalInternal(rawMsg)
}

func (m MigrateSQLServerSQLMISyncTaskOutput) marshalInternal(objectMap map[string]interface{}, discValue string) {
	populate(objectMap, "id", m.ID)
	m.ResultType = &discValue
	objectMap["resultType"] = m.ResultType
}

func (m *MigrateSQLServerSQLMISyncTaskOutput) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSQLServerSQLMISyncTaskOutputDatabaseLevel struct {
	MigrateSQLServerSQLMISyncTaskOutput
	// READ-ONLY; Backup sets that are currently active (Either being uploaded or getting restored)
	ActiveBackupSets []*BackupSetInfo `json:"activeBackupSets,omitempty" azure:"ro"`

	// READ-ONLY; Name of container created in the Azure Storage account where backups are copied to
	ContainerName *string `json:"containerName,omitempty" azure:"ro"`

	// READ-ONLY; Database migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; prefix string to use for querying errors for this database
	ErrorPrefix *string `json:"errorPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Migration exceptions and warnings
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; Details of full backup set
	FullBackupSetInfo *BackupSetInfo `json:"fullBackupSetInfo,omitempty" azure:"ro"`

	// READ-ONLY; Whether full backup has been applied to the target database or not
	IsFullBackupRestored *bool `json:"isFullBackupRestored,omitempty" azure:"ro"`

	// READ-ONLY; Last applied backup set information
	LastRestoredBackupSetInfo *BackupSetInfo `json:"lastRestoredBackupSetInfo,omitempty" azure:"ro"`

	// READ-ONLY; Current state of database
	MigrationState *DatabaseMigrationState `json:"migrationState,omitempty" azure:"ro"`

	// READ-ONLY; Name of the database
	SourceDatabaseName *string `json:"sourceDatabaseName,omitempty" azure:"ro"`

	// READ-ONLY; Database migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMISyncTaskOutputDatabaseLevel.
func (m MigrateSQLServerSQLMISyncTaskOutputDatabaseLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSQLServerSQLMISyncTaskOutput.marshalInternal(objectMap, "DatabaseLevelOutput")
	populate(objectMap, "activeBackupSets", m.ActiveBackupSets)
	populate(objectMap, "containerName", m.ContainerName)
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "errorPrefix", m.ErrorPrefix)
	populate(objectMap, "exceptionsAndWarnings", m.ExceptionsAndWarnings)
	populate(objectMap, "fullBackupSetInfo", m.FullBackupSetInfo)
	populate(objectMap, "isFullBackupRestored", m.IsFullBackupRestored)
	populate(objectMap, "lastRestoredBackupSetInfo", m.LastRestoredBackupSetInfo)
	populate(objectMap, "migrationState", m.MigrationState)
	populate(objectMap, "sourceDatabaseName", m.SourceDatabaseName)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMISyncTaskOutputDatabaseLevel.
func (m *MigrateSQLServerSQLMISyncTaskOutputDatabaseLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activeBackupSets":
			err = unpopulate(val, &m.ActiveBackupSets)
			delete(rawMsg, key)
		case "containerName":
			err = unpopulate(val, &m.ContainerName)
			delete(rawMsg, key)
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "errorPrefix":
			err = unpopulate(val, &m.ErrorPrefix)
			delete(rawMsg, key)
		case "exceptionsAndWarnings":
			err = unpopulate(val, &m.ExceptionsAndWarnings)
			delete(rawMsg, key)
		case "fullBackupSetInfo":
			err = unpopulate(val, &m.FullBackupSetInfo)
			delete(rawMsg, key)
		case "isFullBackupRestored":
			err = unpopulate(val, &m.IsFullBackupRestored)
			delete(rawMsg, key)
		case "lastRestoredBackupSetInfo":
			err = unpopulate(val, &m.LastRestoredBackupSetInfo)
			delete(rawMsg, key)
		case "migrationState":
			err = unpopulate(val, &m.MigrationState)
			delete(rawMsg, key)
		case "sourceDatabaseName":
			err = unpopulate(val, &m.SourceDatabaseName)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSQLServerSQLMISyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateSQLServerSQLMISyncTaskOutputError struct {
	MigrateSQLServerSQLMISyncTaskOutput
	// READ-ONLY; Migration error
	Error *ReportableException `json:"error,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMISyncTaskOutputError.
func (m MigrateSQLServerSQLMISyncTaskOutputError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSQLServerSQLMISyncTaskOutput.marshalInternal(objectMap, "ErrorOutput")
	populate(objectMap, "error", m.Error)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMISyncTaskOutputError.
func (m *MigrateSQLServerSQLMISyncTaskOutputError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &m.Error)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSQLServerSQLMISyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateSQLServerSQLMISyncTaskOutputMigrationLevel struct {
	MigrateSQLServerSQLMISyncTaskOutput
	// READ-ONLY; Count of databases
	DatabaseCount *int32 `json:"databaseCount,omitempty" azure:"ro"`

	// READ-ONLY; Number of database level errors
	DatabaseErrorCount *int32 `json:"databaseErrorCount,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Source server brand version
	SourceServerBrandVersion *string `json:"sourceServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Source server name
	SourceServerName *string `json:"sourceServerName,omitempty" azure:"ro"`

	// READ-ONLY; Source server version
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Target server name
	TargetServerName *string `json:"targetServerName,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMISyncTaskOutputMigrationLevel.
func (m MigrateSQLServerSQLMISyncTaskOutputMigrationLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSQLServerSQLMISyncTaskOutput.marshalInternal(objectMap, "MigrationLevelOutput")
	populate(objectMap, "databaseCount", m.DatabaseCount)
	populate(objectMap, "databaseErrorCount", m.DatabaseErrorCount)
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "sourceServerBrandVersion", m.SourceServerBrandVersion)
	populate(objectMap, "sourceServerName", m.SourceServerName)
	populate(objectMap, "sourceServerVersion", m.SourceServerVersion)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	populate(objectMap, "state", m.State)
	populate(objectMap, "targetServerBrandVersion", m.TargetServerBrandVersion)
	populate(objectMap, "targetServerName", m.TargetServerName)
	populate(objectMap, "targetServerVersion", m.TargetServerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMISyncTaskOutputMigrationLevel.
func (m *MigrateSQLServerSQLMISyncTaskOutputMigrationLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databaseCount":
			err = unpopulate(val, &m.DatabaseCount)
			delete(rawMsg, key)
		case "databaseErrorCount":
			err = unpopulate(val, &m.DatabaseErrorCount)
			delete(rawMsg, key)
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "sourceServerBrandVersion":
			err = unpopulate(val, &m.SourceServerBrandVersion)
			delete(rawMsg, key)
		case "sourceServerName":
			err = unpopulate(val, &m.SourceServerName)
			delete(rawMsg, key)
		case "sourceServerVersion":
			err = unpopulate(val, &m.SourceServerVersion)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "targetServerBrandVersion":
			err = unpopulate(val, &m.TargetServerBrandVersion)
			delete(rawMsg, key)
		case "targetServerName":
			err = unpopulate(val, &m.TargetServerName)
			delete(rawMsg, key)
		case "targetServerVersion":
			err = unpopulate(val, &m.TargetServerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSQLServerSQLMISyncTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigrateSQLServerSQLMISyncTaskProperties - Properties for task that migrates SQL Server databases to Azure SQL Database Managed Instance sync scenario
type MigrateSQLServerSQLMISyncTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *MigrateSQLServerSQLMISyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []MigrateSQLServerSQLMISyncTaskOutputClassification `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMISyncTaskProperties.
func (m MigrateSQLServerSQLMISyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ProjectTaskProperties.marshalInternal(objectMap, "Migrate.SqlServer.AzureSqlDbMI.Sync.LRS")
	populate(objectMap, "input", m.Input)
	populate(objectMap, "output", m.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMISyncTaskProperties.
func (m *MigrateSQLServerSQLMISyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMigrateSQLServerSQLMISyncTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigrateSQLServerSQLMITaskInput - Input for task that migrates SQL Server databases to Azure SQL Database Managed Instance.
type MigrateSQLServerSQLMITaskInput struct {
	SQLMigrationTaskInput
	// REQUIRED; SAS URI of Azure Storage Account Container to be used for storing backup files.
	BackupBlobShare *BlobShare `json:"backupBlobShare,omitempty"`

	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateSQLServerSQLMIDatabaseInput `json:"selectedDatabases,omitempty"`

	// Azure Active Directory domain name in the format of 'contoso.com' for federated Azure AD or 'contoso.onmicrosoft.com' for managed domain, required if
	// and only if Windows logins are selected
	AADDomainName *string `json:"aadDomainName,omitempty"`

	// Backup file share information for all selected databases.
	BackupFileShare *FileShare `json:"backupFileShare,omitempty"`

	// Backup Mode to specify whether to use existing backup or create new backup. If using existing backups, backup file paths are required to be provided
	// in selectedDatabases.
	BackupMode *BackupMode `json:"backupMode,omitempty"`

	// Agent Jobs to migrate.
	SelectedAgentJobs []*string `json:"selectedAgentJobs,omitempty"`

	// Logins to migrate.
	SelectedLogins []*string `json:"selectedLogins,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMITaskInput.
func (m MigrateSQLServerSQLMITaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.SQLMigrationTaskInput.marshalInternal(objectMap)
	populate(objectMap, "aadDomainName", m.AADDomainName)
	populate(objectMap, "backupBlobShare", m.BackupBlobShare)
	populate(objectMap, "backupFileShare", m.BackupFileShare)
	populate(objectMap, "backupMode", m.BackupMode)
	populate(objectMap, "selectedAgentJobs", m.SelectedAgentJobs)
	populate(objectMap, "selectedDatabases", m.SelectedDatabases)
	populate(objectMap, "selectedLogins", m.SelectedLogins)
	return json.Marshal(objectMap)
}

// MigrateSQLServerSQLMITaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetMigrateSQLServerSQLMITaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MigrateSQLServerSQLMITaskOutput, *MigrateSqlServerSqlMITaskOutputAgentJobLevel, *MigrateSqlServerSqlMITaskOutputDatabaseLevel,
// - *MigrateSqlServerSqlMITaskOutputError, *MigrateSqlServerSqlMITaskOutputLoginLevel, *MigrateSqlServerSqlMITaskOutputMigrationLevel
type MigrateSQLServerSQLMITaskOutputClassification interface {
	// GetMigrateSQLServerSQLMITaskOutput returns the MigrateSQLServerSQLMITaskOutput content of the underlying type.
	GetMigrateSQLServerSQLMITaskOutput() *MigrateSQLServerSQLMITaskOutput
}

// MigrateSQLServerSQLMITaskOutput - Output for task that migrates SQL Server databases to Azure SQL Database Managed Instance.
type MigrateSQLServerSQLMITaskOutput struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateSQLServerSQLMITaskOutput implements the MigrateSQLServerSQLMITaskOutputClassification interface for type MigrateSQLServerSQLMITaskOutput.
func (m *MigrateSQLServerSQLMITaskOutput) GetMigrateSQLServerSQLMITaskOutput() *MigrateSQLServerSQLMITaskOutput {
	return m
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMITaskOutput.
func (m *MigrateSQLServerSQLMITaskOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return m.unmarshalInternal(rawMsg)
}

func (m MigrateSQLServerSQLMITaskOutput) marshalInternal(objectMap map[string]interface{}, discValue string) {
	populate(objectMap, "id", m.ID)
	m.ResultType = &discValue
	objectMap["resultType"] = m.ResultType
}

func (m *MigrateSQLServerSQLMITaskOutput) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSQLServerSQLMITaskOutputAgentJobLevel struct {
	MigrateSQLServerSQLMITaskOutput
	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Migration errors and warnings per job
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; The state of the original Agent Job.
	IsEnabled *bool `json:"isEnabled,omitempty" azure:"ro"`

	// READ-ONLY; Migration progress message
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Agent Job name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMITaskOutputAgentJobLevel.
func (m MigrateSQLServerSQLMITaskOutputAgentJobLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSQLServerSQLMITaskOutput.marshalInternal(objectMap, "AgentJobLevelOutput")
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "exceptionsAndWarnings", m.ExceptionsAndWarnings)
	populate(objectMap, "isEnabled", m.IsEnabled)
	populate(objectMap, "message", m.Message)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	populate(objectMap, "state", m.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMITaskOutputAgentJobLevel.
func (m *MigrateSQLServerSQLMITaskOutputAgentJobLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "exceptionsAndWarnings":
			err = unpopulate(val, &m.ExceptionsAndWarnings)
			delete(rawMsg, key)
		case "isEnabled":
			err = unpopulate(val, &m.IsEnabled)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &m.Message)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSQLServerSQLMITaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateSQLServerSQLMITaskOutputDatabaseLevel struct {
	MigrateSQLServerSQLMITaskOutput
	// READ-ONLY; Name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Migration exceptions and warnings
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; Migration progress message
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Size of the database in megabytes
	SizeMB *float64 `json:"sizeMB,omitempty" azure:"ro"`

	// READ-ONLY; Current stage of migration
	Stage *DatabaseMigrationStage `json:"stage,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMITaskOutputDatabaseLevel.
func (m MigrateSQLServerSQLMITaskOutputDatabaseLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSQLServerSQLMITaskOutput.marshalInternal(objectMap, "DatabaseLevelOutput")
	populate(objectMap, "databaseName", m.DatabaseName)
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "exceptionsAndWarnings", m.ExceptionsAndWarnings)
	populate(objectMap, "message", m.Message)
	populate(objectMap, "sizeMB", m.SizeMB)
	populate(objectMap, "stage", m.Stage)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	populate(objectMap, "state", m.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMITaskOutputDatabaseLevel.
func (m *MigrateSQLServerSQLMITaskOutputDatabaseLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "exceptionsAndWarnings":
			err = unpopulate(val, &m.ExceptionsAndWarnings)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &m.Message)
			delete(rawMsg, key)
		case "sizeMB":
			err = unpopulate(val, &m.SizeMB)
			delete(rawMsg, key)
		case "stage":
			err = unpopulate(val, &m.Stage)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSQLServerSQLMITaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateSQLServerSQLMITaskOutputError struct {
	MigrateSQLServerSQLMITaskOutput
	// READ-ONLY; Migration error
	Error *ReportableException `json:"error,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMITaskOutputError.
func (m MigrateSQLServerSQLMITaskOutputError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSQLServerSQLMITaskOutput.marshalInternal(objectMap, "ErrorOutput")
	populate(objectMap, "error", m.Error)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMITaskOutputError.
func (m *MigrateSQLServerSQLMITaskOutputError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &m.Error)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSQLServerSQLMITaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateSQLServerSQLMITaskOutputLoginLevel struct {
	MigrateSQLServerSQLMITaskOutput
	// READ-ONLY; Login migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Login migration errors and warnings per login
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; Login name.
	LoginName *string `json:"loginName,omitempty" azure:"ro"`

	// READ-ONLY; Login migration progress message
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Current stage of login
	Stage *LoginMigrationStage `json:"stage,omitempty" azure:"ro"`

	// READ-ONLY; Login migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of login
	State *MigrationState `json:"state,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMITaskOutputLoginLevel.
func (m MigrateSQLServerSQLMITaskOutputLoginLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSQLServerSQLMITaskOutput.marshalInternal(objectMap, "LoginLevelOutput")
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "exceptionsAndWarnings", m.ExceptionsAndWarnings)
	populate(objectMap, "loginName", m.LoginName)
	populate(objectMap, "message", m.Message)
	populate(objectMap, "stage", m.Stage)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	populate(objectMap, "state", m.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMITaskOutputLoginLevel.
func (m *MigrateSQLServerSQLMITaskOutputLoginLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "exceptionsAndWarnings":
			err = unpopulate(val, &m.ExceptionsAndWarnings)
			delete(rawMsg, key)
		case "loginName":
			err = unpopulate(val, &m.LoginName)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &m.Message)
			delete(rawMsg, key)
		case "stage":
			err = unpopulate(val, &m.Stage)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSQLServerSQLMITaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateSQLServerSQLMITaskOutputMigrationLevel struct {
	MigrateSQLServerSQLMITaskOutput
	// READ-ONLY; Selected agent jobs as a map from name to id
	AgentJobs *string `json:"agentJobs,omitempty" azure:"ro"`

	// READ-ONLY; Selected databases as a map from database name to database id
	Databases *string `json:"databases,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Migration exceptions and warnings.
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; Selected logins as a map from name to id
	Logins *string `json:"logins,omitempty" azure:"ro"`

	// READ-ONLY; Migration progress message
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; List of orphaned users.
	OrphanedUsersInfo []*OrphanedUserInfo `json:"orphanedUsersInfo,omitempty" azure:"ro"`

	// READ-ONLY; Map of server role migration results.
	ServerRoleResults *string `json:"serverRoleResults,omitempty" azure:"ro"`

	// READ-ONLY; Source server brand version
	SourceServerBrandVersion *string `json:"sourceServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Source server version
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Current status of migration
	Status *MigrationStatus `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMITaskOutputMigrationLevel.
func (m MigrateSQLServerSQLMITaskOutputMigrationLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSQLServerSQLMITaskOutput.marshalInternal(objectMap, "MigrationLevelOutput")
	populate(objectMap, "agentJobs", m.AgentJobs)
	populate(objectMap, "databases", m.Databases)
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "exceptionsAndWarnings", m.ExceptionsAndWarnings)
	populate(objectMap, "logins", m.Logins)
	populate(objectMap, "message", m.Message)
	populate(objectMap, "orphanedUsersInfo", m.OrphanedUsersInfo)
	populate(objectMap, "serverRoleResults", m.ServerRoleResults)
	populate(objectMap, "sourceServerBrandVersion", m.SourceServerBrandVersion)
	populate(objectMap, "sourceServerVersion", m.SourceServerVersion)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	populate(objectMap, "state", m.State)
	populate(objectMap, "status", m.Status)
	populate(objectMap, "targetServerBrandVersion", m.TargetServerBrandVersion)
	populate(objectMap, "targetServerVersion", m.TargetServerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMITaskOutputMigrationLevel.
func (m *MigrateSQLServerSQLMITaskOutputMigrationLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentJobs":
			err = unpopulate(val, &m.AgentJobs)
			delete(rawMsg, key)
		case "databases":
			err = unpopulate(val, &m.Databases)
			delete(rawMsg, key)
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "exceptionsAndWarnings":
			err = unpopulate(val, &m.ExceptionsAndWarnings)
			delete(rawMsg, key)
		case "logins":
			err = unpopulate(val, &m.Logins)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &m.Message)
			delete(rawMsg, key)
		case "orphanedUsersInfo":
			err = unpopulate(val, &m.OrphanedUsersInfo)
			delete(rawMsg, key)
		case "serverRoleResults":
			err = unpopulate(val, &m.ServerRoleResults)
			delete(rawMsg, key)
		case "sourceServerBrandVersion":
			err = unpopulate(val, &m.SourceServerBrandVersion)
			delete(rawMsg, key)
		case "sourceServerVersion":
			err = unpopulate(val, &m.SourceServerVersion)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &m.Status)
			delete(rawMsg, key)
		case "targetServerBrandVersion":
			err = unpopulate(val, &m.TargetServerBrandVersion)
			delete(rawMsg, key)
		case "targetServerVersion":
			err = unpopulate(val, &m.TargetServerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSQLServerSQLMITaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigrateSQLServerSQLMITaskProperties - Properties for task that migrates SQL Server databases to Azure SQL Database Managed Instance
type MigrateSQLServerSQLMITaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *MigrateSQLServerSQLMITaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []MigrateSQLServerSQLMITaskOutputClassification `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSQLServerSQLMITaskProperties.
func (m MigrateSQLServerSQLMITaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ProjectTaskProperties.marshalInternal(objectMap, "Migrate.SqlServer.AzureSqlDbMI")
	populate(objectMap, "input", m.Input)
	populate(objectMap, "output", m.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSQLServerSQLMITaskProperties.
func (m *MigrateSQLServerSQLMITaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMigrateSQLServerSQLMITaskOutputClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigrateSchemaSQLServerSQLDbDatabaseInput - Database input for migrate schema Sql Server to Azure SQL Server scenario
type MigrateSchemaSQLServerSQLDbDatabaseInput struct {
	// Name of source database
	Name *string `json:"name,omitempty"`

	// Database schema migration settings
	SchemaSetting *SchemaMigrationSetting `json:"schemaSetting,omitempty"`

	// Name of target database
	TargetDatabaseName *string `json:"targetDatabaseName,omitempty"`
}

// MigrateSchemaSQLServerSQLDbTaskInput - Input for task that migrates Schema for SQL Server databases to Azure SQL databases
type MigrateSchemaSQLServerSQLDbTaskInput struct {
	SQLMigrationTaskInput
	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateSchemaSQLServerSQLDbDatabaseInput `json:"selectedDatabases,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSchemaSQLServerSQLDbTaskInput.
func (m MigrateSchemaSQLServerSQLDbTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.SQLMigrationTaskInput.marshalInternal(objectMap)
	populate(objectMap, "selectedDatabases", m.SelectedDatabases)
	return json.Marshal(objectMap)
}

// MigrateSchemaSQLServerSQLDbTaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetMigrateSchemaSQLServerSQLDbTaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MigrateSchemaSQLServerSQLDbTaskOutput, *MigrateSchemaSqlServerSqlDbTaskOutputDatabaseLevel, *MigrateSchemaSqlServerSqlDbTaskOutputError,
// - *MigrateSchemaSqlServerSqlDbTaskOutputMigrationLevel, *MigrateSchemaSqlTaskOutputError
type MigrateSchemaSQLServerSQLDbTaskOutputClassification interface {
	// GetMigrateSchemaSQLServerSQLDbTaskOutput returns the MigrateSchemaSQLServerSQLDbTaskOutput content of the underlying type.
	GetMigrateSchemaSQLServerSQLDbTaskOutput() *MigrateSchemaSQLServerSQLDbTaskOutput
}

// MigrateSchemaSQLServerSQLDbTaskOutput - Output for the task that migrates Schema for SQL Server databases to Azure SQL databases
type MigrateSchemaSQLServerSQLDbTaskOutput struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateSchemaSQLServerSQLDbTaskOutput implements the MigrateSchemaSQLServerSQLDbTaskOutputClassification interface for type MigrateSchemaSQLServerSQLDbTaskOutput.
func (m *MigrateSchemaSQLServerSQLDbTaskOutput) GetMigrateSchemaSQLServerSQLDbTaskOutput() *MigrateSchemaSQLServerSQLDbTaskOutput {
	return m
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSchemaSQLServerSQLDbTaskOutput.
func (m *MigrateSchemaSQLServerSQLDbTaskOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return m.unmarshalInternal(rawMsg)
}

func (m MigrateSchemaSQLServerSQLDbTaskOutput) marshalInternal(objectMap map[string]interface{}, discValue string) {
	populate(objectMap, "id", m.ID)
	m.ResultType = &discValue
	objectMap["resultType"] = m.ResultType
}

func (m *MigrateSchemaSQLServerSQLDbTaskOutput) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSchemaSQLServerSQLDbTaskOutputDatabaseLevel struct {
	MigrateSchemaSQLServerSQLDbTaskOutput
	// READ-ONLY; Prefix string to use for querying errors for this database
	DatabaseErrorResultPrefix *string `json:"databaseErrorResultPrefix,omitempty" azure:"ro"`

	// READ-ONLY; The name of the database
	DatabaseName *string `json:"databaseName,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Identifier for the file resource containing the schema of this database
	FileID *string `json:"fileId,omitempty" azure:"ro"`

	// READ-ONLY; Number of failed operations for this database
	NumberOfFailedOperations *int64 `json:"numberOfFailedOperations,omitempty" azure:"ro"`

	// READ-ONLY; Number of successful operations for this database
	NumberOfSuccessfulOperations *int64 `json:"numberOfSuccessfulOperations,omitempty" azure:"ro"`

	// READ-ONLY; Prefix string to use for querying schema errors for this database
	SchemaErrorResultPrefix *string `json:"schemaErrorResultPrefix,omitempty" azure:"ro"`

	// READ-ONLY; Schema migration stage for this database
	Stage *SchemaMigrationStage `json:"stage,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; State of the schema migration for this database
	State *MigrationState `json:"state,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSchemaSQLServerSQLDbTaskOutputDatabaseLevel.
func (m MigrateSchemaSQLServerSQLDbTaskOutputDatabaseLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSchemaSQLServerSQLDbTaskOutput.marshalInternal(objectMap, "DatabaseLevelOutput")
	populate(objectMap, "databaseErrorResultPrefix", m.DatabaseErrorResultPrefix)
	populate(objectMap, "databaseName", m.DatabaseName)
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "fileId", m.FileID)
	populate(objectMap, "numberOfFailedOperations", m.NumberOfFailedOperations)
	populate(objectMap, "numberOfSuccessfulOperations", m.NumberOfSuccessfulOperations)
	populate(objectMap, "schemaErrorResultPrefix", m.SchemaErrorResultPrefix)
	populate(objectMap, "stage", m.Stage)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	populate(objectMap, "state", m.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSchemaSQLServerSQLDbTaskOutputDatabaseLevel.
func (m *MigrateSchemaSQLServerSQLDbTaskOutputDatabaseLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databaseErrorResultPrefix":
			err = unpopulate(val, &m.DatabaseErrorResultPrefix)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "fileId":
			err = unpopulate(val, &m.FileID)
			delete(rawMsg, key)
		case "numberOfFailedOperations":
			err = unpopulate(val, &m.NumberOfFailedOperations)
			delete(rawMsg, key)
		case "numberOfSuccessfulOperations":
			err = unpopulate(val, &m.NumberOfSuccessfulOperations)
			delete(rawMsg, key)
		case "schemaErrorResultPrefix":
			err = unpopulate(val, &m.SchemaErrorResultPrefix)
			delete(rawMsg, key)
		case "stage":
			err = unpopulate(val, &m.Stage)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSchemaSQLServerSQLDbTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateSchemaSQLServerSQLDbTaskOutputError struct {
	MigrateSchemaSQLServerSQLDbTaskOutput
	// READ-ONLY; Schema command which failed
	CommandText *string `json:"commandText,omitempty" azure:"ro"`

	// READ-ONLY; Reason of failure
	ErrorText *string `json:"errorText,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSchemaSQLServerSQLDbTaskOutputError.
func (m MigrateSchemaSQLServerSQLDbTaskOutputError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSchemaSQLServerSQLDbTaskOutput.marshalInternal(objectMap, "SchemaErrorOutput")
	populate(objectMap, "commandText", m.CommandText)
	populate(objectMap, "errorText", m.ErrorText)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSchemaSQLServerSQLDbTaskOutputError.
func (m *MigrateSchemaSQLServerSQLDbTaskOutputError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commandText":
			err = unpopulate(val, &m.CommandText)
			delete(rawMsg, key)
		case "errorText":
			err = unpopulate(val, &m.ErrorText)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSchemaSQLServerSQLDbTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateSchemaSQLServerSQLDbTaskOutputMigrationLevel struct {
	MigrateSchemaSQLServerSQLDbTaskOutput
	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Source server brand version
	SourceServerBrandVersion *string `json:"sourceServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Source server version
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Overall state of the schema migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`

	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSchemaSQLServerSQLDbTaskOutputMigrationLevel.
func (m MigrateSchemaSQLServerSQLDbTaskOutputMigrationLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSchemaSQLServerSQLDbTaskOutput.marshalInternal(objectMap, "MigrationLevelOutput")
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "sourceServerBrandVersion", m.SourceServerBrandVersion)
	populate(objectMap, "sourceServerVersion", m.SourceServerVersion)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	populate(objectMap, "state", m.State)
	populate(objectMap, "targetServerBrandVersion", m.TargetServerBrandVersion)
	populate(objectMap, "targetServerVersion", m.TargetServerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSchemaSQLServerSQLDbTaskOutputMigrationLevel.
func (m *MigrateSchemaSQLServerSQLDbTaskOutputMigrationLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "sourceServerBrandVersion":
			err = unpopulate(val, &m.SourceServerBrandVersion)
			delete(rawMsg, key)
		case "sourceServerVersion":
			err = unpopulate(val, &m.SourceServerVersion)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "targetServerBrandVersion":
			err = unpopulate(val, &m.TargetServerBrandVersion)
			delete(rawMsg, key)
		case "targetServerVersion":
			err = unpopulate(val, &m.TargetServerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSchemaSQLServerSQLDbTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigrateSchemaSQLServerSQLDbTaskProperties - Properties for task that migrates Schema for SQL Server databases to Azure SQL databases
type MigrateSchemaSQLServerSQLDbTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *MigrateSchemaSQLServerSQLDbTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []MigrateSchemaSQLServerSQLDbTaskOutputClassification `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSchemaSQLServerSQLDbTaskProperties.
func (m MigrateSchemaSQLServerSQLDbTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ProjectTaskProperties.marshalInternal(objectMap, "MigrateSchemaSqlServerSqlDb")
	populate(objectMap, "input", m.Input)
	populate(objectMap, "output", m.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSchemaSQLServerSQLDbTaskProperties.
func (m *MigrateSchemaSQLServerSQLDbTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMigrateSchemaSQLServerSQLDbTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateSchemaSQLTaskOutputError struct {
	MigrateSchemaSQLServerSQLDbTaskOutput
	// READ-ONLY; Migration error
	Error *ReportableException `json:"error,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSchemaSQLTaskOutputError.
func (m MigrateSchemaSQLTaskOutputError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSchemaSQLServerSQLDbTaskOutput.marshalInternal(objectMap, "ErrorOutput")
	populate(objectMap, "error", m.Error)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSchemaSQLTaskOutputError.
func (m *MigrateSchemaSQLTaskOutputError) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "error":
			err = unpopulate(val, &m.Error)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSchemaSQLServerSQLDbTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigrateSsisTaskInput - Input for task that migrates SSIS packages from SQL Server to Azure SQL Database Managed Instance.
type MigrateSsisTaskInput struct {
	SQLMigrationTaskInput
	// REQUIRED; SSIS package migration information.
	SsisMigrationInfo *SsisMigrationInfo `json:"ssisMigrationInfo,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSsisTaskInput.
func (m MigrateSsisTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.SQLMigrationTaskInput.marshalInternal(objectMap)
	populate(objectMap, "ssisMigrationInfo", m.SsisMigrationInfo)
	return json.Marshal(objectMap)
}

// MigrateSsisTaskOutputClassification provides polymorphic access to related types.
// Call the interface's GetMigrateSsisTaskOutput() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MigrateSsisTaskOutput, *MigrateSsisTaskOutputMigrationLevel, *MigrateSsisTaskOutputProjectLevel
type MigrateSsisTaskOutputClassification interface {
	// GetMigrateSsisTaskOutput returns the MigrateSsisTaskOutput content of the underlying type.
	GetMigrateSsisTaskOutput() *MigrateSsisTaskOutput
}

// MigrateSsisTaskOutput - Output for task that migrates SSIS packages from SQL Server to Azure SQL Database Managed Instance.
type MigrateSsisTaskOutput struct {
	// REQUIRED; Result type
	ResultType *string `json:"resultType,omitempty"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// GetMigrateSsisTaskOutput implements the MigrateSsisTaskOutputClassification interface for type MigrateSsisTaskOutput.
func (m *MigrateSsisTaskOutput) GetMigrateSsisTaskOutput() *MigrateSsisTaskOutput { return m }

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSsisTaskOutput.
func (m *MigrateSsisTaskOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return m.unmarshalInternal(rawMsg)
}

func (m MigrateSsisTaskOutput) marshalInternal(objectMap map[string]interface{}, discValue string) {
	populate(objectMap, "id", m.ID)
	m.ResultType = &discValue
	objectMap["resultType"] = m.ResultType
}

func (m *MigrateSsisTaskOutput) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

type MigrateSsisTaskOutputMigrationLevel struct {
	MigrateSsisTaskOutput
	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Migration exceptions and warnings.
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; Migration progress message
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Source server brand version
	SourceServerBrandVersion *string `json:"sourceServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Source server version
	SourceServerVersion *string `json:"sourceServerVersion,omitempty" azure:"ro"`

	// READ-ONLY; Stage of SSIS migration.
	Stage *SsisMigrationStage `json:"stage,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current status of migration
	Status *MigrationStatus `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; Target server brand version
	TargetServerBrandVersion *string `json:"targetServerBrandVersion,omitempty" azure:"ro"`

	// READ-ONLY; Target server version
	TargetServerVersion *string `json:"targetServerVersion,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSsisTaskOutputMigrationLevel.
func (m MigrateSsisTaskOutputMigrationLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSsisTaskOutput.marshalInternal(objectMap, "MigrationLevelOutput")
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "exceptionsAndWarnings", m.ExceptionsAndWarnings)
	populate(objectMap, "message", m.Message)
	populate(objectMap, "sourceServerBrandVersion", m.SourceServerBrandVersion)
	populate(objectMap, "sourceServerVersion", m.SourceServerVersion)
	populate(objectMap, "stage", m.Stage)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	populate(objectMap, "status", m.Status)
	populate(objectMap, "targetServerBrandVersion", m.TargetServerBrandVersion)
	populate(objectMap, "targetServerVersion", m.TargetServerVersion)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSsisTaskOutputMigrationLevel.
func (m *MigrateSsisTaskOutputMigrationLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "exceptionsAndWarnings":
			err = unpopulate(val, &m.ExceptionsAndWarnings)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &m.Message)
			delete(rawMsg, key)
		case "sourceServerBrandVersion":
			err = unpopulate(val, &m.SourceServerBrandVersion)
			delete(rawMsg, key)
		case "sourceServerVersion":
			err = unpopulate(val, &m.SourceServerVersion)
			delete(rawMsg, key)
		case "stage":
			err = unpopulate(val, &m.Stage)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &m.Status)
			delete(rawMsg, key)
		case "targetServerBrandVersion":
			err = unpopulate(val, &m.TargetServerBrandVersion)
			delete(rawMsg, key)
		case "targetServerVersion":
			err = unpopulate(val, &m.TargetServerVersion)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSsisTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

type MigrateSsisTaskOutputProjectLevel struct {
	MigrateSsisTaskOutput
	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Migration exceptions and warnings
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; Name of the folder
	FolderName *string `json:"folderName,omitempty" azure:"ro"`

	// READ-ONLY; Migration progress message
	Message *string `json:"message,omitempty" azure:"ro"`

	// READ-ONLY; Name of the project
	ProjectName *string `json:"projectName,omitempty" azure:"ro"`

	// READ-ONLY; Stage of SSIS migration.
	Stage *SsisMigrationStage `json:"stage,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSsisTaskOutputProjectLevel.
func (m MigrateSsisTaskOutputProjectLevel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MigrateSsisTaskOutput.marshalInternal(objectMap, "SsisProjectLevelOutput")
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "exceptionsAndWarnings", m.ExceptionsAndWarnings)
	populate(objectMap, "folderName", m.FolderName)
	populate(objectMap, "message", m.Message)
	populate(objectMap, "projectName", m.ProjectName)
	populate(objectMap, "stage", m.Stage)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	populate(objectMap, "state", m.State)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSsisTaskOutputProjectLevel.
func (m *MigrateSsisTaskOutputProjectLevel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "exceptionsAndWarnings":
			err = unpopulate(val, &m.ExceptionsAndWarnings)
			delete(rawMsg, key)
		case "folderName":
			err = unpopulate(val, &m.FolderName)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &m.Message)
			delete(rawMsg, key)
		case "projectName":
			err = unpopulate(val, &m.ProjectName)
			delete(rawMsg, key)
		case "stage":
			err = unpopulate(val, &m.Stage)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MigrateSsisTaskOutput.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigrateSsisTaskProperties - Properties for task that migrates SSIS packages from SQL Server databases to Azure SQL Database Managed Instance.
type MigrateSsisTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *MigrateSsisTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []MigrateSsisTaskOutputClassification `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSsisTaskProperties.
func (m MigrateSsisTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ProjectTaskProperties.marshalInternal(objectMap, "Migrate.Ssis")
	populate(objectMap, "input", m.Input)
	populate(objectMap, "output", m.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSsisTaskProperties.
func (m *MigrateSsisTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "output":
			m.Output, err = unmarshalMigrateSsisTaskOutputClassificationArray(val)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigrateSyncCompleteCommandInput - Input for command that completes sync migration for a database.
type MigrateSyncCompleteCommandInput struct {
	// REQUIRED; Name of database
	DatabaseName *string `json:"databaseName,omitempty"`

	// Time stamp to complete
	CommitTimeStamp *time.Time `json:"commitTimeStamp,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSyncCompleteCommandInput.
func (m MigrateSyncCompleteCommandInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "commitTimeStamp", (*timeRFC3339)(m.CommitTimeStamp))
	populate(objectMap, "databaseName", m.DatabaseName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSyncCompleteCommandInput.
func (m *MigrateSyncCompleteCommandInput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "commitTimeStamp":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.CommitTimeStamp = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "databaseName":
			err = unpopulate(val, &m.DatabaseName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrateSyncCompleteCommandOutput - Output for command that completes sync migration for a database.
type MigrateSyncCompleteCommandOutput struct {
	// READ-ONLY; List of errors that happened during the command execution
	Errors []*ReportableException `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSyncCompleteCommandOutput.
func (m MigrateSyncCompleteCommandOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "id", m.ID)
	return json.Marshal(objectMap)
}

// MigrateSyncCompleteCommandProperties - Properties for the command that completes sync migration for a database.
type MigrateSyncCompleteCommandProperties struct {
	CommandProperties
	// Command input
	Input *MigrateSyncCompleteCommandInput `json:"input,omitempty"`

	// READ-ONLY; Command output. This is ignored if submitted.
	Output *MigrateSyncCompleteCommandOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrateSyncCompleteCommandProperties.
func (m MigrateSyncCompleteCommandProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.CommandProperties.marshalInternal(objectMap, "Migrate.Sync.Complete.Database")
	populate(objectMap, "input", m.Input)
	populate(objectMap, "output", m.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrateSyncCompleteCommandProperties.
func (m *MigrateSyncCompleteCommandProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &m.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.CommandProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MigrationEligibilityInfo - Information about migration eligibility of a server object
type MigrationEligibilityInfo struct {
	// READ-ONLY; Whether object is eligible for migration or not.
	IsEligibleForMigration *bool `json:"isEligibleForMigration,omitempty" azure:"ro"`

	// READ-ONLY; Information about eligibility failure for the server object.
	ValidationMessages []*string `json:"validationMessages,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrationEligibilityInfo.
func (m MigrationEligibilityInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "isEligibleForMigration", m.IsEligibleForMigration)
	populate(objectMap, "validationMessages", m.ValidationMessages)
	return json.Marshal(objectMap)
}

// MigrationReportResult - Migration validation report result, contains the url for downloading the generated report.
type MigrationReportResult struct {
	// Migration validation result identifier
	ID *string `json:"id,omitempty"`

	// The url of the report.
	ReportURL *string `json:"reportUrl,omitempty"`
}

// MigrationTableMetadata - Metadata for tables selected in migration project
type MigrationTableMetadata struct {
	// READ-ONLY; Source table name
	SourceTableName *string `json:"sourceTableName,omitempty" azure:"ro"`

	// READ-ONLY; Target table name
	TargetTableName *string `json:"targetTableName,omitempty" azure:"ro"`
}

// MigrationValidationDatabaseLevelResult - Database level validation results
type MigrationValidationDatabaseLevelResult struct {
	// READ-ONLY; Provides data integrity validation result between the source and target tables that are migrated.
	DataIntegrityValidationResult *DataIntegrityValidationResult `json:"dataIntegrityValidationResult,omitempty" azure:"ro"`

	// READ-ONLY; Validation end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Migration Identifier
	MigrationID *string `json:"migrationId,omitempty" azure:"ro"`

	// READ-ONLY; Results of some of the query execution result between source and target database
	QueryAnalysisValidationResult *QueryAnalysisValidationResult `json:"queryAnalysisValidationResult,omitempty" azure:"ro"`

	// READ-ONLY; Provides schema comparison result between source and target database
	SchemaValidationResult *SchemaComparisonValidationResult `json:"schemaValidationResult,omitempty" azure:"ro"`

	// READ-ONLY; Name of the source database
	SourceDatabaseName *string `json:"sourceDatabaseName,omitempty" azure:"ro"`

	// READ-ONLY; Validation start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current status of validation at the database level
	Status *ValidationStatus `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; Name of the target database
	TargetDatabaseName *string `json:"targetDatabaseName,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrationValidationDatabaseLevelResult.
func (m MigrationValidationDatabaseLevelResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrationValidationDatabaseLevelResult.
func (m *MigrationValidationDatabaseLevelResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return m.unmarshalInternal(rawMsg)
}

func (m MigrationValidationDatabaseLevelResult) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "dataIntegrityValidationResult", m.DataIntegrityValidationResult)
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "id", m.ID)
	populate(objectMap, "migrationId", m.MigrationID)
	populate(objectMap, "queryAnalysisValidationResult", m.QueryAnalysisValidationResult)
	populate(objectMap, "schemaValidationResult", m.SchemaValidationResult)
	populate(objectMap, "sourceDatabaseName", m.SourceDatabaseName)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	populate(objectMap, "status", m.Status)
	populate(objectMap, "targetDatabaseName", m.TargetDatabaseName)
}

func (m *MigrationValidationDatabaseLevelResult) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataIntegrityValidationResult":
			err = unpopulate(val, &m.DataIntegrityValidationResult)
			delete(rawMsg, key)
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "migrationId":
			err = unpopulate(val, &m.MigrationID)
			delete(rawMsg, key)
		case "queryAnalysisValidationResult":
			err = unpopulate(val, &m.QueryAnalysisValidationResult)
			delete(rawMsg, key)
		case "schemaValidationResult":
			err = unpopulate(val, &m.SchemaValidationResult)
			delete(rawMsg, key)
		case "sourceDatabaseName":
			err = unpopulate(val, &m.SourceDatabaseName)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &m.Status)
			delete(rawMsg, key)
		case "targetDatabaseName":
			err = unpopulate(val, &m.TargetDatabaseName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrationValidationDatabaseSummaryResult - Migration Validation Database level summary result
type MigrationValidationDatabaseSummaryResult struct {
	// READ-ONLY; Validation end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Migration Identifier
	MigrationID *string `json:"migrationId,omitempty" azure:"ro"`

	// READ-ONLY; Name of the source database
	SourceDatabaseName *string `json:"sourceDatabaseName,omitempty" azure:"ro"`

	// READ-ONLY; Validation start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current status of validation at the database level
	Status *ValidationStatus `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; Name of the target database
	TargetDatabaseName *string `json:"targetDatabaseName,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrationValidationDatabaseSummaryResult.
func (m MigrationValidationDatabaseSummaryResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "endedOn", (*timeRFC3339)(m.EndedOn))
	populate(objectMap, "id", m.ID)
	populate(objectMap, "migrationId", m.MigrationID)
	populate(objectMap, "sourceDatabaseName", m.SourceDatabaseName)
	populate(objectMap, "startedOn", (*timeRFC3339)(m.StartedOn))
	populate(objectMap, "status", m.Status)
	populate(objectMap, "targetDatabaseName", m.TargetDatabaseName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrationValidationDatabaseSummaryResult.
func (m *MigrationValidationDatabaseSummaryResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "migrationId":
			err = unpopulate(val, &m.MigrationID)
			delete(rawMsg, key)
		case "sourceDatabaseName":
			err = unpopulate(val, &m.SourceDatabaseName)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &m.Status)
			delete(rawMsg, key)
		case "targetDatabaseName":
			err = unpopulate(val, &m.TargetDatabaseName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MigrationValidationOptions - Types of validations to run after the migration
type MigrationValidationOptions struct {
	// Allows to perform a checksum based data integrity validation between source and target for the selected database / tables .
	EnableDataIntegrityValidation *bool `json:"enableDataIntegrityValidation,omitempty"`

	// Allows to perform a quick and intelligent query analysis by retrieving queries from the source database and executes them in the target. The result will
	// have execution statistics for executions in
	// source and target databases for the extracted queries.
	EnableQueryAnalysisValidation *bool `json:"enableQueryAnalysisValidation,omitempty"`

	// Allows to compare the schema information between source and target.
	EnableSchemaValidation *bool `json:"enableSchemaValidation,omitempty"`
}

// MigrationValidationResult - Migration Validation Result
type MigrationValidationResult struct {
	// Validation summary results for each database
	SummaryResults map[string]*MigrationValidationDatabaseSummaryResult `json:"summaryResults,omitempty"`

	// READ-ONLY; Migration validation result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Migration Identifier
	MigrationID *string `json:"migrationId,omitempty" azure:"ro"`

	// READ-ONLY; Current status of validation at the migration level. Status from the database validation result status will be aggregated here.
	Status *ValidationStatus `json:"status,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type MigrationValidationResult.
func (m MigrationValidationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MigrationValidationResult.
func (m *MigrationValidationResult) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return m.unmarshalInternal(rawMsg)
}

func (m MigrationValidationResult) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "id", m.ID)
	populate(objectMap, "migrationId", m.MigrationID)
	populate(objectMap, "status", m.Status)
	populate(objectMap, "summaryResults", m.SummaryResults)
}

func (m *MigrationValidationResult) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &m.ID)
			delete(rawMsg, key)
		case "migrationId":
			err = unpopulate(val, &m.MigrationID)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &m.Status)
			delete(rawMsg, key)
		case "summaryResults":
			err = unpopulate(val, &m.SummaryResults)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbCancelCommand - Properties for the command that cancels a migration in whole or in part
type MongoDbCancelCommand struct {
	CommandProperties
	// Command input
	Input *MongoDbCommandInput `json:"input,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbCancelCommand.
func (m MongoDbCancelCommand) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.CommandProperties.marshalInternal(objectMap, "cancel")
	populate(objectMap, "input", m.Input)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbCancelCommand.
func (m *MongoDbCancelCommand) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.CommandProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MongoDbClusterInfo - Describes a MongoDB data source
type MongoDbClusterInfo struct {
	// REQUIRED; A list of non-system databases in the cluster
	Databases []*MongoDbDatabaseInfo `json:"databases,omitempty"`

	// REQUIRED; Whether the cluster supports sharded collections
	SupportsSharding *bool `json:"supportsSharding,omitempty"`

	// REQUIRED; The type of data source
	Type *MongoDbClusterType `json:"type,omitempty"`

	// REQUIRED; The version of the data source in the form x.y.z (e.g. 3.6.7). Not used if Type is BlobContainer.
	Version *string `json:"version,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbClusterInfo.
func (m MongoDbClusterInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "databases", m.Databases)
	populate(objectMap, "supportsSharding", m.SupportsSharding)
	populate(objectMap, "type", m.Type)
	populate(objectMap, "version", m.Version)
	return json.Marshal(objectMap)
}

// MongoDbCollectionInfo - Describes a supported collection within a MongoDB database
type MongoDbCollectionInfo struct {
	MongoDbObjectInfo
	// REQUIRED; The name of the database containing the collection
	DatabaseName *string `json:"databaseName,omitempty"`

	// REQUIRED; Whether the collection is a capped collection (i.e. whether it has a fixed size and acts like a circular buffer)
	IsCapped *bool `json:"isCapped,omitempty"`

	// REQUIRED; Whether the collection is system collection
	IsSystemCollection *bool `json:"isSystemCollection,omitempty"`

	// REQUIRED; Whether the collection is a view of another collection
	IsView *bool `json:"isView,omitempty"`

	// REQUIRED; Whether the database has sharding enabled. Note that the migration task will enable sharding on the target if necessary.
	SupportsSharding *bool `json:"supportsSharding,omitempty"`

	// The shard key on the collection, or null if the collection is not sharded
	ShardKey *MongoDbShardKeyInfo `json:"shardKey,omitempty"`

	// The name of the collection that this is a view of, if IsView is true
	ViewOf *string `json:"viewOf,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbCollectionInfo.
func (m MongoDbCollectionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MongoDbObjectInfo.marshalInternal(objectMap)
	populate(objectMap, "databaseName", m.DatabaseName)
	populate(objectMap, "isCapped", m.IsCapped)
	populate(objectMap, "isSystemCollection", m.IsSystemCollection)
	populate(objectMap, "isView", m.IsView)
	populate(objectMap, "shardKey", m.ShardKey)
	populate(objectMap, "supportsSharding", m.SupportsSharding)
	populate(objectMap, "viewOf", m.ViewOf)
	return json.Marshal(objectMap)
}

// MongoDbCollectionProgress - Describes the progress of a collection
type MongoDbCollectionProgress struct {
	MongoDbProgress
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbCollectionProgress.
func (m MongoDbCollectionProgress) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MongoDbProgress.marshalInternal(objectMap, MongoDbProgressResultTypeCollection)
	return json.Marshal(objectMap)
}

// MongoDbCollectionSettings - Describes how an individual MongoDB collection should be migrated
type MongoDbCollectionSettings struct {
	// Whether the migrator is allowed to drop the target collection in the course of performing a migration. The default is true.
	CanDelete *bool `json:"canDelete,omitempty"`

	// Describes a MongoDB shard key
	ShardKey *MongoDbShardKeySetting `json:"shardKey,omitempty"`

	// The RUs that should be configured on a CosmosDB target, or null to use the default. This has no effect on non-CosmosDB targets.
	TargetRUs *int32 `json:"targetRUs,omitempty"`
}

// MongoDbCommandInput - Describes the input to the 'cancel' and 'restart' MongoDB migration commands
type MongoDbCommandInput struct {
	// The qualified name of a database or collection to act upon, or null to act upon the entire migration
	ObjectName *string `json:"objectName,omitempty"`
}

// MongoDbConnectionInfo - Describes a connection to a MongoDB data source
type MongoDbConnectionInfo struct {
	ConnectionInfo
	// REQUIRED; A MongoDB connection string or blob container URL. The user name and password can be specified here or in the userName and password properties
	ConnectionString *string `json:"connectionString,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbConnectionInfo.
func (m MongoDbConnectionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ConnectionInfo.marshalInternal(objectMap, "MongoDbConnectionInfo")
	populate(objectMap, "connectionString", m.ConnectionString)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbConnectionInfo.
func (m *MongoDbConnectionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "connectionString":
			err = unpopulate(val, &m.ConnectionString)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ConnectionInfo.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MongoDbDatabaseInfo - Describes a database within a MongoDB data source
type MongoDbDatabaseInfo struct {
	MongoDbObjectInfo
	// REQUIRED; A list of supported collections in a MongoDB database
	Collections []*MongoDbCollectionInfo `json:"collections,omitempty"`

	// REQUIRED; Whether the database has sharding enabled. Note that the migration task will enable sharding on the target if necessary.
	SupportsSharding *bool `json:"supportsSharding,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbDatabaseInfo.
func (m MongoDbDatabaseInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MongoDbObjectInfo.marshalInternal(objectMap)
	populate(objectMap, "collections", m.Collections)
	populate(objectMap, "supportsSharding", m.SupportsSharding)
	return json.Marshal(objectMap)
}

// MongoDbDatabaseProgress - Describes the progress of a database
type MongoDbDatabaseProgress struct {
	MongoDbProgress
	// The progress of the collections in the database. The keys are the unqualified names of the collections
	Collections map[string]*MongoDbCollectionProgress `json:"collections,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbDatabaseProgress.
func (m MongoDbDatabaseProgress) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MongoDbProgress.marshalInternal(objectMap, MongoDbProgressResultTypeDatabase)
	populate(objectMap, "collections", m.Collections)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbDatabaseProgress.
func (m *MongoDbDatabaseProgress) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "collections":
			err = unpopulate(val, &m.Collections)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MongoDbProgress.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MongoDbDatabaseSettings - Describes how an individual MongoDB database should be migrated
type MongoDbDatabaseSettings struct {
	// REQUIRED; The collections on the source database to migrate to the target. The keys are the unqualified names of the collections.
	Collections map[string]*MongoDbCollectionSettings `json:"collections,omitempty"`

	// The RUs that should be configured on a CosmosDB target, or null to use the default, or 0 if throughput should not be provisioned for the database. This
	// has no effect on non-CosmosDB targets.
	TargetRUs *int32 `json:"targetRUs,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbDatabaseSettings.
func (m MongoDbDatabaseSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "collections", m.Collections)
	populate(objectMap, "targetRUs", m.TargetRUs)
	return json.Marshal(objectMap)
}

// MongoDbError - Describes an error or warning that occurred during a MongoDB migration
type MongoDbError struct {
	// The non-localized, machine-readable code that describes the error or warning
	Code *string `json:"code,omitempty"`

	// The number of times the error or warning has occurred
	Count *int32 `json:"count,omitempty"`

	// The localized, human-readable message that describes the error or warning
	Message *string `json:"message,omitempty"`

	// The type of error or warning
	Type *MongoDbErrorType `json:"type,omitempty"`
}

// MongoDbFinishCommand - Properties for the command that finishes a migration in whole or in part
type MongoDbFinishCommand struct {
	CommandProperties
	// Command input
	Input *MongoDbFinishCommandInput `json:"input,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbFinishCommand.
func (m MongoDbFinishCommand) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.CommandProperties.marshalInternal(objectMap, "finish")
	populate(objectMap, "input", m.Input)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbFinishCommand.
func (m *MongoDbFinishCommand) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.CommandProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MongoDbFinishCommandInput - Describes the input to the 'finish' MongoDB migration command
type MongoDbFinishCommandInput struct {
	MongoDbCommandInput
	// REQUIRED; If true, replication for the affected objects will be stopped immediately. If false, the migrator will finish replaying queued events before
	// finishing the replication.
	Immediate *bool `json:"immediate,omitempty"`
}

// MongoDbMigrationProgress - Describes the progress of the overall migration
type MongoDbMigrationProgress struct {
	MongoDbProgress
	// The progress of the databases in the migration. The keys are the names of the databases
	Databases map[string]*MongoDbDatabaseProgress `json:"databases,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbMigrationProgress.
func (m MongoDbMigrationProgress) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.MongoDbProgress.marshalInternal(objectMap, MongoDbProgressResultTypeMigration)
	populate(objectMap, "databases", m.Databases)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbMigrationProgress.
func (m *MongoDbMigrationProgress) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databases":
			err = unpopulate(val, &m.Databases)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.MongoDbProgress.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MongoDbMigrationSettings - Describes how a MongoDB data migration should be performed
type MongoDbMigrationSettings struct {
	// REQUIRED; The databases on the source cluster to migrate to the target. The keys are the names of the databases.
	Databases map[string]*MongoDbDatabaseSettings `json:"databases,omitempty"`

	// REQUIRED; Settings used to connect to the source cluster
	Source *MongoDbConnectionInfo `json:"source,omitempty"`

	// REQUIRED; Settings used to connect to the target cluster
	Target *MongoDbConnectionInfo `json:"target,omitempty"`

	// The RU limit on a CosmosDB target that collections will be temporarily increased to (if lower) during the initial copy of a migration, from 10,000 to
	// 1,000,000, or 0 to use the default boost (which is
	// generally the maximum), or null to not boost the RUs. This setting has no effect on non-CosmosDB targets.
	BoostRUs *int32 `json:"boostRUs,omitempty"`

	// Describes how changes will be replicated from the source to the target. The default is OneTime.
	Replication *MongoDbReplication `json:"replication,omitempty"`

	// Settings used to limit the resource usage of the migration
	Throttling *MongoDbThrottlingSettings `json:"throttling,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbMigrationSettings.
func (m MongoDbMigrationSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "boostRUs", m.BoostRUs)
	populate(objectMap, "databases", m.Databases)
	populate(objectMap, "replication", m.Replication)
	populate(objectMap, "source", m.Source)
	populate(objectMap, "target", m.Target)
	populate(objectMap, "throttling", m.Throttling)
	return json.Marshal(objectMap)
}

// MongoDbObjectInfo - Describes a database or collection within a MongoDB data source
type MongoDbObjectInfo struct {
	// REQUIRED; The average document size, or -1 if the average size is unknown
	AverageDocumentSize *int64 `json:"averageDocumentSize,omitempty"`

	// REQUIRED; The estimated total data size, in bytes, or -1 if the size is unknown.
	DataSize *int64 `json:"dataSize,omitempty"`

	// REQUIRED; The estimated total number of documents, or -1 if the document count is unknown
	DocumentCount *int64 `json:"documentCount,omitempty"`

	// REQUIRED; The unqualified name of the database or collection
	Name *string `json:"name,omitempty"`

	// REQUIRED; The qualified name of the database or collection. For a collection, this is the database-qualified name.
	QualifiedName *string `json:"qualifiedName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbObjectInfo.
func (m MongoDbObjectInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (m MongoDbObjectInfo) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "averageDocumentSize", m.AverageDocumentSize)
	populate(objectMap, "dataSize", m.DataSize)
	populate(objectMap, "documentCount", m.DocumentCount)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "qualifiedName", m.QualifiedName)
}

// MongoDbProgressClassification provides polymorphic access to related types.
// Call the interface's GetMongoDbProgress() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *MongoDbCollectionProgress, *MongoDbDatabaseProgress, *MongoDbMigrationProgress, *MongoDbProgress
type MongoDbProgressClassification interface {
	// GetMongoDbProgress returns the MongoDbProgress content of the underlying type.
	GetMongoDbProgress() *MongoDbProgress
}

// MongoDbProgress - Base class for MongoDB migration outputs
type MongoDbProgress struct {
	// REQUIRED; The number of document bytes copied during the Copying stage
	BytesCopied *int64 `json:"bytesCopied,omitempty"`

	// REQUIRED; The number of documents copied during the Copying stage
	DocumentsCopied *int64 `json:"documentsCopied,omitempty"`

	// REQUIRED; The elapsed time in the format [ddd.]hh:mm:ss[.fffffff] (i.e. TimeSpan format)
	ElapsedTime *string `json:"elapsedTime,omitempty"`

	// REQUIRED; The errors and warnings that have occurred for the current object. The keys are the error codes.
	Errors map[string]*MongoDbError `json:"errors,omitempty"`

	// REQUIRED; The number of oplog events awaiting replay
	EventsPending *int64 `json:"eventsPending,omitempty"`

	// REQUIRED; The number of oplog events replayed so far
	EventsReplayed *int64 `json:"eventsReplayed,omitempty"`

	// REQUIRED; The type of progress object
	ResultType *MongoDbProgressResultType `json:"resultType,omitempty"`

	// REQUIRED
	State *MongoDbMigrationState `json:"state,omitempty"`

	// REQUIRED; The total number of document bytes on the source at the beginning of the Copying stage, or -1 if the total size was unknown
	TotalBytes *int64 `json:"totalBytes,omitempty"`

	// REQUIRED; The total number of documents on the source at the beginning of the Copying stage, or -1 if the total count was unknown
	TotalDocuments *int64 `json:"totalDocuments,omitempty"`

	// The timestamp of the last oplog event received, or null if no oplog event has been received yet
	LastEventTime *time.Time `json:"lastEventTime,omitempty"`

	// The timestamp of the last oplog event replayed, or null if no oplog event has been replayed yet
	LastReplayTime *time.Time `json:"lastReplayTime,omitempty"`

	// The name of the progress object. For a collection, this is the unqualified collection name. For a database, this is the database name. For the overall
	// migration, this is null.
	Name *string `json:"name,omitempty"`

	// The qualified name of the progress object. For a collection, this is the database-qualified name. For a database, this is the database name. For the
	// overall migration, this is null.
	QualifiedName *string `json:"qualifiedName,omitempty"`
}

// GetMongoDbProgress implements the MongoDbProgressClassification interface for type MongoDbProgress.
func (m *MongoDbProgress) GetMongoDbProgress() *MongoDbProgress { return m }

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbProgress.
func (m *MongoDbProgress) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return m.unmarshalInternal(rawMsg)
}

func (m MongoDbProgress) marshalInternal(objectMap map[string]interface{}, discValue MongoDbProgressResultType) {
	populate(objectMap, "bytesCopied", m.BytesCopied)
	populate(objectMap, "documentsCopied", m.DocumentsCopied)
	populate(objectMap, "elapsedTime", m.ElapsedTime)
	populate(objectMap, "errors", m.Errors)
	populate(objectMap, "eventsPending", m.EventsPending)
	populate(objectMap, "eventsReplayed", m.EventsReplayed)
	populate(objectMap, "lastEventTime", (*timeRFC3339)(m.LastEventTime))
	populate(objectMap, "lastReplayTime", (*timeRFC3339)(m.LastReplayTime))
	populate(objectMap, "name", m.Name)
	populate(objectMap, "qualifiedName", m.QualifiedName)
	m.ResultType = &discValue
	objectMap["resultType"] = m.ResultType
	populate(objectMap, "state", m.State)
	populate(objectMap, "totalBytes", m.TotalBytes)
	populate(objectMap, "totalDocuments", m.TotalDocuments)
}

func (m *MongoDbProgress) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "bytesCopied":
			err = unpopulate(val, &m.BytesCopied)
			delete(rawMsg, key)
		case "documentsCopied":
			err = unpopulate(val, &m.DocumentsCopied)
			delete(rawMsg, key)
		case "elapsedTime":
			err = unpopulate(val, &m.ElapsedTime)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &m.Errors)
			delete(rawMsg, key)
		case "eventsPending":
			err = unpopulate(val, &m.EventsPending)
			delete(rawMsg, key)
		case "eventsReplayed":
			err = unpopulate(val, &m.EventsReplayed)
			delete(rawMsg, key)
		case "lastEventTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.LastEventTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "lastReplayTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.LastReplayTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "qualifiedName":
			err = unpopulate(val, &m.QualifiedName)
			delete(rawMsg, key)
		case "resultType":
			err = unpopulate(val, &m.ResultType)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &m.State)
			delete(rawMsg, key)
		case "totalBytes":
			err = unpopulate(val, &m.TotalBytes)
			delete(rawMsg, key)
		case "totalDocuments":
			err = unpopulate(val, &m.TotalDocuments)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MongoDbRestartCommand - Properties for the command that restarts a migration in whole or in part
type MongoDbRestartCommand struct {
	CommandProperties
	// Command input
	Input *MongoDbCommandInput `json:"input,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbRestartCommand.
func (m MongoDbRestartCommand) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.CommandProperties.marshalInternal(objectMap, "restart")
	populate(objectMap, "input", m.Input)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MongoDbRestartCommand.
func (m *MongoDbRestartCommand) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &m.Input)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.CommandProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// MongoDbShardKeyField - Describes a field reference within a MongoDB shard key
type MongoDbShardKeyField struct {
	// REQUIRED; The name of the field
	Name *string `json:"name,omitempty"`

	// REQUIRED; The field ordering
	Order *MongoDbShardKeyOrder `json:"order,omitempty"`
}

// MongoDbShardKeyInfo - Describes a MongoDB shard key
type MongoDbShardKeyInfo struct {
	// REQUIRED; The fields within the shard key
	Fields []*MongoDbShardKeyField `json:"fields,omitempty"`

	// REQUIRED; Whether the shard key is unique
	IsUnique *bool `json:"isUnique,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbShardKeyInfo.
func (m MongoDbShardKeyInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "fields", m.Fields)
	populate(objectMap, "isUnique", m.IsUnique)
	return json.Marshal(objectMap)
}

// MongoDbShardKeySetting - Describes a MongoDB shard key
type MongoDbShardKeySetting struct {
	// REQUIRED; The fields within the shard key
	Fields []*MongoDbShardKeyField `json:"fields,omitempty"`

	// REQUIRED; Whether the shard key is unique
	IsUnique *bool `json:"isUnique,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MongoDbShardKeySetting.
func (m MongoDbShardKeySetting) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "fields", m.Fields)
	populate(objectMap, "isUnique", m.IsUnique)
	return json.Marshal(objectMap)
}

// MongoDbThrottlingSettings - Specifies resource limits for the migration
type MongoDbThrottlingSettings struct {
	// The maximum number of work items (e.g. collection copies) that will be processed in parallel
	MaxParallelism *int32 `json:"maxParallelism,omitempty"`

	// The percentage of CPU time that the migrator will try to avoid using, from 0 to 100
	MinFreeCPU *int32 `json:"minFreeCpu,omitempty"`

	// The number of megabytes of RAM that the migrator will try to avoid using
	MinFreeMemoryMb *int32 `json:"minFreeMemoryMb,omitempty"`
}

// MySQLConnectionInfo - Information for connecting to MySQL server
type MySQLConnectionInfo struct {
	ConnectionInfo
	// REQUIRED; Port for Server
	Port *int32 `json:"port,omitempty"`

	// REQUIRED; Name of the server
	ServerName *string `json:"serverName,omitempty"`

	// Whether to encrypt the connection
	EncryptConnection *bool `json:"encryptConnection,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MySQLConnectionInfo.
func (m MySQLConnectionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.ConnectionInfo.marshalInternal(objectMap, "MySqlConnectionInfo")
	populate(objectMap, "encryptConnection", m.EncryptConnection)
	populate(objectMap, "port", m.Port)
	populate(objectMap, "serverName", m.ServerName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MySQLConnectionInfo.
func (m *MySQLConnectionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "encryptConnection":
			err = unpopulate(val, &m.EncryptConnection)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &m.Port)
			delete(rawMsg, key)
		case "serverName":
			err = unpopulate(val, &m.ServerName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.ConnectionInfo.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// NameAvailabilityRequest - A resource type and proposed name
type NameAvailabilityRequest struct {
	// The proposed resource name
	Name *string `json:"name,omitempty"`

	// The resource type chain (e.g. virtualMachines/extensions)
	Type *string `json:"type,omitempty"`
}

// NameAvailabilityResponse - Indicates whether a proposed resource name is available
type NameAvailabilityResponse struct {
	// The localized reason why the name is not available, if nameAvailable is false
	Message *string `json:"message,omitempty"`

	// If true, the name is valid and available. If false, 'reason' describes why not.
	NameAvailable *bool `json:"nameAvailable,omitempty"`

	// The reason why the name is not available, if nameAvailable is false
	Reason *NameCheckFailureReason `json:"reason,omitempty"`
}

// NonSQLDataMigrationTable - Defines metadata for table to be migrated
type NonSQLDataMigrationTable struct {
	// Source table name
	SourceName *string `json:"sourceName,omitempty"`
}

// NonSQLDataMigrationTableResult - Object used to report the data migration results of a table
type NonSQLDataMigrationTableResult struct {
	// READ-ONLY; Time taken to migrate the data
	ElapsedTimeInMiliseconds *float64 `json:"elapsedTimeInMiliseconds,omitempty" azure:"ro"`

	// READ-ONLY; List of errors, if any, during migration
	Errors []*DataMigrationError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; Result code of the data migration
	ResultCode *DataMigrationResultCode `json:"resultCode,omitempty" azure:"ro"`

	// READ-ONLY; Name of the source table
	SourceName *string `json:"sourceName,omitempty" azure:"ro"`

	// READ-ONLY; Number of rows in the source table
	SourceRowCount *int64 `json:"sourceRowCount,omitempty" azure:"ro"`

	// READ-ONLY; Name of the target table
	TargetName *string `json:"targetName,omitempty" azure:"ro"`

	// READ-ONLY; Number of rows in the target table
	TargetRowCount *int64 `json:"targetRowCount,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type NonSQLDataMigrationTableResult.
func (n NonSQLDataMigrationTableResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "elapsedTimeInMiliseconds", n.ElapsedTimeInMiliseconds)
	populate(objectMap, "errors", n.Errors)
	populate(objectMap, "resultCode", n.ResultCode)
	populate(objectMap, "sourceName", n.SourceName)
	populate(objectMap, "sourceRowCount", n.SourceRowCount)
	populate(objectMap, "targetName", n.TargetName)
	populate(objectMap, "targetRowCount", n.TargetRowCount)
	return json.Marshal(objectMap)
}

// NonSQLMigrationTaskInput - Base class for non sql migration task input
type NonSQLMigrationTaskInput struct {
	// REQUIRED; A URL that points to the drop location to access project artifacts
	ProjectLocation *string `json:"projectLocation,omitempty"`

	// REQUIRED; Name of the migration project
	ProjectName *string `json:"projectName,omitempty"`

	// REQUIRED; Metadata of the tables selected for migration
	SelectedTables []*NonSQLDataMigrationTable `json:"selectedTables,omitempty"`

	// REQUIRED; Information for connecting to target
	TargetConnectionInfo *SQLConnectionInfo `json:"targetConnectionInfo,omitempty"`

	// REQUIRED; Target database name
	TargetDatabaseName *string `json:"targetDatabaseName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NonSQLMigrationTaskInput.
func (n NonSQLMigrationTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "projectLocation", n.ProjectLocation)
	populate(objectMap, "projectName", n.ProjectName)
	populate(objectMap, "selectedTables", n.SelectedTables)
	populate(objectMap, "targetConnectionInfo", n.TargetConnectionInfo)
	populate(objectMap, "targetDatabaseName", n.TargetDatabaseName)
	return json.Marshal(objectMap)
}

// NonSQLMigrationTaskOutput - Base class for non sql migration task output
type NonSQLMigrationTaskOutput struct {
	// READ-ONLY; Results of the migration. The key contains the table name and the value the table result object
	DataMigrationTableResults *string `json:"dataMigrationTableResults,omitempty" azure:"ro"`

	// READ-ONLY; Migration end time
	EndedOn *time.Time `json:"endedOn,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Message about the progress of the migration
	ProgressMessage *string `json:"progressMessage,omitempty" azure:"ro"`

	// READ-ONLY; Name of source server
	SourceServerName *string `json:"sourceServerName,omitempty" azure:"ro"`

	// READ-ONLY; Migration start time
	StartedOn *time.Time `json:"startedOn,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	Status *MigrationStatus `json:"status,omitempty" azure:"ro"`

	// READ-ONLY; Name of target server
	TargetServerName *string `json:"targetServerName,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type NonSQLMigrationTaskOutput.
func (n NonSQLMigrationTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dataMigrationTableResults", n.DataMigrationTableResults)
	populate(objectMap, "endedOn", (*timeRFC3339)(n.EndedOn))
	populate(objectMap, "id", n.ID)
	populate(objectMap, "progressMessage", n.ProgressMessage)
	populate(objectMap, "sourceServerName", n.SourceServerName)
	populate(objectMap, "startedOn", (*timeRFC3339)(n.StartedOn))
	populate(objectMap, "status", n.Status)
	populate(objectMap, "targetServerName", n.TargetServerName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NonSQLMigrationTaskOutput.
func (n *NonSQLMigrationTaskOutput) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataMigrationTableResults":
			err = unpopulate(val, &n.DataMigrationTableResults)
			delete(rawMsg, key)
		case "endedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			n.EndedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "id":
			err = unpopulate(val, &n.ID)
			delete(rawMsg, key)
		case "progressMessage":
			err = unpopulate(val, &n.ProgressMessage)
			delete(rawMsg, key)
		case "sourceServerName":
			err = unpopulate(val, &n.SourceServerName)
			delete(rawMsg, key)
		case "startedOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			n.StartedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &n.Status)
			delete(rawMsg, key)
		case "targetServerName":
			err = unpopulate(val, &n.TargetServerName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ODataError - Error information in OData format.
type ODataError struct {
	// The machine-readable description of the error, such as 'InvalidRequest' or 'InternalServerError'
	Code *string `json:"code,omitempty"`

	// Inner errors that caused this error
	Details []*ODataError `json:"details,omitempty"`

	// The human-readable description of the error
	Message *string `json:"message,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ODataError.
func (o ODataError) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", o.Code)
	populate(objectMap, "details", o.Details)
	populate(objectMap, "message", o.Message)
	return json.Marshal(objectMap)
}

// OperationsListOptions contains the optional parameters for the Operations.List method.
type OperationsListOptions struct {
	// placeholder for future optional parameters
}

// OracleConnectionInfo - Information for connecting to Oracle server
type OracleConnectionInfo struct {
	ConnectionInfo
	// REQUIRED; EZConnect or TNSName connection string.
	DataSource *string `json:"dataSource,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type OracleConnectionInfo.
func (o OracleConnectionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	o.ConnectionInfo.marshalInternal(objectMap, "OracleConnectionInfo")
	populate(objectMap, "dataSource", o.DataSource)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type OracleConnectionInfo.
func (o *OracleConnectionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dataSource":
			err = unpopulate(val, &o.DataSource)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := o.ConnectionInfo.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// OracleOCIDriverInfo - Information about an Oracle OCI driver.
type OracleOCIDriverInfo struct {
	// READ-ONLY; The MD5 Base64 encoded checksum for the driver package.
	ArchiveChecksum *string `json:"archiveChecksum,omitempty" azure:"ro"`

	// READ-ONLY; Version listed in the OCI assembly 'oci.dll'
	AssemblyVersion *string `json:"assemblyVersion,omitempty" azure:"ro"`

	// READ-ONLY; The name of the driver package
	DriverName *string `json:"driverName,omitempty" azure:"ro"`

	// READ-ONLY; The size in bytes of the driver package
	DriverSize *string `json:"driverSize,omitempty" azure:"ro"`

	// READ-ONLY; The checksum for the driver package provided by Oracle.
	OracleChecksum *string `json:"oracleChecksum,omitempty" azure:"ro"`

	// READ-ONLY; List of Oracle database versions supported by this driver. Only major minor of the version is listed.
	SupportedOracleVersions []*string `json:"supportedOracleVersions,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type OracleOCIDriverInfo.
func (o OracleOCIDriverInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "archiveChecksum", o.ArchiveChecksum)
	populate(objectMap, "assemblyVersion", o.AssemblyVersion)
	populate(objectMap, "driverName", o.DriverName)
	populate(objectMap, "driverSize", o.DriverSize)
	populate(objectMap, "oracleChecksum", o.OracleChecksum)
	populate(objectMap, "supportedOracleVersions", o.SupportedOracleVersions)
	return json.Marshal(objectMap)
}

// OrphanedUserInfo - Information of orphaned users on the SQL server database.
type OrphanedUserInfo struct {
	// Parent database of the user
	DatabaseName *string `json:"databaseName,omitempty"`

	// Name of the orphaned user
	Name *string `json:"name,omitempty"`
}

// PostgreSQLConnectionInfo - Information for connecting to PostgreSQL server
type PostgreSQLConnectionInfo struct {
	ConnectionInfo
	// REQUIRED; Port for Server
	Port *int32 `json:"port,omitempty"`

	// REQUIRED; Name of the server
	ServerName *string `json:"serverName,omitempty"`

	// Name of the database
	DatabaseName *string `json:"databaseName,omitempty"`

	// Whether to encrypt the connection
	EncryptConnection *bool `json:"encryptConnection,omitempty"`

	// Whether to trust the server certificate
	TrustServerCertificate *bool `json:"trustServerCertificate,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type PostgreSQLConnectionInfo.
func (p PostgreSQLConnectionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.ConnectionInfo.marshalInternal(objectMap, "PostgreSqlConnectionInfo")
	populate(objectMap, "databaseName", p.DatabaseName)
	populate(objectMap, "encryptConnection", p.EncryptConnection)
	populate(objectMap, "port", p.Port)
	populate(objectMap, "serverName", p.ServerName)
	populate(objectMap, "trustServerCertificate", p.TrustServerCertificate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PostgreSQLConnectionInfo.
func (p *PostgreSQLConnectionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "databaseName":
			err = unpopulate(val, &p.DatabaseName)
			delete(rawMsg, key)
		case "encryptConnection":
			err = unpopulate(val, &p.EncryptConnection)
			delete(rawMsg, key)
		case "port":
			err = unpopulate(val, &p.Port)
			delete(rawMsg, key)
		case "serverName":
			err = unpopulate(val, &p.ServerName)
			delete(rawMsg, key)
		case "trustServerCertificate":
			err = unpopulate(val, &p.TrustServerCertificate)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := p.ConnectionInfo.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// Project - A project resource
type Project struct {
	TrackedResource
	// Project properties
	Properties *ProjectProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Project.
func (p Project) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.TrackedResource.marshalInternal(objectMap)
	populate(objectMap, "properties", p.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Project.
func (p *Project) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &p.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := p.TrackedResource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ProjectFile - A file resource
type ProjectFile struct {
	Resource
	// HTTP strong entity tag value. This is ignored if submitted.
	Etag *string `json:"etag,omitempty"`

	// Custom file properties
	Properties *ProjectFileProperties `json:"properties,omitempty"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ProjectFile.
func (p ProjectFile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.Resource.marshalInternal(objectMap)
	populate(objectMap, "etag", p.Etag)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProjectFile.
func (p *ProjectFile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &p.Etag)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &p.Properties)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &p.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := p.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ProjectFileProperties - Base class for file properties.
type ProjectFileProperties struct {
	// Optional File extension. If submitted it should not have a leading period and must match the extension from filePath.
	Extension *string `json:"extension,omitempty"`

	// Relative path of this file resource. This property can be set when creating or updating the file resource.
	FilePath *string `json:"filePath,omitempty"`

	// File content type. This property can be modified to reflect the file content type.
	MediaType *string `json:"mediaType,omitempty"`

	// READ-ONLY; Modification DateTime.
	LastModified *time.Time `json:"lastModified,omitempty" azure:"ro"`

	// READ-ONLY; File size.
	Size *int64 `json:"size,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ProjectFileProperties.
func (p ProjectFileProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "extension", p.Extension)
	populate(objectMap, "filePath", p.FilePath)
	populate(objectMap, "lastModified", (*timeRFC3339)(p.LastModified))
	populate(objectMap, "mediaType", p.MediaType)
	populate(objectMap, "size", p.Size)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProjectFileProperties.
func (p *ProjectFileProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "extension":
			err = unpopulate(val, &p.Extension)
			delete(rawMsg, key)
		case "filePath":
			err = unpopulate(val, &p.FilePath)
			delete(rawMsg, key)
		case "lastModified":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			p.LastModified = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "mediaType":
			err = unpopulate(val, &p.MediaType)
			delete(rawMsg, key)
		case "size":
			err = unpopulate(val, &p.Size)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ProjectList - OData page of project resources
type ProjectList struct {
	// URL to load the next page of projects
	NextLink *string `json:"nextLink,omitempty"`

	// List of projects
	Value []*Project `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ProjectList.
func (p ProjectList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// ProjectProperties - Project-specific properties
type ProjectProperties struct {
	// REQUIRED; Source platform for the project
	SourcePlatform *ProjectSourcePlatform `json:"sourcePlatform,omitempty"`

	// REQUIRED; Target platform for the project
	TargetPlatform *ProjectTargetPlatform `json:"targetPlatform,omitempty"`

	// List of DatabaseInfo
	DatabasesInfo []*DatabaseInfo `json:"databasesInfo,omitempty"`

	// Information for connecting to source
	SourceConnectionInfo ConnectionInfoClassification `json:"sourceConnectionInfo,omitempty"`

	// Information for connecting to target
	TargetConnectionInfo ConnectionInfoClassification `json:"targetConnectionInfo,omitempty"`

	// READ-ONLY; UTC Date and time when project was created
	CreationTime *time.Time `json:"creationTime,omitempty" azure:"ro"`

	// READ-ONLY; The project's provisioning state
	ProvisioningState *ProjectProvisioningState `json:"provisioningState,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ProjectProperties.
func (p ProjectProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "creationTime", (*timeRFC3339)(p.CreationTime))
	populate(objectMap, "databasesInfo", p.DatabasesInfo)
	populate(objectMap, "provisioningState", p.ProvisioningState)
	populate(objectMap, "sourceConnectionInfo", p.SourceConnectionInfo)
	populate(objectMap, "sourcePlatform", p.SourcePlatform)
	populate(objectMap, "targetConnectionInfo", p.TargetConnectionInfo)
	populate(objectMap, "targetPlatform", p.TargetPlatform)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProjectProperties.
func (p *ProjectProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "creationTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			p.CreationTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "databasesInfo":
			err = unpopulate(val, &p.DatabasesInfo)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &p.ProvisioningState)
			delete(rawMsg, key)
		case "sourceConnectionInfo":
			p.SourceConnectionInfo, err = unmarshalConnectionInfoClassification(val)
			delete(rawMsg, key)
		case "sourcePlatform":
			err = unpopulate(val, &p.SourcePlatform)
			delete(rawMsg, key)
		case "targetConnectionInfo":
			p.TargetConnectionInfo, err = unmarshalConnectionInfoClassification(val)
			delete(rawMsg, key)
		case "targetPlatform":
			err = unpopulate(val, &p.TargetPlatform)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ProjectTask - A task resource
type ProjectTask struct {
	Resource
	// HTTP strong entity tag value. This is ignored if submitted.
	Etag *string `json:"etag,omitempty"`

	// Custom task properties
	Properties ProjectTaskPropertiesClassification `json:"properties,omitempty"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ProjectTask.
func (p ProjectTask) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	p.Resource.marshalInternal(objectMap)
	populate(objectMap, "etag", p.Etag)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "systemData", p.SystemData)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProjectTask.
func (p *ProjectTask) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &p.Etag)
			delete(rawMsg, key)
		case "properties":
			p.Properties, err = unmarshalProjectTaskPropertiesClassification(val)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &p.SystemData)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := p.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ProjectTaskPropertiesClassification provides polymorphic access to related types.
// Call the interface's GetProjectTaskProperties() method to access the common type.
// Use a type switch to determine the concrete type.  The possible types are:
// - *CheckOCIDriverTaskProperties, *ConnectToMongoDbTaskProperties, *ConnectToSourceMySqlTaskProperties, *ConnectToSourceOracleSyncTaskProperties,
// - *ConnectToSourcePostgreSqlSyncTaskProperties, *ConnectToSourceSqlServerSyncTaskProperties, *ConnectToSourceSqlServerTaskProperties,
// - *ConnectToTargetAzureDbForMySqlTaskProperties, *ConnectToTargetAzureDbForPostgreSqlSyncTaskProperties, *ConnectToTargetOracleAzureDbForPostgreSqlSyncTaskProperties,
// - *ConnectToTargetSqlDbSyncTaskProperties, *ConnectToTargetSqlDbTaskProperties, *ConnectToTargetSqlMISyncTaskProperties,
// - *ConnectToTargetSqlMITaskProperties, *GetTdeCertificatesSqlTaskProperties, *GetUserTablesMySqlTaskProperties, *GetUserTablesOracleTaskProperties,
// - *GetUserTablesPostgreSqlTaskProperties, *GetUserTablesSqlSyncTaskProperties, *GetUserTablesSqlTaskProperties, *InstallOCIDriverTaskProperties,
// - *MigrateMongoDbTaskProperties, *MigrateMySqlAzureDbForMySqlOfflineTaskProperties, *MigrateMySqlAzureDbForMySqlSyncTaskProperties,
// - *MigrateOracleAzureDbForPostgreSqlSyncTaskProperties, *MigratePostgreSqlAzureDbForPostgreSqlSyncTaskProperties, *MigrateSchemaSqlServerSqlDbTaskProperties,
// - *MigrateSqlServerSqlDbSyncTaskProperties, *MigrateSqlServerSqlDbTaskProperties, *MigrateSqlServerSqlMISyncTaskProperties,
// - *MigrateSqlServerSqlMITaskProperties, *MigrateSsisTaskProperties, *ProjectTaskProperties, *UploadOCIDriverTaskProperties,
// - *ValidateMigrationInputSqlServerSqlDbSyncTaskProperties, *ValidateMigrationInputSqlServerSqlMISyncTaskProperties, *ValidateMigrationInputSqlServerSqlMITaskProperties,
// - *ValidateMongoDbTaskProperties, *ValidateOracleAzureDbForPostgreSqlSyncTaskProperties
type ProjectTaskPropertiesClassification interface {
	// GetProjectTaskProperties returns the ProjectTaskProperties content of the underlying type.
	GetProjectTaskProperties() *ProjectTaskProperties
}

// ProjectTaskProperties - Base class for all types of DMS task properties. If task is not supported by current client, this object is returned.
type ProjectTaskProperties struct {
	// REQUIRED; Task type.
	TaskType *string `json:"taskType,omitempty"`

	// Key value pairs of client data to attach meta data information to task
	ClientData map[string]*string `json:"clientData,omitempty"`

	// READ-ONLY; Array of command properties.
	Commands []CommandPropertiesClassification `json:"commands,omitempty" azure:"ro"`

	// READ-ONLY; Array of errors. This is ignored if submitted.
	Errors []*ODataError `json:"errors,omitempty" azure:"ro"`

	// READ-ONLY; The state of the task. This is ignored if submitted.
	State *TaskState `json:"state,omitempty" azure:"ro"`
}

// GetProjectTaskProperties implements the ProjectTaskPropertiesClassification interface for type ProjectTaskProperties.
func (p *ProjectTaskProperties) GetProjectTaskProperties() *ProjectTaskProperties { return p }

// UnmarshalJSON implements the json.Unmarshaller interface for type ProjectTaskProperties.
func (p *ProjectTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return p.unmarshalInternal(rawMsg)
}

func (p ProjectTaskProperties) marshalInternal(objectMap map[string]interface{}, discValue string) {
	populate(objectMap, "clientData", p.ClientData)
	populate(objectMap, "commands", p.Commands)
	populate(objectMap, "errors", p.Errors)
	populate(objectMap, "state", p.State)
	p.TaskType = &discValue
	objectMap["taskType"] = p.TaskType
}

func (p *ProjectTaskProperties) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientData":
			err = unpopulate(val, &p.ClientData)
			delete(rawMsg, key)
		case "commands":
			p.Commands, err = unmarshalCommandPropertiesClassificationArray(val)
			delete(rawMsg, key)
		case "errors":
			err = unpopulate(val, &p.Errors)
			delete(rawMsg, key)
		case "state":
			err = unpopulate(val, &p.State)
			delete(rawMsg, key)
		case "taskType":
			err = unpopulate(val, &p.TaskType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ProjectsCreateOrUpdateOptions contains the optional parameters for the Projects.CreateOrUpdate method.
type ProjectsCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ProjectsDeleteOptions contains the optional parameters for the Projects.Delete method.
type ProjectsDeleteOptions struct {
	// Delete the resource even if it contains running tasks
	DeleteRunningTasks *bool
}

// ProjectsGetOptions contains the optional parameters for the Projects.Get method.
type ProjectsGetOptions struct {
	// placeholder for future optional parameters
}

// ProjectsListOptions contains the optional parameters for the Projects.List method.
type ProjectsListOptions struct {
	// placeholder for future optional parameters
}

// ProjectsUpdateOptions contains the optional parameters for the Projects.Update method.
type ProjectsUpdateOptions struct {
	// placeholder for future optional parameters
}

// QueryAnalysisValidationResult - Results for query analysis comparison between the source and target
type QueryAnalysisValidationResult struct {
	// List of queries executed and it's execution results in source and target
	QueryResults *QueryExecutionResult `json:"queryResults,omitempty"`

	// Errors that are part of the execution
	ValidationErrors *ValidationError `json:"validationErrors,omitempty"`
}

// QueryExecutionResult - Describes query analysis results for execution in source and target
type QueryExecutionResult struct {
	// Query text retrieved from the source server
	QueryText *string `json:"queryText,omitempty"`

	// Query analysis result from the source
	SourceResult *ExecutionStatistics `json:"sourceResult,omitempty"`

	// Total no. of statements in the batch
	StatementsInBatch *int64 `json:"statementsInBatch,omitempty"`

	// Query analysis result from the target
	TargetResult *ExecutionStatistics `json:"targetResult,omitempty"`
}

// Quota - Describes a quota for or usage details about a resource
type Quota struct {
	// The current value of the quota. If null or missing, the current value cannot be determined in the context of the request.
	CurrentValue *float64 `json:"currentValue,omitempty"`

	// The resource ID of the quota object
	ID *string `json:"id,omitempty"`

	// The maximum value of the quota. If null or missing, the quota has no maximum, in which case it merely tracks usage.
	Limit *float64 `json:"limit,omitempty"`

	// The name of the quota
	Name *QuotaName `json:"name,omitempty"`

	// The unit for the quota, such as Count, Bytes, BytesPerSecond, etc.
	Unit *string `json:"unit,omitempty"`
}

// QuotaList - OData page of quota objects
type QuotaList struct {
	// URL to load the next page of quotas, or null or missing if this is the last page
	NextLink *string `json:"nextLink,omitempty"`

	// List of quotas
	Value []*Quota `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type QuotaList.
func (q QuotaList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", q.NextLink)
	populate(objectMap, "value", q.Value)
	return json.Marshal(objectMap)
}

// QuotaName - The name of the quota
type QuotaName struct {
	// The localized name of the quota
	LocalizedValue *string `json:"localizedValue,omitempty"`

	// The unlocalized name (or ID) of the quota
	Value *string `json:"value,omitempty"`
}

// ReportableException - Exception object for all custom exceptions
type ReportableException struct {
	// Actionable steps for this exception
	ActionableMessage *string `json:"actionableMessage,omitempty"`

	// The path to the file where exception occurred
	FilePath *string `json:"filePath,omitempty"`

	// Coded numerical value that is assigned to a specific exception
	HResult *int32 `json:"hResult,omitempty"`

	// The line number where exception occurred
	LineNumber *string `json:"lineNumber,omitempty"`

	// Error message
	Message *string `json:"message,omitempty"`

	// Stack trace
	StackTrace *string `json:"stackTrace,omitempty"`
}

// Resource - ARM resource.
type Resource struct {
	// READ-ONLY; Resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Resource.
func (r *Resource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return r.unmarshalInternal(rawMsg)
}

func (r Resource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "id", r.ID)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "type", r.Type)
}

func (r *Resource) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &r.ID)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &r.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ResourceSKU - Describes an available DMS SKU.
type ResourceSKU struct {
	// READ-ONLY; The api versions that support this SKU.
	APIVersions []*string `json:"apiVersions,omitempty" azure:"ro"`

	// READ-ONLY; A name value pair to describe the capability.
	Capabilities []*ResourceSKUCapabilities `json:"capabilities,omitempty" azure:"ro"`

	// READ-ONLY; Not used.
	Capacity *ResourceSKUCapacity `json:"capacity,omitempty" azure:"ro"`

	// READ-ONLY; Metadata for retrieving price info.
	Costs []*ResourceSKUCosts `json:"costs,omitempty" azure:"ro"`

	// READ-ONLY; The Family of this particular SKU.
	Family *string `json:"family,omitempty" azure:"ro"`

	// READ-ONLY; The Kind of resources that are supported in this SKU.
	Kind *string `json:"kind,omitempty" azure:"ro"`

	// READ-ONLY; The set of locations that the SKU is available.
	Locations []*string `json:"locations,omitempty" azure:"ro"`

	// READ-ONLY; The name of SKU.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The type of resource the SKU applies to.
	ResourceType *string `json:"resourceType,omitempty" azure:"ro"`

	// READ-ONLY; The restrictions because of which SKU cannot be used. This is empty if there are no restrictions.
	Restrictions []*ResourceSKURestrictions `json:"restrictions,omitempty" azure:"ro"`

	// READ-ONLY; The Size of the SKU.
	Size *string `json:"size,omitempty" azure:"ro"`

	// READ-ONLY; Specifies the tier of DMS in a scale set.
	Tier *string `json:"tier,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceSKU.
func (r ResourceSKU) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "apiVersions", r.APIVersions)
	populate(objectMap, "capabilities", r.Capabilities)
	populate(objectMap, "capacity", r.Capacity)
	populate(objectMap, "costs", r.Costs)
	populate(objectMap, "family", r.Family)
	populate(objectMap, "kind", r.Kind)
	populate(objectMap, "locations", r.Locations)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "resourceType", r.ResourceType)
	populate(objectMap, "restrictions", r.Restrictions)
	populate(objectMap, "size", r.Size)
	populate(objectMap, "tier", r.Tier)
	return json.Marshal(objectMap)
}

// ResourceSKUCapabilities - Describes The SKU capabilities object.
type ResourceSKUCapabilities struct {
	// READ-ONLY; An invariant to describe the feature.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; An invariant if the feature is measured by quantity.
	Value *string `json:"value,omitempty" azure:"ro"`
}

// ResourceSKUCapacity - Describes scaling information of a SKU.
type ResourceSKUCapacity struct {
	// READ-ONLY; The default capacity.
	Default *int64 `json:"default,omitempty" azure:"ro"`

	// READ-ONLY; The maximum capacity.
	Maximum *int64 `json:"maximum,omitempty" azure:"ro"`

	// READ-ONLY; The minimum capacity.
	Minimum *int64 `json:"minimum,omitempty" azure:"ro"`

	// READ-ONLY; The scale type applicable to the SKU.
	ScaleType *ResourceSKUCapacityScaleType `json:"scaleType,omitempty" azure:"ro"`
}

// ResourceSKUCosts - Describes metadata for retrieving price info.
type ResourceSKUCosts struct {
	// READ-ONLY; An invariant to show the extended unit.
	ExtendedUnit *string `json:"extendedUnit,omitempty" azure:"ro"`

	// READ-ONLY; Used for querying price from commerce.
	MeterID *string `json:"meterID,omitempty" azure:"ro"`

	// READ-ONLY; The multiplier is needed to extend the base metered cost.
	Quantity *int64 `json:"quantity,omitempty" azure:"ro"`
}

// ResourceSKURestrictions - Describes scaling information of a SKU.
type ResourceSKURestrictions struct {
	// READ-ONLY; The reason code for restriction.
	ReasonCode *ResourceSKURestrictionsReasonCode `json:"reasonCode,omitempty" azure:"ro"`

	// READ-ONLY; The type of restrictions.
	Type *ResourceSKURestrictionsType `json:"type,omitempty" azure:"ro"`

	// READ-ONLY; The value of restrictions. If the restriction type is set to location. This would be different locations where the SKU is restricted.
	Values []*string `json:"values,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceSKURestrictions.
func (r ResourceSKURestrictions) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "reasonCode", r.ReasonCode)
	populate(objectMap, "type", r.Type)
	populate(objectMap, "values", r.Values)
	return json.Marshal(objectMap)
}

// ResourceSKUsListSKUsOptions contains the optional parameters for the ResourceSKUs.ListSKUs method.
type ResourceSKUsListSKUsOptions struct {
	// placeholder for future optional parameters
}

// ResourceSKUsResult - The DMS List SKUs operation response.
type ResourceSKUsResult struct {
	// REQUIRED; The list of SKUs available for the subscription.
	Value []*ResourceSKU `json:"value,omitempty"`

	// The uri to fetch the next page of DMS SKUs. Call ListNext() with this to fetch the next page of DMS SKUs.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ResourceSKUsResult.
func (r ResourceSKUsResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// SQLConnectionInfo - Information for connecting to SQL database server
type SQLConnectionInfo struct {
	ConnectionInfo
	// REQUIRED; Data source in the format Protocol:MachineName\SQLServerInstanceName,PortNumber
	DataSource *string `json:"dataSource,omitempty"`

	// Additional connection settings
	AdditionalSettings *string `json:"additionalSettings,omitempty"`

	// Authentication type to use for connection
	Authentication *AuthenticationType `json:"authentication,omitempty"`

	// Whether to encrypt the connection
	EncryptConnection *bool `json:"encryptConnection,omitempty"`

	// Server platform type for connection
	Platform *SQLSourcePlatform `json:"platform,omitempty"`

	// Whether to trust the server certificate
	TrustServerCertificate *bool `json:"trustServerCertificate,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLConnectionInfo.
func (s SQLConnectionInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.ConnectionInfo.marshalInternal(objectMap, "SqlConnectionInfo")
	populate(objectMap, "additionalSettings", s.AdditionalSettings)
	populate(objectMap, "authentication", s.Authentication)
	populate(objectMap, "dataSource", s.DataSource)
	populate(objectMap, "encryptConnection", s.EncryptConnection)
	populate(objectMap, "platform", s.Platform)
	populate(objectMap, "trustServerCertificate", s.TrustServerCertificate)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SQLConnectionInfo.
func (s *SQLConnectionInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "additionalSettings":
			err = unpopulate(val, &s.AdditionalSettings)
			delete(rawMsg, key)
		case "authentication":
			err = unpopulate(val, &s.Authentication)
			delete(rawMsg, key)
		case "dataSource":
			err = unpopulate(val, &s.DataSource)
			delete(rawMsg, key)
		case "encryptConnection":
			err = unpopulate(val, &s.EncryptConnection)
			delete(rawMsg, key)
		case "platform":
			err = unpopulate(val, &s.Platform)
			delete(rawMsg, key)
		case "trustServerCertificate":
			err = unpopulate(val, &s.TrustServerCertificate)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.ConnectionInfo.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SQLMigrationTaskInput - Base class for migration task input
type SQLMigrationTaskInput struct {
	// REQUIRED; Information for connecting to source
	SourceConnectionInfo *SQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Information for connecting to target
	TargetConnectionInfo *SQLConnectionInfo `json:"targetConnectionInfo,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLMigrationTaskInput.
func (s SQLMigrationTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (s SQLMigrationTaskInput) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "sourceConnectionInfo", s.SourceConnectionInfo)
	populate(objectMap, "targetConnectionInfo", s.TargetConnectionInfo)
}

// SQLServerSQLMISyncTaskInput - Input for task that migrates SQL Server databases to Azure SQL Database Managed Instance online scenario.
type SQLServerSQLMISyncTaskInput struct {
	// REQUIRED; Azure Active Directory Application the DMS instance will use to connect to the target instance of Azure SQL Database Managed Instance and the
	// Azure Storage Account
	AzureApp *AzureActiveDirectoryApp `json:"azureApp,omitempty"`

	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateSQLServerSQLMIDatabaseInput `json:"selectedDatabases,omitempty"`

	// REQUIRED; Connection information for source SQL Server
	SourceConnectionInfo *SQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Fully qualified resourceId of storage
	StorageResourceID *string `json:"storageResourceId,omitempty"`

	// REQUIRED; Connection information for Azure SQL Database Managed Instance
	TargetConnectionInfo *MiSQLConnectionInfo `json:"targetConnectionInfo,omitempty"`

	// Backup file share information for all selected databases.
	BackupFileShare *FileShare `json:"backupFileShare,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SQLServerSQLMISyncTaskInput.
func (s SQLServerSQLMISyncTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (s SQLServerSQLMISyncTaskInput) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "azureApp", s.AzureApp)
	populate(objectMap, "backupFileShare", s.BackupFileShare)
	populate(objectMap, "selectedDatabases", s.SelectedDatabases)
	populate(objectMap, "sourceConnectionInfo", s.SourceConnectionInfo)
	populate(objectMap, "storageResourceId", s.StorageResourceID)
	populate(objectMap, "targetConnectionInfo", s.TargetConnectionInfo)
}

// SchemaComparisonValidationResult - Results for schema comparison between the source and target
type SchemaComparisonValidationResult struct {
	// List of schema differences between the source and target databases
	SchemaDifferences *SchemaComparisonValidationResultType `json:"schemaDifferences,omitempty"`

	// Count of source database objects
	SourceDatabaseObjectCount map[string]*int64 `json:"sourceDatabaseObjectCount,omitempty"`

	// Count of target database objects
	TargetDatabaseObjectCount map[string]*int64 `json:"targetDatabaseObjectCount,omitempty"`

	// List of errors that happened while performing schema compare validation
	ValidationErrors *ValidationError `json:"validationErrors,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SchemaComparisonValidationResult.
func (s SchemaComparisonValidationResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "schemaDifferences", s.SchemaDifferences)
	populate(objectMap, "sourceDatabaseObjectCount", s.SourceDatabaseObjectCount)
	populate(objectMap, "targetDatabaseObjectCount", s.TargetDatabaseObjectCount)
	populate(objectMap, "validationErrors", s.ValidationErrors)
	return json.Marshal(objectMap)
}

// SchemaComparisonValidationResultType - Description about the errors happen while performing migration validation
type SchemaComparisonValidationResultType struct {
	// Name of the object that has the difference
	ObjectName *string `json:"objectName,omitempty"`

	// Type of the object that has the difference. e.g (Table/View/StoredProcedure)
	ObjectType *ObjectType `json:"objectType,omitempty"`

	// Update action type with respect to target
	UpdateAction *UpdateActionType `json:"updateAction,omitempty"`
}

// SchemaMigrationSetting - Settings for migrating schema from source to target
type SchemaMigrationSetting struct {
	// Resource Identifier of a file resource containing the uploaded schema file
	FileID *string `json:"fileId,omitempty"`

	// Option on how to migrate the schema
	SchemaOption *SchemaMigrationOption `json:"schemaOption,omitempty"`
}

// SelectedCertificateInput - Info for certificate to be exported for TDE enabled databases.
type SelectedCertificateInput struct {
	// REQUIRED; Name of certificate to be exported.
	CertificateName *string `json:"certificateName,omitempty"`

	// REQUIRED; Password to use for encrypting the exported certificate.
	Password *string `json:"password,omitempty"`
}

// ServerProperties - Server properties for MySQL type source
type ServerProperties struct {
	// READ-ONLY; Number of databases in the server
	ServerDatabaseCount *int32 `json:"serverDatabaseCount,omitempty" azure:"ro"`

	// READ-ONLY; Edition of the database server
	ServerEdition *string `json:"serverEdition,omitempty" azure:"ro"`

	// READ-ONLY; Name of the server
	ServerName *string `json:"serverName,omitempty" azure:"ro"`

	// READ-ONLY; Version of the operating system
	ServerOperatingSystemVersion *string `json:"serverOperatingSystemVersion,omitempty" azure:"ro"`

	// READ-ONLY; Name of the server platform
	ServerPlatform *string `json:"serverPlatform,omitempty" azure:"ro"`

	// READ-ONLY; Version of the database server
	ServerVersion *string `json:"serverVersion,omitempty" azure:"ro"`
}

// ServiceOperation - Description of an action supported by the Database Migration Service
type ServiceOperation struct {
	// Localized display text
	Display *ServiceOperationDisplay `json:"display,omitempty"`

	// The fully qualified action name, e.g. Microsoft.DataMigration/services/read
	Name *string `json:"name,omitempty"`
}

// ServiceOperationDisplay - Localized display text
type ServiceOperationDisplay struct {
	// The localized operation description
	Description *string `json:"description,omitempty"`

	// The localized operation name
	Operation *string `json:"operation,omitempty"`

	// The localized resource provider name
	Provider *string `json:"provider,omitempty"`

	// The localized resource type name
	Resource *string `json:"resource,omitempty"`
}

// ServiceOperationList - OData page of action (operation) objects
type ServiceOperationList struct {
	// URL to load the next page of actions
	NextLink *string `json:"nextLink,omitempty"`

	// List of actions
	Value []*ServiceOperation `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceOperationList.
func (s ServiceOperationList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// ServiceSKU - An Azure SKU instance
type ServiceSKU struct {
	// The capacity of the SKU, if it supports scaling
	Capacity *int32 `json:"capacity,omitempty"`

	// The SKU family, used when the service has multiple performance classes within a tier, such as 'A', 'D', etc. for virtual machines
	Family *string `json:"family,omitempty"`

	// The unique name of the SKU, such as 'P3'
	Name *string `json:"name,omitempty"`

	// The size of the SKU, used when the name alone does not denote a service size or when a SKU has multiple performance classes within a family, e.g. 'A1'
	// for virtual machines
	Size *string `json:"size,omitempty"`

	// The tier of the SKU, such as 'Basic', 'General Purpose', or 'Business Critical'
	Tier *string `json:"tier,omitempty"`
}

// ServiceSKUList - OData page of available SKUs
type ServiceSKUList struct {
	// URL to load the next page of service SKUs
	NextLink *string `json:"nextLink,omitempty"`

	// List of service SKUs
	Value []*AvailableServiceSKU `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ServiceSKUList.
func (s ServiceSKUList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", s.NextLink)
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// ServiceTasksCancelOptions contains the optional parameters for the ServiceTasks.Cancel method.
type ServiceTasksCancelOptions struct {
	// placeholder for future optional parameters
}

// ServiceTasksCreateOrUpdateOptions contains the optional parameters for the ServiceTasks.CreateOrUpdate method.
type ServiceTasksCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ServiceTasksDeleteOptions contains the optional parameters for the ServiceTasks.Delete method.
type ServiceTasksDeleteOptions struct {
	// Delete the resource even if it contains running tasks
	DeleteRunningTasks *bool
}

// ServiceTasksGetOptions contains the optional parameters for the ServiceTasks.Get method.
type ServiceTasksGetOptions struct {
	// Expand the response
	Expand *string
}

// ServiceTasksListOptions contains the optional parameters for the ServiceTasks.List method.
type ServiceTasksListOptions struct {
	// Filter tasks by task type
	TaskType *string
}

// ServiceTasksUpdateOptions contains the optional parameters for the ServiceTasks.Update method.
type ServiceTasksUpdateOptions struct {
	// placeholder for future optional parameters
}

// ServicesBeginCreateOrUpdateOptions contains the optional parameters for the Services.BeginCreateOrUpdate method.
type ServicesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ServicesBeginDeleteOptions contains the optional parameters for the Services.BeginDelete method.
type ServicesBeginDeleteOptions struct {
	// Delete the resource even if it contains running tasks
	DeleteRunningTasks *bool
}

// ServicesBeginStartOptions contains the optional parameters for the Services.BeginStart method.
type ServicesBeginStartOptions struct {
	// placeholder for future optional parameters
}

// ServicesBeginStopOptions contains the optional parameters for the Services.BeginStop method.
type ServicesBeginStopOptions struct {
	// placeholder for future optional parameters
}

// ServicesBeginUpdateOptions contains the optional parameters for the Services.BeginUpdate method.
type ServicesBeginUpdateOptions struct {
	// placeholder for future optional parameters
}

// ServicesCheckChildrenNameAvailabilityOptions contains the optional parameters for the Services.CheckChildrenNameAvailability method.
type ServicesCheckChildrenNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// ServicesCheckNameAvailabilityOptions contains the optional parameters for the Services.CheckNameAvailability method.
type ServicesCheckNameAvailabilityOptions struct {
	// placeholder for future optional parameters
}

// ServicesCheckStatusOptions contains the optional parameters for the Services.CheckStatus method.
type ServicesCheckStatusOptions struct {
	// placeholder for future optional parameters
}

// ServicesGetOptions contains the optional parameters for the Services.Get method.
type ServicesGetOptions struct {
	// placeholder for future optional parameters
}

// ServicesListByResourceGroupOptions contains the optional parameters for the Services.ListByResourceGroup method.
type ServicesListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// ServicesListOptions contains the optional parameters for the Services.List method.
type ServicesListOptions struct {
	// placeholder for future optional parameters
}

// ServicesListSKUsOptions contains the optional parameters for the Services.ListSKUs method.
type ServicesListSKUsOptions struct {
	// placeholder for future optional parameters
}

// SsisMigrationInfo - SSIS migration info with SSIS store type, overwrite policy.
type SsisMigrationInfo struct {
	// The overwrite option for the SSIS environment migration
	EnvironmentOverwriteOption *SsisMigrationOverwriteOption `json:"environmentOverwriteOption,omitempty"`

	// The overwrite option for the SSIS project migration
	ProjectOverwriteOption *SsisMigrationOverwriteOption `json:"projectOverwriteOption,omitempty"`

	// The SSIS store type of source, only SSIS catalog is supported now in DMS
	SsisStoreType *SsisStoreType `json:"ssisStoreType,omitempty"`
}

// StartMigrationScenarioServerRoleResult - Server role migration result
type StartMigrationScenarioServerRoleResult struct {
	// READ-ONLY; Migration exceptions and warnings.
	ExceptionsAndWarnings []*ReportableException `json:"exceptionsAndWarnings,omitempty" azure:"ro"`

	// READ-ONLY; Name of server role.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Current state of migration
	State *MigrationState `json:"state,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type StartMigrationScenarioServerRoleResult.
func (s StartMigrationScenarioServerRoleResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "exceptionsAndWarnings", s.ExceptionsAndWarnings)
	populate(objectMap, "name", s.Name)
	populate(objectMap, "state", s.State)
	return json.Marshal(objectMap)
}

// SyncMigrationDatabaseErrorEvent - Database migration errors for online migration
type SyncMigrationDatabaseErrorEvent struct {
	// READ-ONLY; Event text.
	EventText *string `json:"eventText,omitempty" azure:"ro"`

	// READ-ONLY; Event type.
	EventTypeString *string `json:"eventTypeString,omitempty" azure:"ro"`

	// READ-ONLY; String value of timestamp.
	TimestampString *string `json:"timestampString,omitempty" azure:"ro"`
}

// SystemData - Metadata pertaining to creation and last modification of the resource.
type SystemData struct {
	// The timestamp of resource creation (UTC).
	CreatedAt *time.Time `json:"createdAt,omitempty"`

	// The identity that created the resource.
	CreatedBy *string `json:"createdBy,omitempty"`

	// The type of identity that created the resource.
	CreatedByType *CreatedByType `json:"createdByType,omitempty"`

	// The timestamp of resource last modification (UTC)
	LastModifiedAt *time.Time `json:"lastModifiedAt,omitempty"`

	// The identity that last modified the resource.
	LastModifiedBy *string `json:"lastModifiedBy,omitempty"`

	// The type of identity that last modified the resource.
	LastModifiedByType *CreatedByType `json:"lastModifiedByType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "createdAt", (*timeRFC3339)(s.CreatedAt))
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populate(objectMap, "lastModifiedAt", (*timeRFC3339)(s.LastModifiedAt))
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.CreatedAt = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			s.LastModifiedAt = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// TaskList - OData page of tasks
type TaskList struct {
	// URL to load the next page of tasks
	NextLink *string `json:"nextLink,omitempty"`

	// List of tasks
	Value []*ProjectTask `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TaskList.
func (t TaskList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", t.NextLink)
	populate(objectMap, "value", t.Value)
	return json.Marshal(objectMap)
}

// TasksCancelOptions contains the optional parameters for the Tasks.Cancel method.
type TasksCancelOptions struct {
	// placeholder for future optional parameters
}

// TasksCommandOptions contains the optional parameters for the Tasks.Command method.
type TasksCommandOptions struct {
	// placeholder for future optional parameters
}

// TasksCreateOrUpdateOptions contains the optional parameters for the Tasks.CreateOrUpdate method.
type TasksCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// TasksDeleteOptions contains the optional parameters for the Tasks.Delete method.
type TasksDeleteOptions struct {
	// Delete the resource even if it contains running tasks
	DeleteRunningTasks *bool
}

// TasksGetOptions contains the optional parameters for the Tasks.Get method.
type TasksGetOptions struct {
	// Expand the response
	Expand *string
}

// TasksListOptions contains the optional parameters for the Tasks.List method.
type TasksListOptions struct {
	// Filter tasks by task type
	TaskType *string
}

// TasksUpdateOptions contains the optional parameters for the Tasks.Update method.
type TasksUpdateOptions struct {
	// placeholder for future optional parameters
}

// TrackedResource - ARM tracked top level resource.
type TrackedResource struct {
	Resource
	// REQUIRED; Resource location.
	Location *string `json:"location,omitempty"`

	// Resource tags.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; Metadata pertaining to creation and last modification of the resource.
	SystemData *SystemData `json:"systemData,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type TrackedResource.
func (t TrackedResource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	t.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TrackedResource.
func (t *TrackedResource) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return t.unmarshalInternal(rawMsg)
}

func (t TrackedResource) marshalInternal(objectMap map[string]interface{}) {
	t.Resource.marshalInternal(objectMap)
	populate(objectMap, "location", t.Location)
	populate(objectMap, "systemData", t.SystemData)
	populate(objectMap, "tags", t.Tags)
}

func (t *TrackedResource) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "location":
			err = unpopulate(val, &t.Location)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &t.SystemData)
			delete(rawMsg, key)
		case "tags":
			err = unpopulate(val, &t.Tags)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := t.Resource.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// UploadOCIDriverTaskInput - Input for the service task to upload an OCI driver.
type UploadOCIDriverTaskInput struct {
	// File share information for the OCI driver archive.
	DriverShare *FileShare `json:"driverShare,omitempty"`
}

// UploadOCIDriverTaskOutput - Output for the service task to upload an OCI driver.
type UploadOCIDriverTaskOutput struct {
	// READ-ONLY; The name of the driver package that was validated and uploaded.
	DriverPackageName *string `json:"driverPackageName,omitempty" azure:"ro"`

	// READ-ONLY; Validation errors
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type UploadOCIDriverTaskOutput.
func (u UploadOCIDriverTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "driverPackageName", u.DriverPackageName)
	populate(objectMap, "validationErrors", u.ValidationErrors)
	return json.Marshal(objectMap)
}

// UploadOCIDriverTaskProperties - Properties for the task that uploads an OCI driver.
type UploadOCIDriverTaskProperties struct {
	ProjectTaskProperties
	// Input for the service task to upload an OCI driver.
	Input *UploadOCIDriverTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*UploadOCIDriverTaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type UploadOCIDriverTaskProperties.
func (u UploadOCIDriverTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	u.ProjectTaskProperties.marshalInternal(objectMap, "Service.Upload.OCI")
	populate(objectMap, "input", u.Input)
	populate(objectMap, "output", u.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UploadOCIDriverTaskProperties.
func (u *UploadOCIDriverTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &u.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &u.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := u.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// UsagesListOptions contains the optional parameters for the Usages.List method.
type UsagesListOptions struct {
	// placeholder for future optional parameters
}

// ValidateMigrationInputSQLServerSQLDbSyncTaskProperties - Properties for task that validates migration input for SQL to Azure SQL DB sync migrations
type ValidateMigrationInputSQLServerSQLDbSyncTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *ValidateSyncMigrationInputSQLServerTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ValidateSyncMigrationInputSQLServerTaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidateMigrationInputSQLServerSQLDbSyncTaskProperties.
func (v ValidateMigrationInputSQLServerSQLDbSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	v.ProjectTaskProperties.marshalInternal(objectMap, "ValidateMigrationInput.SqlServer.SqlDb.Sync")
	populate(objectMap, "input", v.Input)
	populate(objectMap, "output", v.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateMigrationInputSQLServerSQLDbSyncTaskProperties.
func (v *ValidateMigrationInputSQLServerSQLDbSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &v.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &v.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := v.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ValidateMigrationInputSQLServerSQLMISyncTaskInput - Input for task that migrates SQL Server databases to Azure SQL Database Managed Instance online scenario.
type ValidateMigrationInputSQLServerSQLMISyncTaskInput struct {
	SQLServerSQLMISyncTaskInput
}

// ValidateMigrationInputSQLServerSQLMISyncTaskOutput - Output for task that validates migration input for Azure SQL Database Managed Instance online migration
type ValidateMigrationInputSQLServerSQLMISyncTaskOutput struct {
	// READ-ONLY; Database identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of database
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Errors associated with a selected database object
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidateMigrationInputSQLServerSQLMISyncTaskOutput.
func (v ValidateMigrationInputSQLServerSQLMISyncTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", v.ID)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "validationErrors", v.ValidationErrors)
	return json.Marshal(objectMap)
}

// ValidateMigrationInputSQLServerSQLMISyncTaskProperties - Properties for task that validates migration input for SQL to Azure SQL Database Managed Instance
// sync scenario
type ValidateMigrationInputSQLServerSQLMISyncTaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *ValidateMigrationInputSQLServerSQLMISyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ValidateMigrationInputSQLServerSQLMISyncTaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidateMigrationInputSQLServerSQLMISyncTaskProperties.
func (v ValidateMigrationInputSQLServerSQLMISyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	v.ProjectTaskProperties.marshalInternal(objectMap, "ValidateMigrationInput.SqlServer.AzureSqlDbMI.Sync.LRS")
	populate(objectMap, "input", v.Input)
	populate(objectMap, "output", v.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateMigrationInputSQLServerSQLMISyncTaskProperties.
func (v *ValidateMigrationInputSQLServerSQLMISyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &v.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &v.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := v.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ValidateMigrationInputSQLServerSQLMITaskInput - Input for task that validates migration input for SQL to Azure SQL Managed Instance
type ValidateMigrationInputSQLServerSQLMITaskInput struct {
	// REQUIRED; SAS URI of Azure Storage Account Container to be used for storing backup files.
	BackupBlobShare *BlobShare `json:"backupBlobShare,omitempty"`

	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateSQLServerSQLMIDatabaseInput `json:"selectedDatabases,omitempty"`

	// REQUIRED; Information for connecting to source
	SourceConnectionInfo *SQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Information for connecting to target
	TargetConnectionInfo *SQLConnectionInfo `json:"targetConnectionInfo,omitempty"`

	// Backup file share information for all selected databases.
	BackupFileShare *FileShare `json:"backupFileShare,omitempty"`

	// Backup Mode to specify whether to use existing backup or create new backup.
	BackupMode *BackupMode `json:"backupMode,omitempty"`

	// Logins to migrate
	SelectedLogins []*string `json:"selectedLogins,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidateMigrationInputSQLServerSQLMITaskInput.
func (v ValidateMigrationInputSQLServerSQLMITaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupBlobShare", v.BackupBlobShare)
	populate(objectMap, "backupFileShare", v.BackupFileShare)
	populate(objectMap, "backupMode", v.BackupMode)
	populate(objectMap, "selectedDatabases", v.SelectedDatabases)
	populate(objectMap, "selectedLogins", v.SelectedLogins)
	populate(objectMap, "sourceConnectionInfo", v.SourceConnectionInfo)
	populate(objectMap, "targetConnectionInfo", v.TargetConnectionInfo)
	return json.Marshal(objectMap)
}

// ValidateMigrationInputSQLServerSQLMITaskOutput - Output for task that validates migration input for SQL to Azure SQL Managed Instance migrations
type ValidateMigrationInputSQLServerSQLMITaskOutput struct {
	// Information about backup files when existing backup mode is used.
	DatabaseBackupInfo *DatabaseBackupInfo `json:"databaseBackupInfo,omitempty"`

	// READ-ONLY; Errors associated with the BackupFolder path
	BackupFolderErrors []*ReportableException `json:"backupFolderErrors,omitempty" azure:"ro"`

	// READ-ONLY; Errors associated with backup share user name and password credentials
	BackupShareCredentialsErrors []*ReportableException `json:"backupShareCredentialsErrors,omitempty" azure:"ro"`

	// READ-ONLY; Errors associated with the storage account provided.
	BackupStorageAccountErrors []*ReportableException `json:"backupStorageAccountErrors,omitempty" azure:"ro"`

	// READ-ONLY; Errors associated with existing backup files.
	ExistingBackupErrors []*ReportableException `json:"existingBackupErrors,omitempty" azure:"ro"`

	// READ-ONLY; Result identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of database
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Errors associated with the RestoreDatabaseName
	RestoreDatabaseNameErrors []*ReportableException `json:"restoreDatabaseNameErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidateMigrationInputSQLServerSQLMITaskOutput.
func (v ValidateMigrationInputSQLServerSQLMITaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupFolderErrors", v.BackupFolderErrors)
	populate(objectMap, "backupShareCredentialsErrors", v.BackupShareCredentialsErrors)
	populate(objectMap, "backupStorageAccountErrors", v.BackupStorageAccountErrors)
	populate(objectMap, "databaseBackupInfo", v.DatabaseBackupInfo)
	populate(objectMap, "existingBackupErrors", v.ExistingBackupErrors)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "restoreDatabaseNameErrors", v.RestoreDatabaseNameErrors)
	return json.Marshal(objectMap)
}

// ValidateMigrationInputSQLServerSQLMITaskProperties - Properties for task that validates migration input for SQL to Azure SQL Database Managed Instance
type ValidateMigrationInputSQLServerSQLMITaskProperties struct {
	ProjectTaskProperties
	// Task input
	Input *ValidateMigrationInputSQLServerSQLMITaskInput `json:"input,omitempty"`

	// READ-ONLY; Task output. This is ignored if submitted.
	Output []*ValidateMigrationInputSQLServerSQLMITaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidateMigrationInputSQLServerSQLMITaskProperties.
func (v ValidateMigrationInputSQLServerSQLMITaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	v.ProjectTaskProperties.marshalInternal(objectMap, "ValidateMigrationInput.SqlServer.AzureSqlDbMI")
	populate(objectMap, "input", v.Input)
	populate(objectMap, "output", v.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateMigrationInputSQLServerSQLMITaskProperties.
func (v *ValidateMigrationInputSQLServerSQLMITaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &v.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &v.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := v.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ValidateMongoDbTaskProperties - Properties for the task that validates a migration between MongoDB data sources
type ValidateMongoDbTaskProperties struct {
	ProjectTaskProperties
	// Describes how a MongoDB data migration should be performed
	Input *MongoDbMigrationSettings `json:"input,omitempty"`

	// READ-ONLY; An array containing a single MongoDbMigrationProgress object
	Output []*MongoDbMigrationProgress `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidateMongoDbTaskProperties.
func (v ValidateMongoDbTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	v.ProjectTaskProperties.marshalInternal(objectMap, "Validate.MongoDb")
	populate(objectMap, "input", v.Input)
	populate(objectMap, "output", v.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateMongoDbTaskProperties.
func (v *ValidateMongoDbTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &v.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &v.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := v.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ValidateOracleAzureDbForPostgreSQLSyncTaskProperties - Properties for the task that validates a migration for Oracle to Azure Database for PostgreSQL
// for online migrations
type ValidateOracleAzureDbForPostgreSQLSyncTaskProperties struct {
	ProjectTaskProperties
	// Input for the task that migrates Oracle databases to Azure Database for PostgreSQL for online migrations
	Input *MigrateOracleAzureDbPostgreSQLSyncTaskInput `json:"input,omitempty"`

	// READ-ONLY; An array containing a single validation error response object
	Output []*ValidateOracleAzureDbPostgreSQLSyncTaskOutput `json:"output,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidateOracleAzureDbForPostgreSQLSyncTaskProperties.
func (v ValidateOracleAzureDbForPostgreSQLSyncTaskProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	v.ProjectTaskProperties.marshalInternal(objectMap, "Validate.Oracle.AzureDbPostgreSql.Sync")
	populate(objectMap, "input", v.Input)
	populate(objectMap, "output", v.Output)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ValidateOracleAzureDbForPostgreSQLSyncTaskProperties.
func (v *ValidateOracleAzureDbForPostgreSQLSyncTaskProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "input":
			err = unpopulate(val, &v.Input)
			delete(rawMsg, key)
		case "output":
			err = unpopulate(val, &v.Output)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := v.ProjectTaskProperties.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ValidateOracleAzureDbPostgreSQLSyncTaskOutput - Output for task that validates migration input for Oracle to Azure Database for PostgreSQL for online
// migrations
type ValidateOracleAzureDbPostgreSQLSyncTaskOutput struct {
	// READ-ONLY; Errors associated with a selected database object
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidateOracleAzureDbPostgreSQLSyncTaskOutput.
func (v ValidateOracleAzureDbPostgreSQLSyncTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "validationErrors", v.ValidationErrors)
	return json.Marshal(objectMap)
}

// ValidateSyncMigrationInputSQLServerTaskInput - Input for task that validates migration input for SQL sync migrations
type ValidateSyncMigrationInputSQLServerTaskInput struct {
	// REQUIRED; Databases to migrate
	SelectedDatabases []*MigrateSQLServerSQLDbSyncDatabaseInput `json:"selectedDatabases,omitempty"`

	// REQUIRED; Information for connecting to source SQL server
	SourceConnectionInfo *SQLConnectionInfo `json:"sourceConnectionInfo,omitempty"`

	// REQUIRED; Information for connecting to target
	TargetConnectionInfo *SQLConnectionInfo `json:"targetConnectionInfo,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidateSyncMigrationInputSQLServerTaskInput.
func (v ValidateSyncMigrationInputSQLServerTaskInput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "selectedDatabases", v.SelectedDatabases)
	populate(objectMap, "sourceConnectionInfo", v.SourceConnectionInfo)
	populate(objectMap, "targetConnectionInfo", v.TargetConnectionInfo)
	return json.Marshal(objectMap)
}

// ValidateSyncMigrationInputSQLServerTaskOutput - Output for task that validates migration input for SQL sync migrations
type ValidateSyncMigrationInputSQLServerTaskOutput struct {
	// READ-ONLY; Database identifier
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; Name of database
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; Errors associated with a selected database object
	ValidationErrors []*ReportableException `json:"validationErrors,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type ValidateSyncMigrationInputSQLServerTaskOutput.
func (v ValidateSyncMigrationInputSQLServerTaskOutput) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", v.ID)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "validationErrors", v.ValidationErrors)
	return json.Marshal(objectMap)
}

// ValidationError - Description about the errors happen while performing migration validation
type ValidationError struct {
	// Severity of the error
	Severity *Severity `json:"severity,omitempty"`

	// Error Text
	Text *string `json:"text,omitempty"`
}

// WaitStatistics - Wait statistics gathered during query batch execution
type WaitStatistics struct {
	// Total no. of waits
	WaitCount *int64 `json:"waitCount,omitempty"`

	// Total wait time in millisecond(s)
	WaitTimeMs *float32 `json:"waitTimeMs,omitempty"`

	// Type of the Wait
	WaitType *string `json:"waitType,omitempty"`
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
