//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdevtestlabs

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// ArmTemplatesClientListPager provides operations for iterating over paged responses.
type ArmTemplatesClientListPager struct {
	client    *ArmTemplatesClient
	current   ArmTemplatesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ArmTemplatesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ArmTemplatesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ArmTemplateList.NextLink == nil || len(*p.current.ArmTemplateList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ArmTemplatesClientListPager) NextPage(ctx context.Context) (ArmTemplatesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ArmTemplatesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ArmTemplatesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ArmTemplatesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ArmTemplatesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ArmTemplatesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ArtifactSourcesClientListPager provides operations for iterating over paged responses.
type ArtifactSourcesClientListPager struct {
	client    *ArtifactSourcesClient
	current   ArtifactSourcesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ArtifactSourcesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ArtifactSourcesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ArtifactSourceList.NextLink == nil || len(*p.current.ArtifactSourceList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ArtifactSourcesClientListPager) NextPage(ctx context.Context) (ArtifactSourcesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ArtifactSourcesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ArtifactSourcesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ArtifactSourcesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ArtifactSourcesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ArtifactSourcesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ArtifactsClientListPager provides operations for iterating over paged responses.
type ArtifactsClientListPager struct {
	client    *ArtifactsClient
	current   ArtifactsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ArtifactsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ArtifactsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ArtifactList.NextLink == nil || len(*p.current.ArtifactList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ArtifactsClientListPager) NextPage(ctx context.Context) (ArtifactsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ArtifactsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ArtifactsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ArtifactsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ArtifactsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ArtifactsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CustomImagesClientListPager provides operations for iterating over paged responses.
type CustomImagesClientListPager struct {
	client    *CustomImagesClient
	current   CustomImagesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomImagesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CustomImagesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomImageList.NextLink == nil || len(*p.current.CustomImageList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CustomImagesClientListPager) NextPage(ctx context.Context) (CustomImagesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CustomImagesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CustomImagesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CustomImagesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CustomImagesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return CustomImagesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DisksClientListPager provides operations for iterating over paged responses.
type DisksClientListPager struct {
	client    *DisksClient
	current   DisksClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DisksClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DisksClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskList.NextLink == nil || len(*p.current.DiskList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DisksClientListPager) NextPage(ctx context.Context) (DisksClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DisksClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DisksClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DisksClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DisksClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return DisksClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// EnvironmentsClientListPager provides operations for iterating over paged responses.
type EnvironmentsClientListPager struct {
	client    *EnvironmentsClient
	current   EnvironmentsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnvironmentsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *EnvironmentsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DtlEnvironmentList.NextLink == nil || len(*p.current.DtlEnvironmentList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *EnvironmentsClientListPager) NextPage(ctx context.Context) (EnvironmentsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return EnvironmentsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return EnvironmentsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return EnvironmentsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return EnvironmentsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return EnvironmentsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// FormulasClientListPager provides operations for iterating over paged responses.
type FormulasClientListPager struct {
	client    *FormulasClient
	current   FormulasClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, FormulasClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *FormulasClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.FormulaList.NextLink == nil || len(*p.current.FormulaList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *FormulasClientListPager) NextPage(ctx context.Context) (FormulasClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return FormulasClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return FormulasClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return FormulasClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return FormulasClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return FormulasClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GalleryImagesClientListPager provides operations for iterating over paged responses.
type GalleryImagesClientListPager struct {
	client    *GalleryImagesClient
	current   GalleryImagesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleryImagesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GalleryImagesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryImageList.NextLink == nil || len(*p.current.GalleryImageList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GalleryImagesClientListPager) NextPage(ctx context.Context) (GalleryImagesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GalleryImagesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GalleryImagesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GalleryImagesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GalleryImagesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return GalleryImagesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GlobalSchedulesClientListByResourceGroupPager provides operations for iterating over paged responses.
type GlobalSchedulesClientListByResourceGroupPager struct {
	client    *GlobalSchedulesClient
	current   GlobalSchedulesClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GlobalSchedulesClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GlobalSchedulesClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ScheduleList.NextLink == nil || len(*p.current.ScheduleList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GlobalSchedulesClientListByResourceGroupPager) NextPage(ctx context.Context) (GlobalSchedulesClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GlobalSchedulesClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GlobalSchedulesClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GlobalSchedulesClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GlobalSchedulesClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return GlobalSchedulesClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GlobalSchedulesClientListBySubscriptionPager provides operations for iterating over paged responses.
type GlobalSchedulesClientListBySubscriptionPager struct {
	client    *GlobalSchedulesClient
	current   GlobalSchedulesClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GlobalSchedulesClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GlobalSchedulesClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ScheduleList.NextLink == nil || len(*p.current.ScheduleList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GlobalSchedulesClientListBySubscriptionPager) NextPage(ctx context.Context) (GlobalSchedulesClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GlobalSchedulesClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GlobalSchedulesClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GlobalSchedulesClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GlobalSchedulesClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return GlobalSchedulesClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// LabsClientListByResourceGroupPager provides operations for iterating over paged responses.
type LabsClientListByResourceGroupPager struct {
	client    *LabsClient
	current   LabsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LabsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *LabsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LabList.NextLink == nil || len(*p.current.LabList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *LabsClientListByResourceGroupPager) NextPage(ctx context.Context) (LabsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return LabsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return LabsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return LabsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return LabsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return LabsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// LabsClientListBySubscriptionPager provides operations for iterating over paged responses.
type LabsClientListBySubscriptionPager struct {
	client    *LabsClient
	current   LabsClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LabsClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *LabsClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LabList.NextLink == nil || len(*p.current.LabList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *LabsClientListBySubscriptionPager) NextPage(ctx context.Context) (LabsClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return LabsClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return LabsClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return LabsClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return LabsClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return LabsClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// LabsClientListVhdsPager provides operations for iterating over paged responses.
type LabsClientListVhdsPager struct {
	client    *LabsClient
	current   LabsClientListVhdsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LabsClientListVhdsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *LabsClientListVhdsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LabVhdList.NextLink == nil || len(*p.current.LabVhdList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *LabsClientListVhdsPager) NextPage(ctx context.Context) (LabsClientListVhdsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return LabsClientListVhdsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return LabsClientListVhdsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return LabsClientListVhdsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return LabsClientListVhdsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listVhdsHandleResponse(resp)
	if err != nil {
		return LabsClientListVhdsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// NotificationChannelsClientListPager provides operations for iterating over paged responses.
type NotificationChannelsClientListPager struct {
	client    *NotificationChannelsClient
	current   NotificationChannelsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NotificationChannelsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *NotificationChannelsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NotificationChannelList.NextLink == nil || len(*p.current.NotificationChannelList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *NotificationChannelsClientListPager) NextPage(ctx context.Context) (NotificationChannelsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return NotificationChannelsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return NotificationChannelsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return NotificationChannelsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return NotificationChannelsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return NotificationChannelsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PoliciesClientListPager provides operations for iterating over paged responses.
type PoliciesClientListPager struct {
	client    *PoliciesClient
	current   PoliciesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PoliciesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PoliciesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PolicyList.NextLink == nil || len(*p.current.PolicyList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PoliciesClientListPager) NextPage(ctx context.Context) (PoliciesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PoliciesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PoliciesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PoliciesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PoliciesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return PoliciesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProviderOperationsClientListPager provides operations for iterating over paged responses.
type ProviderOperationsClientListPager struct {
	client    *ProviderOperationsClient
	current   ProviderOperationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProviderOperationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProviderOperationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProviderOperationResult.NextLink == nil || len(*p.current.ProviderOperationResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProviderOperationsClientListPager) NextPage(ctx context.Context) (ProviderOperationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProviderOperationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProviderOperationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProviderOperationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProviderOperationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ProviderOperationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SchedulesClientListApplicablePager provides operations for iterating over paged responses.
type SchedulesClientListApplicablePager struct {
	client    *SchedulesClient
	current   SchedulesClientListApplicableResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SchedulesClientListApplicableResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SchedulesClientListApplicablePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ScheduleList.NextLink == nil || len(*p.current.ScheduleList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SchedulesClientListApplicablePager) NextPage(ctx context.Context) (SchedulesClientListApplicableResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SchedulesClientListApplicableResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SchedulesClientListApplicableResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SchedulesClientListApplicableResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SchedulesClientListApplicableResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listApplicableHandleResponse(resp)
	if err != nil {
		return SchedulesClientListApplicableResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SchedulesClientListPager provides operations for iterating over paged responses.
type SchedulesClientListPager struct {
	client    *SchedulesClient
	current   SchedulesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SchedulesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SchedulesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ScheduleList.NextLink == nil || len(*p.current.ScheduleList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SchedulesClientListPager) NextPage(ctx context.Context) (SchedulesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SchedulesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SchedulesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SchedulesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SchedulesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return SchedulesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SecretsClientListPager provides operations for iterating over paged responses.
type SecretsClientListPager struct {
	client    *SecretsClient
	current   SecretsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecretsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SecretsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecretList.NextLink == nil || len(*p.current.SecretList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SecretsClientListPager) NextPage(ctx context.Context) (SecretsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SecretsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SecretsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SecretsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SecretsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return SecretsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ServiceFabricSchedulesClientListPager provides operations for iterating over paged responses.
type ServiceFabricSchedulesClientListPager struct {
	client    *ServiceFabricSchedulesClient
	current   ServiceFabricSchedulesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServiceFabricSchedulesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ServiceFabricSchedulesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ScheduleList.NextLink == nil || len(*p.current.ScheduleList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ServiceFabricSchedulesClientListPager) NextPage(ctx context.Context) (ServiceFabricSchedulesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ServiceFabricSchedulesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ServiceFabricSchedulesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ServiceFabricSchedulesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ServiceFabricSchedulesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ServiceFabricSchedulesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ServiceFabricsClientListPager provides operations for iterating over paged responses.
type ServiceFabricsClientListPager struct {
	client    *ServiceFabricsClient
	current   ServiceFabricsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServiceFabricsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ServiceFabricsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServiceFabricList.NextLink == nil || len(*p.current.ServiceFabricList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ServiceFabricsClientListPager) NextPage(ctx context.Context) (ServiceFabricsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ServiceFabricsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ServiceFabricsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ServiceFabricsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ServiceFabricsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ServiceFabricsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// UsersClientListPager provides operations for iterating over paged responses.
type UsersClientListPager struct {
	client    *UsersClient
	current   UsersClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UsersClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *UsersClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UserList.NextLink == nil || len(*p.current.UserList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *UsersClientListPager) NextPage(ctx context.Context) (UsersClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return UsersClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return UsersClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return UsersClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return UsersClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return UsersClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachineSchedulesClientListPager provides operations for iterating over paged responses.
type VirtualMachineSchedulesClientListPager struct {
	client    *VirtualMachineSchedulesClient
	current   VirtualMachineSchedulesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineSchedulesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachineSchedulesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ScheduleList.NextLink == nil || len(*p.current.ScheduleList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachineSchedulesClientListPager) NextPage(ctx context.Context) (VirtualMachineSchedulesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachineSchedulesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachineSchedulesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachineSchedulesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachineSchedulesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualMachineSchedulesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachinesClientListPager provides operations for iterating over paged responses.
type VirtualMachinesClientListPager struct {
	client    *VirtualMachinesClient
	current   VirtualMachinesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachinesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachinesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LabVirtualMachineList.NextLink == nil || len(*p.current.LabVirtualMachineList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachinesClientListPager) NextPage(ctx context.Context) (VirtualMachinesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachinesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachinesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachinesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachinesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualMachinesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualNetworksClientListPager provides operations for iterating over paged responses.
type VirtualNetworksClientListPager struct {
	client    *VirtualNetworksClient
	current   VirtualNetworksClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualNetworksClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualNetworksClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualNetworkList.NextLink == nil || len(*p.current.VirtualNetworkList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualNetworksClientListPager) NextPage(ctx context.Context) (VirtualNetworksClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualNetworksClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualNetworksClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualNetworksClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualNetworksClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualNetworksClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}
