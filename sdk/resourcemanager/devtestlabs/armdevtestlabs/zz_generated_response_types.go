//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdevtestlabs

import (
	"context"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"time"
)

// ArmTemplatesClientGetResponse contains the response from method ArmTemplatesClient.Get.
type ArmTemplatesClientGetResponse struct {
	ArmTemplate
}

// ArmTemplatesClientListResponse contains the response from method ArmTemplatesClient.List.
type ArmTemplatesClientListResponse struct {
	ArmTemplateList
}

// ArtifactSourcesClientCreateOrUpdateResponse contains the response from method ArtifactSourcesClient.CreateOrUpdate.
type ArtifactSourcesClientCreateOrUpdateResponse struct {
	ArtifactSource
}

// ArtifactSourcesClientDeleteResponse contains the response from method ArtifactSourcesClient.Delete.
type ArtifactSourcesClientDeleteResponse struct {
	// placeholder for future response values
}

// ArtifactSourcesClientGetResponse contains the response from method ArtifactSourcesClient.Get.
type ArtifactSourcesClientGetResponse struct {
	ArtifactSource
}

// ArtifactSourcesClientListResponse contains the response from method ArtifactSourcesClient.List.
type ArtifactSourcesClientListResponse struct {
	ArtifactSourceList
}

// ArtifactSourcesClientUpdateResponse contains the response from method ArtifactSourcesClient.Update.
type ArtifactSourcesClientUpdateResponse struct {
	ArtifactSource
}

// ArtifactsClientGenerateArmTemplateResponse contains the response from method ArtifactsClient.GenerateArmTemplate.
type ArtifactsClientGenerateArmTemplateResponse struct {
	ArmTemplateInfo
}

// ArtifactsClientGetResponse contains the response from method ArtifactsClient.Get.
type ArtifactsClientGetResponse struct {
	Artifact
}

// ArtifactsClientListResponse contains the response from method ArtifactsClient.List.
type ArtifactsClientListResponse struct {
	ArtifactList
}

// CostsClientCreateOrUpdateResponse contains the response from method CostsClient.CreateOrUpdate.
type CostsClientCreateOrUpdateResponse struct {
	LabCost
}

// CostsClientGetResponse contains the response from method CostsClient.Get.
type CostsClientGetResponse struct {
	LabCost
}

// CustomImagesClientCreateOrUpdatePollerResponse contains the response from method CustomImagesClient.CreateOrUpdate.
type CustomImagesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CustomImagesClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CustomImagesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CustomImagesClientCreateOrUpdateResponse, error) {
	respType := CustomImagesClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.CustomImage)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a CustomImagesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *CustomImagesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *CustomImagesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CustomImagesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &CustomImagesClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// CustomImagesClientCreateOrUpdateResponse contains the response from method CustomImagesClient.CreateOrUpdate.
type CustomImagesClientCreateOrUpdateResponse struct {
	CustomImage
}

// CustomImagesClientDeletePollerResponse contains the response from method CustomImagesClient.Delete.
type CustomImagesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *CustomImagesClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l CustomImagesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (CustomImagesClientDeleteResponse, error) {
	respType := CustomImagesClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a CustomImagesClientDeletePollerResponse from the provided client and resume token.
func (l *CustomImagesClientDeletePollerResponse) Resume(ctx context.Context, client *CustomImagesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("CustomImagesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &CustomImagesClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// CustomImagesClientDeleteResponse contains the response from method CustomImagesClient.Delete.
type CustomImagesClientDeleteResponse struct {
	// placeholder for future response values
}

// CustomImagesClientGetResponse contains the response from method CustomImagesClient.Get.
type CustomImagesClientGetResponse struct {
	CustomImage
}

// CustomImagesClientListResponse contains the response from method CustomImagesClient.List.
type CustomImagesClientListResponse struct {
	CustomImageList
}

// CustomImagesClientUpdateResponse contains the response from method CustomImagesClient.Update.
type CustomImagesClientUpdateResponse struct {
	CustomImage
}

// DisksClientAttachPollerResponse contains the response from method DisksClient.Attach.
type DisksClientAttachPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DisksClientAttachPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DisksClientAttachPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DisksClientAttachResponse, error) {
	respType := DisksClientAttachResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a DisksClientAttachPollerResponse from the provided client and resume token.
func (l *DisksClientAttachPollerResponse) Resume(ctx context.Context, client *DisksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DisksClient.Attach", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DisksClientAttachPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// DisksClientAttachResponse contains the response from method DisksClient.Attach.
type DisksClientAttachResponse struct {
	// placeholder for future response values
}

// DisksClientCreateOrUpdatePollerResponse contains the response from method DisksClient.CreateOrUpdate.
type DisksClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DisksClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DisksClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DisksClientCreateOrUpdateResponse, error) {
	respType := DisksClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Disk)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a DisksClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *DisksClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *DisksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DisksClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DisksClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// DisksClientCreateOrUpdateResponse contains the response from method DisksClient.CreateOrUpdate.
type DisksClientCreateOrUpdateResponse struct {
	Disk
}

// DisksClientDeletePollerResponse contains the response from method DisksClient.Delete.
type DisksClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DisksClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DisksClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DisksClientDeleteResponse, error) {
	respType := DisksClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a DisksClientDeletePollerResponse from the provided client and resume token.
func (l *DisksClientDeletePollerResponse) Resume(ctx context.Context, client *DisksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DisksClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DisksClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// DisksClientDeleteResponse contains the response from method DisksClient.Delete.
type DisksClientDeleteResponse struct {
	// placeholder for future response values
}

// DisksClientDetachPollerResponse contains the response from method DisksClient.Detach.
type DisksClientDetachPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *DisksClientDetachPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l DisksClientDetachPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (DisksClientDetachResponse, error) {
	respType := DisksClientDetachResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a DisksClientDetachPollerResponse from the provided client and resume token.
func (l *DisksClientDetachPollerResponse) Resume(ctx context.Context, client *DisksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("DisksClient.Detach", token, client.pl)
	if err != nil {
		return err
	}
	poller := &DisksClientDetachPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// DisksClientDetachResponse contains the response from method DisksClient.Detach.
type DisksClientDetachResponse struct {
	// placeholder for future response values
}

// DisksClientGetResponse contains the response from method DisksClient.Get.
type DisksClientGetResponse struct {
	Disk
}

// DisksClientListResponse contains the response from method DisksClient.List.
type DisksClientListResponse struct {
	DiskList
}

// DisksClientUpdateResponse contains the response from method DisksClient.Update.
type DisksClientUpdateResponse struct {
	Disk
}

// EnvironmentsClientCreateOrUpdatePollerResponse contains the response from method EnvironmentsClient.CreateOrUpdate.
type EnvironmentsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EnvironmentsClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EnvironmentsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EnvironmentsClientCreateOrUpdateResponse, error) {
	respType := EnvironmentsClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.DtlEnvironment)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a EnvironmentsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *EnvironmentsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *EnvironmentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EnvironmentsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &EnvironmentsClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// EnvironmentsClientCreateOrUpdateResponse contains the response from method EnvironmentsClient.CreateOrUpdate.
type EnvironmentsClientCreateOrUpdateResponse struct {
	DtlEnvironment
}

// EnvironmentsClientDeletePollerResponse contains the response from method EnvironmentsClient.Delete.
type EnvironmentsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *EnvironmentsClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l EnvironmentsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (EnvironmentsClientDeleteResponse, error) {
	respType := EnvironmentsClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a EnvironmentsClientDeletePollerResponse from the provided client and resume token.
func (l *EnvironmentsClientDeletePollerResponse) Resume(ctx context.Context, client *EnvironmentsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("EnvironmentsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &EnvironmentsClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// EnvironmentsClientDeleteResponse contains the response from method EnvironmentsClient.Delete.
type EnvironmentsClientDeleteResponse struct {
	// placeholder for future response values
}

// EnvironmentsClientGetResponse contains the response from method EnvironmentsClient.Get.
type EnvironmentsClientGetResponse struct {
	DtlEnvironment
}

// EnvironmentsClientListResponse contains the response from method EnvironmentsClient.List.
type EnvironmentsClientListResponse struct {
	DtlEnvironmentList
}

// EnvironmentsClientUpdateResponse contains the response from method EnvironmentsClient.Update.
type EnvironmentsClientUpdateResponse struct {
	DtlEnvironment
}

// FormulasClientCreateOrUpdatePollerResponse contains the response from method FormulasClient.CreateOrUpdate.
type FormulasClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *FormulasClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l FormulasClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (FormulasClientCreateOrUpdateResponse, error) {
	respType := FormulasClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Formula)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a FormulasClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *FormulasClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *FormulasClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("FormulasClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &FormulasClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// FormulasClientCreateOrUpdateResponse contains the response from method FormulasClient.CreateOrUpdate.
type FormulasClientCreateOrUpdateResponse struct {
	Formula
}

// FormulasClientDeleteResponse contains the response from method FormulasClient.Delete.
type FormulasClientDeleteResponse struct {
	// placeholder for future response values
}

// FormulasClientGetResponse contains the response from method FormulasClient.Get.
type FormulasClientGetResponse struct {
	Formula
}

// FormulasClientListResponse contains the response from method FormulasClient.List.
type FormulasClientListResponse struct {
	FormulaList
}

// FormulasClientUpdateResponse contains the response from method FormulasClient.Update.
type FormulasClientUpdateResponse struct {
	Formula
}

// GalleryImagesClientListResponse contains the response from method GalleryImagesClient.List.
type GalleryImagesClientListResponse struct {
	GalleryImageList
}

// GlobalSchedulesClientCreateOrUpdateResponse contains the response from method GlobalSchedulesClient.CreateOrUpdate.
type GlobalSchedulesClientCreateOrUpdateResponse struct {
	Schedule
}

// GlobalSchedulesClientDeleteResponse contains the response from method GlobalSchedulesClient.Delete.
type GlobalSchedulesClientDeleteResponse struct {
	// placeholder for future response values
}

// GlobalSchedulesClientExecutePollerResponse contains the response from method GlobalSchedulesClient.Execute.
type GlobalSchedulesClientExecutePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GlobalSchedulesClientExecutePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GlobalSchedulesClientExecutePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GlobalSchedulesClientExecuteResponse, error) {
	respType := GlobalSchedulesClientExecuteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a GlobalSchedulesClientExecutePollerResponse from the provided client and resume token.
func (l *GlobalSchedulesClientExecutePollerResponse) Resume(ctx context.Context, client *GlobalSchedulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GlobalSchedulesClient.Execute", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GlobalSchedulesClientExecutePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// GlobalSchedulesClientExecuteResponse contains the response from method GlobalSchedulesClient.Execute.
type GlobalSchedulesClientExecuteResponse struct {
	// placeholder for future response values
}

// GlobalSchedulesClientGetResponse contains the response from method GlobalSchedulesClient.Get.
type GlobalSchedulesClientGetResponse struct {
	Schedule
}

// GlobalSchedulesClientListByResourceGroupResponse contains the response from method GlobalSchedulesClient.ListByResourceGroup.
type GlobalSchedulesClientListByResourceGroupResponse struct {
	ScheduleList
}

// GlobalSchedulesClientListBySubscriptionResponse contains the response from method GlobalSchedulesClient.ListBySubscription.
type GlobalSchedulesClientListBySubscriptionResponse struct {
	ScheduleList
}

// GlobalSchedulesClientRetargetPollerResponse contains the response from method GlobalSchedulesClient.Retarget.
type GlobalSchedulesClientRetargetPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *GlobalSchedulesClientRetargetPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l GlobalSchedulesClientRetargetPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (GlobalSchedulesClientRetargetResponse, error) {
	respType := GlobalSchedulesClientRetargetResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a GlobalSchedulesClientRetargetPollerResponse from the provided client and resume token.
func (l *GlobalSchedulesClientRetargetPollerResponse) Resume(ctx context.Context, client *GlobalSchedulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("GlobalSchedulesClient.Retarget", token, client.pl)
	if err != nil {
		return err
	}
	poller := &GlobalSchedulesClientRetargetPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// GlobalSchedulesClientRetargetResponse contains the response from method GlobalSchedulesClient.Retarget.
type GlobalSchedulesClientRetargetResponse struct {
	// placeholder for future response values
}

// GlobalSchedulesClientUpdateResponse contains the response from method GlobalSchedulesClient.Update.
type GlobalSchedulesClientUpdateResponse struct {
	Schedule
}

// LabsClientClaimAnyVMPollerResponse contains the response from method LabsClient.ClaimAnyVM.
type LabsClientClaimAnyVMPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LabsClientClaimAnyVMPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LabsClientClaimAnyVMPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LabsClientClaimAnyVMResponse, error) {
	respType := LabsClientClaimAnyVMResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a LabsClientClaimAnyVMPollerResponse from the provided client and resume token.
func (l *LabsClientClaimAnyVMPollerResponse) Resume(ctx context.Context, client *LabsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LabsClient.ClaimAnyVM", token, client.pl)
	if err != nil {
		return err
	}
	poller := &LabsClientClaimAnyVMPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// LabsClientClaimAnyVMResponse contains the response from method LabsClient.ClaimAnyVM.
type LabsClientClaimAnyVMResponse struct {
	// placeholder for future response values
}

// LabsClientCreateEnvironmentPollerResponse contains the response from method LabsClient.CreateEnvironment.
type LabsClientCreateEnvironmentPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LabsClientCreateEnvironmentPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LabsClientCreateEnvironmentPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LabsClientCreateEnvironmentResponse, error) {
	respType := LabsClientCreateEnvironmentResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a LabsClientCreateEnvironmentPollerResponse from the provided client and resume token.
func (l *LabsClientCreateEnvironmentPollerResponse) Resume(ctx context.Context, client *LabsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LabsClient.CreateEnvironment", token, client.pl)
	if err != nil {
		return err
	}
	poller := &LabsClientCreateEnvironmentPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// LabsClientCreateEnvironmentResponse contains the response from method LabsClient.CreateEnvironment.
type LabsClientCreateEnvironmentResponse struct {
	// placeholder for future response values
}

// LabsClientCreateOrUpdatePollerResponse contains the response from method LabsClient.CreateOrUpdate.
type LabsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LabsClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LabsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LabsClientCreateOrUpdateResponse, error) {
	respType := LabsClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Lab)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a LabsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *LabsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *LabsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LabsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &LabsClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// LabsClientCreateOrUpdateResponse contains the response from method LabsClient.CreateOrUpdate.
type LabsClientCreateOrUpdateResponse struct {
	Lab
}

// LabsClientDeletePollerResponse contains the response from method LabsClient.Delete.
type LabsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LabsClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LabsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LabsClientDeleteResponse, error) {
	respType := LabsClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a LabsClientDeletePollerResponse from the provided client and resume token.
func (l *LabsClientDeletePollerResponse) Resume(ctx context.Context, client *LabsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LabsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &LabsClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// LabsClientDeleteResponse contains the response from method LabsClient.Delete.
type LabsClientDeleteResponse struct {
	// placeholder for future response values
}

// LabsClientExportResourceUsagePollerResponse contains the response from method LabsClient.ExportResourceUsage.
type LabsClientExportResourceUsagePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LabsClientExportResourceUsagePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LabsClientExportResourceUsagePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LabsClientExportResourceUsageResponse, error) {
	respType := LabsClientExportResourceUsageResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a LabsClientExportResourceUsagePollerResponse from the provided client and resume token.
func (l *LabsClientExportResourceUsagePollerResponse) Resume(ctx context.Context, client *LabsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LabsClient.ExportResourceUsage", token, client.pl)
	if err != nil {
		return err
	}
	poller := &LabsClientExportResourceUsagePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// LabsClientExportResourceUsageResponse contains the response from method LabsClient.ExportResourceUsage.
type LabsClientExportResourceUsageResponse struct {
	// placeholder for future response values
}

// LabsClientGenerateUploadURIResponse contains the response from method LabsClient.GenerateUploadURI.
type LabsClientGenerateUploadURIResponse struct {
	GenerateUploadURIResponse
}

// LabsClientGetResponse contains the response from method LabsClient.Get.
type LabsClientGetResponse struct {
	Lab
}

// LabsClientImportVirtualMachinePollerResponse contains the response from method LabsClient.ImportVirtualMachine.
type LabsClientImportVirtualMachinePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *LabsClientImportVirtualMachinePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l LabsClientImportVirtualMachinePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (LabsClientImportVirtualMachineResponse, error) {
	respType := LabsClientImportVirtualMachineResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a LabsClientImportVirtualMachinePollerResponse from the provided client and resume token.
func (l *LabsClientImportVirtualMachinePollerResponse) Resume(ctx context.Context, client *LabsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("LabsClient.ImportVirtualMachine", token, client.pl)
	if err != nil {
		return err
	}
	poller := &LabsClientImportVirtualMachinePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// LabsClientImportVirtualMachineResponse contains the response from method LabsClient.ImportVirtualMachine.
type LabsClientImportVirtualMachineResponse struct {
	// placeholder for future response values
}

// LabsClientListByResourceGroupResponse contains the response from method LabsClient.ListByResourceGroup.
type LabsClientListByResourceGroupResponse struct {
	LabList
}

// LabsClientListBySubscriptionResponse contains the response from method LabsClient.ListBySubscription.
type LabsClientListBySubscriptionResponse struct {
	LabList
}

// LabsClientListVhdsResponse contains the response from method LabsClient.ListVhds.
type LabsClientListVhdsResponse struct {
	LabVhdList
}

// LabsClientUpdateResponse contains the response from method LabsClient.Update.
type LabsClientUpdateResponse struct {
	Lab
}

// NotificationChannelsClientCreateOrUpdateResponse contains the response from method NotificationChannelsClient.CreateOrUpdate.
type NotificationChannelsClientCreateOrUpdateResponse struct {
	NotificationChannel
}

// NotificationChannelsClientDeleteResponse contains the response from method NotificationChannelsClient.Delete.
type NotificationChannelsClientDeleteResponse struct {
	// placeholder for future response values
}

// NotificationChannelsClientGetResponse contains the response from method NotificationChannelsClient.Get.
type NotificationChannelsClientGetResponse struct {
	NotificationChannel
}

// NotificationChannelsClientListResponse contains the response from method NotificationChannelsClient.List.
type NotificationChannelsClientListResponse struct {
	NotificationChannelList
}

// NotificationChannelsClientNotifyResponse contains the response from method NotificationChannelsClient.Notify.
type NotificationChannelsClientNotifyResponse struct {
	// placeholder for future response values
}

// NotificationChannelsClientUpdateResponse contains the response from method NotificationChannelsClient.Update.
type NotificationChannelsClientUpdateResponse struct {
	NotificationChannel
}

// OperationsClientGetResponse contains the response from method OperationsClient.Get.
type OperationsClientGetResponse struct {
	OperationResult
}

// PoliciesClientCreateOrUpdateResponse contains the response from method PoliciesClient.CreateOrUpdate.
type PoliciesClientCreateOrUpdateResponse struct {
	Policy
}

// PoliciesClientDeleteResponse contains the response from method PoliciesClient.Delete.
type PoliciesClientDeleteResponse struct {
	// placeholder for future response values
}

// PoliciesClientGetResponse contains the response from method PoliciesClient.Get.
type PoliciesClientGetResponse struct {
	Policy
}

// PoliciesClientListResponse contains the response from method PoliciesClient.List.
type PoliciesClientListResponse struct {
	PolicyList
}

// PoliciesClientUpdateResponse contains the response from method PoliciesClient.Update.
type PoliciesClientUpdateResponse struct {
	Policy
}

// PolicySetsClientEvaluatePoliciesResponse contains the response from method PolicySetsClient.EvaluatePolicies.
type PolicySetsClientEvaluatePoliciesResponse struct {
	EvaluatePoliciesResponse
}

// ProviderOperationsClientListResponse contains the response from method ProviderOperationsClient.List.
type ProviderOperationsClientListResponse struct {
	ProviderOperationResult
}

// SchedulesClientCreateOrUpdateResponse contains the response from method SchedulesClient.CreateOrUpdate.
type SchedulesClientCreateOrUpdateResponse struct {
	Schedule
}

// SchedulesClientDeleteResponse contains the response from method SchedulesClient.Delete.
type SchedulesClientDeleteResponse struct {
	// placeholder for future response values
}

// SchedulesClientExecutePollerResponse contains the response from method SchedulesClient.Execute.
type SchedulesClientExecutePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SchedulesClientExecutePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SchedulesClientExecutePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SchedulesClientExecuteResponse, error) {
	respType := SchedulesClientExecuteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a SchedulesClientExecutePollerResponse from the provided client and resume token.
func (l *SchedulesClientExecutePollerResponse) Resume(ctx context.Context, client *SchedulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SchedulesClient.Execute", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SchedulesClientExecutePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// SchedulesClientExecuteResponse contains the response from method SchedulesClient.Execute.
type SchedulesClientExecuteResponse struct {
	// placeholder for future response values
}

// SchedulesClientGetResponse contains the response from method SchedulesClient.Get.
type SchedulesClientGetResponse struct {
	Schedule
}

// SchedulesClientListApplicableResponse contains the response from method SchedulesClient.ListApplicable.
type SchedulesClientListApplicableResponse struct {
	ScheduleList
}

// SchedulesClientListResponse contains the response from method SchedulesClient.List.
type SchedulesClientListResponse struct {
	ScheduleList
}

// SchedulesClientUpdateResponse contains the response from method SchedulesClient.Update.
type SchedulesClientUpdateResponse struct {
	Schedule
}

// SecretsClientCreateOrUpdatePollerResponse contains the response from method SecretsClient.CreateOrUpdate.
type SecretsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *SecretsClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l SecretsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (SecretsClientCreateOrUpdateResponse, error) {
	respType := SecretsClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.Secret)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a SecretsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *SecretsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *SecretsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("SecretsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &SecretsClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// SecretsClientCreateOrUpdateResponse contains the response from method SecretsClient.CreateOrUpdate.
type SecretsClientCreateOrUpdateResponse struct {
	Secret
}

// SecretsClientDeleteResponse contains the response from method SecretsClient.Delete.
type SecretsClientDeleteResponse struct {
	// placeholder for future response values
}

// SecretsClientGetResponse contains the response from method SecretsClient.Get.
type SecretsClientGetResponse struct {
	Secret
}

// SecretsClientListResponse contains the response from method SecretsClient.List.
type SecretsClientListResponse struct {
	SecretList
}

// SecretsClientUpdateResponse contains the response from method SecretsClient.Update.
type SecretsClientUpdateResponse struct {
	Secret
}

// ServiceFabricSchedulesClientCreateOrUpdateResponse contains the response from method ServiceFabricSchedulesClient.CreateOrUpdate.
type ServiceFabricSchedulesClientCreateOrUpdateResponse struct {
	Schedule
}

// ServiceFabricSchedulesClientDeleteResponse contains the response from method ServiceFabricSchedulesClient.Delete.
type ServiceFabricSchedulesClientDeleteResponse struct {
	// placeholder for future response values
}

// ServiceFabricSchedulesClientExecutePollerResponse contains the response from method ServiceFabricSchedulesClient.Execute.
type ServiceFabricSchedulesClientExecutePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServiceFabricSchedulesClientExecutePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServiceFabricSchedulesClientExecutePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceFabricSchedulesClientExecuteResponse, error) {
	respType := ServiceFabricSchedulesClientExecuteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a ServiceFabricSchedulesClientExecutePollerResponse from the provided client and resume token.
func (l *ServiceFabricSchedulesClientExecutePollerResponse) Resume(ctx context.Context, client *ServiceFabricSchedulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServiceFabricSchedulesClient.Execute", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServiceFabricSchedulesClientExecutePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// ServiceFabricSchedulesClientExecuteResponse contains the response from method ServiceFabricSchedulesClient.Execute.
type ServiceFabricSchedulesClientExecuteResponse struct {
	// placeholder for future response values
}

// ServiceFabricSchedulesClientGetResponse contains the response from method ServiceFabricSchedulesClient.Get.
type ServiceFabricSchedulesClientGetResponse struct {
	Schedule
}

// ServiceFabricSchedulesClientListResponse contains the response from method ServiceFabricSchedulesClient.List.
type ServiceFabricSchedulesClientListResponse struct {
	ScheduleList
}

// ServiceFabricSchedulesClientUpdateResponse contains the response from method ServiceFabricSchedulesClient.Update.
type ServiceFabricSchedulesClientUpdateResponse struct {
	Schedule
}

// ServiceFabricsClientCreateOrUpdatePollerResponse contains the response from method ServiceFabricsClient.CreateOrUpdate.
type ServiceFabricsClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServiceFabricsClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServiceFabricsClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceFabricsClientCreateOrUpdateResponse, error) {
	respType := ServiceFabricsClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.ServiceFabric)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a ServiceFabricsClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *ServiceFabricsClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *ServiceFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServiceFabricsClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServiceFabricsClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// ServiceFabricsClientCreateOrUpdateResponse contains the response from method ServiceFabricsClient.CreateOrUpdate.
type ServiceFabricsClientCreateOrUpdateResponse struct {
	ServiceFabric
}

// ServiceFabricsClientDeletePollerResponse contains the response from method ServiceFabricsClient.Delete.
type ServiceFabricsClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServiceFabricsClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServiceFabricsClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceFabricsClientDeleteResponse, error) {
	respType := ServiceFabricsClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a ServiceFabricsClientDeletePollerResponse from the provided client and resume token.
func (l *ServiceFabricsClientDeletePollerResponse) Resume(ctx context.Context, client *ServiceFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServiceFabricsClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServiceFabricsClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// ServiceFabricsClientDeleteResponse contains the response from method ServiceFabricsClient.Delete.
type ServiceFabricsClientDeleteResponse struct {
	// placeholder for future response values
}

// ServiceFabricsClientGetResponse contains the response from method ServiceFabricsClient.Get.
type ServiceFabricsClientGetResponse struct {
	ServiceFabric
}

// ServiceFabricsClientListApplicableSchedulesResponse contains the response from method ServiceFabricsClient.ListApplicableSchedules.
type ServiceFabricsClientListApplicableSchedulesResponse struct {
	ApplicableSchedule
}

// ServiceFabricsClientListResponse contains the response from method ServiceFabricsClient.List.
type ServiceFabricsClientListResponse struct {
	ServiceFabricList
}

// ServiceFabricsClientStartPollerResponse contains the response from method ServiceFabricsClient.Start.
type ServiceFabricsClientStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServiceFabricsClientStartPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServiceFabricsClientStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceFabricsClientStartResponse, error) {
	respType := ServiceFabricsClientStartResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a ServiceFabricsClientStartPollerResponse from the provided client and resume token.
func (l *ServiceFabricsClientStartPollerResponse) Resume(ctx context.Context, client *ServiceFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServiceFabricsClient.Start", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServiceFabricsClientStartPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// ServiceFabricsClientStartResponse contains the response from method ServiceFabricsClient.Start.
type ServiceFabricsClientStartResponse struct {
	// placeholder for future response values
}

// ServiceFabricsClientStopPollerResponse contains the response from method ServiceFabricsClient.Stop.
type ServiceFabricsClientStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *ServiceFabricsClientStopPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l ServiceFabricsClientStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (ServiceFabricsClientStopResponse, error) {
	respType := ServiceFabricsClientStopResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a ServiceFabricsClientStopPollerResponse from the provided client and resume token.
func (l *ServiceFabricsClientStopPollerResponse) Resume(ctx context.Context, client *ServiceFabricsClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("ServiceFabricsClient.Stop", token, client.pl)
	if err != nil {
		return err
	}
	poller := &ServiceFabricsClientStopPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// ServiceFabricsClientStopResponse contains the response from method ServiceFabricsClient.Stop.
type ServiceFabricsClientStopResponse struct {
	// placeholder for future response values
}

// ServiceFabricsClientUpdateResponse contains the response from method ServiceFabricsClient.Update.
type ServiceFabricsClientUpdateResponse struct {
	ServiceFabric
}

// ServiceRunnersClientCreateOrUpdateResponse contains the response from method ServiceRunnersClient.CreateOrUpdate.
type ServiceRunnersClientCreateOrUpdateResponse struct {
	ServiceRunner
}

// ServiceRunnersClientDeleteResponse contains the response from method ServiceRunnersClient.Delete.
type ServiceRunnersClientDeleteResponse struct {
	// placeholder for future response values
}

// ServiceRunnersClientGetResponse contains the response from method ServiceRunnersClient.Get.
type ServiceRunnersClientGetResponse struct {
	ServiceRunner
}

// UsersClientCreateOrUpdatePollerResponse contains the response from method UsersClient.CreateOrUpdate.
type UsersClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *UsersClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l UsersClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (UsersClientCreateOrUpdateResponse, error) {
	respType := UsersClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.User)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a UsersClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *UsersClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *UsersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("UsersClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &UsersClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// UsersClientCreateOrUpdateResponse contains the response from method UsersClient.CreateOrUpdate.
type UsersClientCreateOrUpdateResponse struct {
	User
}

// UsersClientDeletePollerResponse contains the response from method UsersClient.Delete.
type UsersClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *UsersClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l UsersClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (UsersClientDeleteResponse, error) {
	respType := UsersClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a UsersClientDeletePollerResponse from the provided client and resume token.
func (l *UsersClientDeletePollerResponse) Resume(ctx context.Context, client *UsersClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("UsersClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &UsersClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// UsersClientDeleteResponse contains the response from method UsersClient.Delete.
type UsersClientDeleteResponse struct {
	// placeholder for future response values
}

// UsersClientGetResponse contains the response from method UsersClient.Get.
type UsersClientGetResponse struct {
	User
}

// UsersClientListResponse contains the response from method UsersClient.List.
type UsersClientListResponse struct {
	UserList
}

// UsersClientUpdateResponse contains the response from method UsersClient.Update.
type UsersClientUpdateResponse struct {
	User
}

// VirtualMachineSchedulesClientCreateOrUpdateResponse contains the response from method VirtualMachineSchedulesClient.CreateOrUpdate.
type VirtualMachineSchedulesClientCreateOrUpdateResponse struct {
	Schedule
}

// VirtualMachineSchedulesClientDeleteResponse contains the response from method VirtualMachineSchedulesClient.Delete.
type VirtualMachineSchedulesClientDeleteResponse struct {
	// placeholder for future response values
}

// VirtualMachineSchedulesClientExecutePollerResponse contains the response from method VirtualMachineSchedulesClient.Execute.
type VirtualMachineSchedulesClientExecutePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachineSchedulesClientExecutePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachineSchedulesClientExecutePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachineSchedulesClientExecuteResponse, error) {
	respType := VirtualMachineSchedulesClientExecuteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachineSchedulesClientExecutePollerResponse from the provided client and resume token.
func (l *VirtualMachineSchedulesClientExecutePollerResponse) Resume(ctx context.Context, client *VirtualMachineSchedulesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachineSchedulesClient.Execute", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachineSchedulesClientExecutePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachineSchedulesClientExecuteResponse contains the response from method VirtualMachineSchedulesClient.Execute.
type VirtualMachineSchedulesClientExecuteResponse struct {
	// placeholder for future response values
}

// VirtualMachineSchedulesClientGetResponse contains the response from method VirtualMachineSchedulesClient.Get.
type VirtualMachineSchedulesClientGetResponse struct {
	Schedule
}

// VirtualMachineSchedulesClientListResponse contains the response from method VirtualMachineSchedulesClient.List.
type VirtualMachineSchedulesClientListResponse struct {
	ScheduleList
}

// VirtualMachineSchedulesClientUpdateResponse contains the response from method VirtualMachineSchedulesClient.Update.
type VirtualMachineSchedulesClientUpdateResponse struct {
	Schedule
}

// VirtualMachinesClientAddDataDiskPollerResponse contains the response from method VirtualMachinesClient.AddDataDisk.
type VirtualMachinesClientAddDataDiskPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientAddDataDiskPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientAddDataDiskPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientAddDataDiskResponse, error) {
	respType := VirtualMachinesClientAddDataDiskResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientAddDataDiskPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientAddDataDiskPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.AddDataDisk", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientAddDataDiskPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientAddDataDiskResponse contains the response from method VirtualMachinesClient.AddDataDisk.
type VirtualMachinesClientAddDataDiskResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientApplyArtifactsPollerResponse contains the response from method VirtualMachinesClient.ApplyArtifacts.
type VirtualMachinesClientApplyArtifactsPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientApplyArtifactsPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientApplyArtifactsPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientApplyArtifactsResponse, error) {
	respType := VirtualMachinesClientApplyArtifactsResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientApplyArtifactsPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientApplyArtifactsPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.ApplyArtifacts", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientApplyArtifactsPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientApplyArtifactsResponse contains the response from method VirtualMachinesClient.ApplyArtifacts.
type VirtualMachinesClientApplyArtifactsResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientClaimPollerResponse contains the response from method VirtualMachinesClient.Claim.
type VirtualMachinesClientClaimPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientClaimPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientClaimPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientClaimResponse, error) {
	respType := VirtualMachinesClientClaimResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientClaimPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientClaimPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Claim", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientClaimPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientClaimResponse contains the response from method VirtualMachinesClient.Claim.
type VirtualMachinesClientClaimResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientCreateOrUpdatePollerResponse contains the response from method VirtualMachinesClient.CreateOrUpdate.
type VirtualMachinesClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientCreateOrUpdateResponse, error) {
	respType := VirtualMachinesClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.LabVirtualMachine)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientCreateOrUpdateResponse contains the response from method VirtualMachinesClient.CreateOrUpdate.
type VirtualMachinesClientCreateOrUpdateResponse struct {
	LabVirtualMachine
}

// VirtualMachinesClientDeletePollerResponse contains the response from method VirtualMachinesClient.Delete.
type VirtualMachinesClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientDeleteResponse, error) {
	respType := VirtualMachinesClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientDeleteResponse contains the response from method VirtualMachinesClient.Delete.
type VirtualMachinesClientDeleteResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientDetachDataDiskPollerResponse contains the response from method VirtualMachinesClient.DetachDataDisk.
type VirtualMachinesClientDetachDataDiskPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientDetachDataDiskPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientDetachDataDiskPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientDetachDataDiskResponse, error) {
	respType := VirtualMachinesClientDetachDataDiskResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientDetachDataDiskPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientDetachDataDiskPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.DetachDataDisk", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientDetachDataDiskPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientDetachDataDiskResponse contains the response from method VirtualMachinesClient.DetachDataDisk.
type VirtualMachinesClientDetachDataDiskResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientGetRdpFileContentsResponse contains the response from method VirtualMachinesClient.GetRdpFileContents.
type VirtualMachinesClientGetRdpFileContentsResponse struct {
	RdpConnection
}

// VirtualMachinesClientGetResponse contains the response from method VirtualMachinesClient.Get.
type VirtualMachinesClientGetResponse struct {
	LabVirtualMachine
}

// VirtualMachinesClientListApplicableSchedulesResponse contains the response from method VirtualMachinesClient.ListApplicableSchedules.
type VirtualMachinesClientListApplicableSchedulesResponse struct {
	ApplicableSchedule
}

// VirtualMachinesClientListResponse contains the response from method VirtualMachinesClient.List.
type VirtualMachinesClientListResponse struct {
	LabVirtualMachineList
}

// VirtualMachinesClientRedeployPollerResponse contains the response from method VirtualMachinesClient.Redeploy.
type VirtualMachinesClientRedeployPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientRedeployPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientRedeployPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientRedeployResponse, error) {
	respType := VirtualMachinesClientRedeployResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientRedeployPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientRedeployPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Redeploy", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientRedeployPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientRedeployResponse contains the response from method VirtualMachinesClient.Redeploy.
type VirtualMachinesClientRedeployResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientResizePollerResponse contains the response from method VirtualMachinesClient.Resize.
type VirtualMachinesClientResizePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientResizePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientResizePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientResizeResponse, error) {
	respType := VirtualMachinesClientResizeResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientResizePollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientResizePollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Resize", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientResizePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientResizeResponse contains the response from method VirtualMachinesClient.Resize.
type VirtualMachinesClientResizeResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientRestartPollerResponse contains the response from method VirtualMachinesClient.Restart.
type VirtualMachinesClientRestartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientRestartPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientRestartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientRestartResponse, error) {
	respType := VirtualMachinesClientRestartResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientRestartPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientRestartPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Restart", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientRestartPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientRestartResponse contains the response from method VirtualMachinesClient.Restart.
type VirtualMachinesClientRestartResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientStartPollerResponse contains the response from method VirtualMachinesClient.Start.
type VirtualMachinesClientStartPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientStartPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientStartPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientStartResponse, error) {
	respType := VirtualMachinesClientStartResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientStartPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientStartPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Start", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientStartPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientStartResponse contains the response from method VirtualMachinesClient.Start.
type VirtualMachinesClientStartResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientStopPollerResponse contains the response from method VirtualMachinesClient.Stop.
type VirtualMachinesClientStopPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientStopPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientStopPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientStopResponse, error) {
	respType := VirtualMachinesClientStopResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientStopPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientStopPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.Stop", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientStopPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientStopResponse contains the response from method VirtualMachinesClient.Stop.
type VirtualMachinesClientStopResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientTransferDisksPollerResponse contains the response from method VirtualMachinesClient.TransferDisks.
type VirtualMachinesClientTransferDisksPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientTransferDisksPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientTransferDisksPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientTransferDisksResponse, error) {
	respType := VirtualMachinesClientTransferDisksResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientTransferDisksPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientTransferDisksPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.TransferDisks", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientTransferDisksPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientTransferDisksResponse contains the response from method VirtualMachinesClient.TransferDisks.
type VirtualMachinesClientTransferDisksResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientUnClaimPollerResponse contains the response from method VirtualMachinesClient.UnClaim.
type VirtualMachinesClientUnClaimPollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualMachinesClientUnClaimPoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualMachinesClientUnClaimPollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualMachinesClientUnClaimResponse, error) {
	respType := VirtualMachinesClientUnClaimResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualMachinesClientUnClaimPollerResponse from the provided client and resume token.
func (l *VirtualMachinesClientUnClaimPollerResponse) Resume(ctx context.Context, client *VirtualMachinesClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualMachinesClient.UnClaim", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualMachinesClientUnClaimPoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualMachinesClientUnClaimResponse contains the response from method VirtualMachinesClient.UnClaim.
type VirtualMachinesClientUnClaimResponse struct {
	// placeholder for future response values
}

// VirtualMachinesClientUpdateResponse contains the response from method VirtualMachinesClient.Update.
type VirtualMachinesClientUpdateResponse struct {
	LabVirtualMachine
}

// VirtualNetworksClientCreateOrUpdatePollerResponse contains the response from method VirtualNetworksClient.CreateOrUpdate.
type VirtualNetworksClientCreateOrUpdatePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworksClientCreateOrUpdatePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworksClientCreateOrUpdatePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworksClientCreateOrUpdateResponse, error) {
	respType := VirtualNetworksClientCreateOrUpdateResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, &respType.VirtualNetwork)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualNetworksClientCreateOrUpdatePollerResponse from the provided client and resume token.
func (l *VirtualNetworksClientCreateOrUpdatePollerResponse) Resume(ctx context.Context, client *VirtualNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworksClient.CreateOrUpdate", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworksClientCreateOrUpdatePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualNetworksClientCreateOrUpdateResponse contains the response from method VirtualNetworksClient.CreateOrUpdate.
type VirtualNetworksClientCreateOrUpdateResponse struct {
	VirtualNetwork
}

// VirtualNetworksClientDeletePollerResponse contains the response from method VirtualNetworksClient.Delete.
type VirtualNetworksClientDeletePollerResponse struct {
	// Poller contains an initialized poller.
	Poller *VirtualNetworksClientDeletePoller
}

// PollUntilDone will poll the service endpoint until a terminal state is reached or an error is received.
// freq: the time to wait between intervals in absence of a Retry-After header. Allowed minimum is one second.
// A good starting value is 30 seconds. Note that some resources might benefit from a different value.
func (l VirtualNetworksClientDeletePollerResponse) PollUntilDone(ctx context.Context, freq time.Duration) (VirtualNetworksClientDeleteResponse, error) {
	respType := VirtualNetworksClientDeleteResponse{}
	_, err := l.Poller.pt.PollUntilDone(ctx, freq, nil)
	if err != nil {
		return respType, err
	}
	return respType, nil
}

// Resume rehydrates a VirtualNetworksClientDeletePollerResponse from the provided client and resume token.
func (l *VirtualNetworksClientDeletePollerResponse) Resume(ctx context.Context, client *VirtualNetworksClient, token string) error {
	pt, err := armruntime.NewPollerFromResumeToken("VirtualNetworksClient.Delete", token, client.pl)
	if err != nil {
		return err
	}
	poller := &VirtualNetworksClientDeletePoller{
		pt: pt,
	}
	_, err = poller.Poll(ctx)
	if err != nil {
		return err
	}
	l.Poller = poller
	return nil
}

// VirtualNetworksClientDeleteResponse contains the response from method VirtualNetworksClient.Delete.
type VirtualNetworksClientDeleteResponse struct {
	// placeholder for future response values
}

// VirtualNetworksClientGetResponse contains the response from method VirtualNetworksClient.Get.
type VirtualNetworksClientGetResponse struct {
	VirtualNetwork
}

// VirtualNetworksClientListResponse contains the response from method VirtualNetworksClient.List.
type VirtualNetworksClientListResponse struct {
	VirtualNetworkList
}

// VirtualNetworksClientUpdateResponse contains the response from method VirtualNetworksClient.Update.
type VirtualNetworksClientUpdateResponse struct {
	VirtualNetwork
}
