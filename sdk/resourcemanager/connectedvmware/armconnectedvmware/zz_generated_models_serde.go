//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
// Code generated by Microsoft (R) AutoRest Code Generator.Changes may cause incorrect behavior and will be lost if the code
// is regenerated.

package armconnectedvmware

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// MarshalJSON implements the json.Marshaller interface for type Cluster.
func (c Cluster) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "extendedLocation", c.ExtendedLocation)
	populate(objectMap, "id", c.ID)
	populate(objectMap, "kind", c.Kind)
	populate(objectMap, "location", c.Location)
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "systemData", c.SystemData)
	populate(objectMap, "tags", c.Tags)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// GetInventoryItemProperties implements the InventoryItemPropertiesClassification interface for type ClusterInventoryItem.
func (c *ClusterInventoryItem) GetInventoryItemProperties() *InventoryItemProperties {
	return &InventoryItemProperties{
		InventoryType:     c.InventoryType,
		ManagedResourceID: c.ManagedResourceID,
		MoRefID:           c.MoRefID,
		MoName:            c.MoName,
		ProvisioningState: c.ProvisioningState,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ClusterInventoryItem.
func (c ClusterInventoryItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["inventoryType"] = InventoryTypeCluster
	populate(objectMap, "managedResourceId", c.ManagedResourceID)
	populate(objectMap, "moName", c.MoName)
	populate(objectMap, "moRefId", c.MoRefID)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClusterInventoryItem.
func (c *ClusterInventoryItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inventoryType":
			err = unpopulate(val, &c.InventoryType)
			delete(rawMsg, key)
		case "managedResourceId":
			err = unpopulate(val, &c.ManagedResourceID)
			delete(rawMsg, key)
		case "moName":
			err = unpopulate(val, &c.MoName)
			delete(rawMsg, key)
		case "moRefId":
			err = unpopulate(val, &c.MoRefID)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &c.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClusterProperties.
func (c ClusterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customResourceName", c.CustomResourceName)
	populate(objectMap, "datastoreIds", c.DatastoreIDs)
	populate(objectMap, "inventoryItemId", c.InventoryItemID)
	populate(objectMap, "moName", c.MoName)
	populate(objectMap, "moRefId", c.MoRefID)
	populate(objectMap, "networkIds", c.NetworkIDs)
	populate(objectMap, "provisioningState", c.ProvisioningState)
	populate(objectMap, "statuses", c.Statuses)
	populate(objectMap, "uuid", c.UUID)
	populate(objectMap, "vCenterId", c.VCenterID)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ClustersList.
func (c ClustersList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Datastore.
func (d Datastore) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "extendedLocation", d.ExtendedLocation)
	populate(objectMap, "id", d.ID)
	populate(objectMap, "kind", d.Kind)
	populate(objectMap, "location", d.Location)
	populate(objectMap, "name", d.Name)
	populate(objectMap, "properties", d.Properties)
	populate(objectMap, "systemData", d.SystemData)
	populate(objectMap, "tags", d.Tags)
	populate(objectMap, "type", d.Type)
	return json.Marshal(objectMap)
}

// GetInventoryItemProperties implements the InventoryItemPropertiesClassification interface for type DatastoreInventoryItem.
func (d *DatastoreInventoryItem) GetInventoryItemProperties() *InventoryItemProperties {
	return &InventoryItemProperties{
		InventoryType:     d.InventoryType,
		ManagedResourceID: d.ManagedResourceID,
		MoRefID:           d.MoRefID,
		MoName:            d.MoName,
		ProvisioningState: d.ProvisioningState,
	}
}

// MarshalJSON implements the json.Marshaller interface for type DatastoreInventoryItem.
func (d DatastoreInventoryItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "capacityGB", d.CapacityGB)
	populate(objectMap, "freeSpaceGB", d.FreeSpaceGB)
	objectMap["inventoryType"] = InventoryTypeDatastore
	populate(objectMap, "managedResourceId", d.ManagedResourceID)
	populate(objectMap, "moName", d.MoName)
	populate(objectMap, "moRefId", d.MoRefID)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DatastoreInventoryItem.
func (d *DatastoreInventoryItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "capacityGB":
			err = unpopulate(val, &d.CapacityGB)
			delete(rawMsg, key)
		case "freeSpaceGB":
			err = unpopulate(val, &d.FreeSpaceGB)
			delete(rawMsg, key)
		case "inventoryType":
			err = unpopulate(val, &d.InventoryType)
			delete(rawMsg, key)
		case "managedResourceId":
			err = unpopulate(val, &d.ManagedResourceID)
			delete(rawMsg, key)
		case "moName":
			err = unpopulate(val, &d.MoName)
			delete(rawMsg, key)
		case "moRefId":
			err = unpopulate(val, &d.MoRefID)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &d.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type DatastoreProperties.
func (d DatastoreProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customResourceName", d.CustomResourceName)
	populate(objectMap, "inventoryItemId", d.InventoryItemID)
	populate(objectMap, "moName", d.MoName)
	populate(objectMap, "moRefId", d.MoRefID)
	populate(objectMap, "provisioningState", d.ProvisioningState)
	populate(objectMap, "statuses", d.Statuses)
	populate(objectMap, "uuid", d.UUID)
	populate(objectMap, "vCenterId", d.VCenterID)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type DatastoresList.
func (d DatastoresList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", d.NextLink)
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDefinition.
func (e ErrorDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ErrorDetail.
func (e ErrorDetail) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", e.Code)
	populate(objectMap, "details", e.Details)
	populate(objectMap, "message", e.Message)
	populate(objectMap, "target", e.Target)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type GuestAgentList.
func (g GuestAgentList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", g.NextLink)
	populate(objectMap, "value", g.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type GuestAgentProfile.
func (g GuestAgentProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agentVersion", g.AgentVersion)
	populate(objectMap, "errorDetails", g.ErrorDetails)
	populateTimeRFC3339(objectMap, "lastStatusChange", g.LastStatusChange)
	populate(objectMap, "status", g.Status)
	populate(objectMap, "vmUuid", g.VMUUID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type GuestAgentProfile.
func (g *GuestAgentProfile) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agentVersion":
			err = unpopulate(val, &g.AgentVersion)
			delete(rawMsg, key)
		case "errorDetails":
			err = unpopulate(val, &g.ErrorDetails)
			delete(rawMsg, key)
		case "lastStatusChange":
			err = unpopulateTimeRFC3339(val, &g.LastStatusChange)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &g.Status)
			delete(rawMsg, key)
		case "vmUuid":
			err = unpopulate(val, &g.VMUUID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type GuestAgentProperties.
func (g GuestAgentProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "credentials", g.Credentials)
	populate(objectMap, "customResourceName", g.CustomResourceName)
	populate(objectMap, "httpProxyConfig", g.HTTPProxyConfig)
	populate(objectMap, "provisioningAction", g.ProvisioningAction)
	populate(objectMap, "provisioningState", g.ProvisioningState)
	populate(objectMap, "status", g.Status)
	populate(objectMap, "statuses", g.Statuses)
	populate(objectMap, "uuid", g.UUID)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type Host.
func (h Host) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "extendedLocation", h.ExtendedLocation)
	populate(objectMap, "id", h.ID)
	populate(objectMap, "kind", h.Kind)
	populate(objectMap, "location", h.Location)
	populate(objectMap, "name", h.Name)
	populate(objectMap, "properties", h.Properties)
	populate(objectMap, "systemData", h.SystemData)
	populate(objectMap, "tags", h.Tags)
	populate(objectMap, "type", h.Type)
	return json.Marshal(objectMap)
}

// GetInventoryItemProperties implements the InventoryItemPropertiesClassification interface for type HostInventoryItem.
func (h *HostInventoryItem) GetInventoryItemProperties() *InventoryItemProperties {
	return &InventoryItemProperties{
		InventoryType:     h.InventoryType,
		ManagedResourceID: h.ManagedResourceID,
		MoRefID:           h.MoRefID,
		MoName:            h.MoName,
		ProvisioningState: h.ProvisioningState,
	}
}

// MarshalJSON implements the json.Marshaller interface for type HostInventoryItem.
func (h HostInventoryItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["inventoryType"] = InventoryTypeHost
	populate(objectMap, "managedResourceId", h.ManagedResourceID)
	populate(objectMap, "moName", h.MoName)
	populate(objectMap, "moRefId", h.MoRefID)
	populate(objectMap, "parent", h.Parent)
	populate(objectMap, "provisioningState", h.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HostInventoryItem.
func (h *HostInventoryItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inventoryType":
			err = unpopulate(val, &h.InventoryType)
			delete(rawMsg, key)
		case "managedResourceId":
			err = unpopulate(val, &h.ManagedResourceID)
			delete(rawMsg, key)
		case "moName":
			err = unpopulate(val, &h.MoName)
			delete(rawMsg, key)
		case "moRefId":
			err = unpopulate(val, &h.MoRefID)
			delete(rawMsg, key)
		case "parent":
			err = unpopulate(val, &h.Parent)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &h.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type HostProperties.
func (h HostProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customResourceName", h.CustomResourceName)
	populate(objectMap, "inventoryItemId", h.InventoryItemID)
	populate(objectMap, "moName", h.MoName)
	populate(objectMap, "moRefId", h.MoRefID)
	populate(objectMap, "provisioningState", h.ProvisioningState)
	populate(objectMap, "statuses", h.Statuses)
	populate(objectMap, "uuid", h.UUID)
	populate(objectMap, "vCenterId", h.VCenterID)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type HostsList.
func (h HostsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", h.NextLink)
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type HybridIdentityMetadataList.
func (h HybridIdentityMetadataList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", h.NextLink)
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type InventoryItem.
func (i InventoryItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", i.ID)
	populate(objectMap, "kind", i.Kind)
	populate(objectMap, "name", i.Name)
	populate(objectMap, "properties", i.Properties)
	populate(objectMap, "systemData", i.SystemData)
	populate(objectMap, "type", i.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type InventoryItem.
func (i *InventoryItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &i.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &i.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &i.Name)
			delete(rawMsg, key)
		case "properties":
			i.Properties, err = unmarshalInventoryItemPropertiesClassification(val)
			delete(rawMsg, key)
		case "systemData":
			err = unpopulate(val, &i.SystemData)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &i.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetInventoryItemProperties implements the InventoryItemPropertiesClassification interface for type InventoryItemProperties.
func (i *InventoryItemProperties) GetInventoryItemProperties() *InventoryItemProperties { return i }

// MarshalJSON implements the json.Marshaller interface for type InventoryItemsList.
func (i InventoryItemsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", i.NextLink)
	populate(objectMap, "value", i.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MachineExtension.
func (m MachineExtension) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	populate(objectMap, "location", m.Location)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "systemData", m.SystemData)
	populate(objectMap, "tags", m.Tags)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MachineExtensionInstanceViewStatus.
func (m MachineExtensionInstanceViewStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", m.Code)
	populate(objectMap, "displayStatus", m.DisplayStatus)
	populate(objectMap, "level", m.Level)
	populate(objectMap, "message", m.Message)
	populateTimeRFC3339(objectMap, "time", m.Time)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MachineExtensionInstanceViewStatus.
func (m *MachineExtensionInstanceViewStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "code":
			err = unpopulate(val, &m.Code)
			delete(rawMsg, key)
		case "displayStatus":
			err = unpopulate(val, &m.DisplayStatus)
			delete(rawMsg, key)
		case "level":
			err = unpopulate(val, &m.Level)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &m.Message)
			delete(rawMsg, key)
		case "time":
			err = unpopulateTimeRFC3339(val, &m.Time)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MachineExtensionUpdate.
func (m MachineExtensionUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "tags", m.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MachineExtensionsListResult.
func (m MachineExtensionsListResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type NetworkInterface.
func (n NetworkInterface) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "deviceKey", n.DeviceKey)
	populate(objectMap, "ipAddresses", n.IPAddresses)
	populate(objectMap, "ipSettings", n.IPSettings)
	populate(objectMap, "label", n.Label)
	populate(objectMap, "macAddress", n.MacAddress)
	populate(objectMap, "name", n.Name)
	populate(objectMap, "networkId", n.NetworkID)
	populate(objectMap, "networkMoName", n.NetworkMoName)
	populate(objectMap, "networkMoRefId", n.NetworkMoRefID)
	populate(objectMap, "nicType", n.NicType)
	populate(objectMap, "powerOnBoot", n.PowerOnBoot)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type NetworkProfile.
func (n NetworkProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "networkInterfaces", n.NetworkInterfaces)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type NetworkProfileUpdate.
func (n NetworkProfileUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "networkInterfaces", n.NetworkInterfaces)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type NicIPSettings.
func (n NicIPSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "allocationMethod", n.AllocationMethod)
	populate(objectMap, "dnsServers", n.DNSServers)
	populate(objectMap, "gateway", n.Gateway)
	populate(objectMap, "ipAddress", n.IPAddress)
	populate(objectMap, "ipAddressInfo", n.IPAddressInfo)
	populate(objectMap, "primaryWinsServer", n.PrimaryWinsServer)
	populate(objectMap, "secondaryWinsServer", n.SecondaryWinsServer)
	populate(objectMap, "subnetMask", n.SubnetMask)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type OperationsList.
func (o OperationsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", o.NextLink)
	populate(objectMap, "value", o.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ResourcePatch.
func (r ResourcePatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "tags", r.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ResourcePool.
func (r ResourcePool) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "extendedLocation", r.ExtendedLocation)
	populate(objectMap, "id", r.ID)
	populate(objectMap, "kind", r.Kind)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "properties", r.Properties)
	populate(objectMap, "systemData", r.SystemData)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// GetInventoryItemProperties implements the InventoryItemPropertiesClassification interface for type ResourcePoolInventoryItem.
func (r *ResourcePoolInventoryItem) GetInventoryItemProperties() *InventoryItemProperties {
	return &InventoryItemProperties{
		InventoryType:     r.InventoryType,
		ManagedResourceID: r.ManagedResourceID,
		MoRefID:           r.MoRefID,
		MoName:            r.MoName,
		ProvisioningState: r.ProvisioningState,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ResourcePoolInventoryItem.
func (r ResourcePoolInventoryItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["inventoryType"] = InventoryTypeResourcePool
	populate(objectMap, "managedResourceId", r.ManagedResourceID)
	populate(objectMap, "moName", r.MoName)
	populate(objectMap, "moRefId", r.MoRefID)
	populate(objectMap, "parent", r.Parent)
	populate(objectMap, "provisioningState", r.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourcePoolInventoryItem.
func (r *ResourcePoolInventoryItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inventoryType":
			err = unpopulate(val, &r.InventoryType)
			delete(rawMsg, key)
		case "managedResourceId":
			err = unpopulate(val, &r.ManagedResourceID)
			delete(rawMsg, key)
		case "moName":
			err = unpopulate(val, &r.MoName)
			delete(rawMsg, key)
		case "moRefId":
			err = unpopulate(val, &r.MoRefID)
			delete(rawMsg, key)
		case "parent":
			err = unpopulate(val, &r.Parent)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &r.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ResourcePoolProperties.
func (r ResourcePoolProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cpuLimitMHz", r.CPULimitMHz)
	populate(objectMap, "cpuReservationMHz", r.CPUReservationMHz)
	populate(objectMap, "cpuSharesLevel", r.CPUSharesLevel)
	populate(objectMap, "customResourceName", r.CustomResourceName)
	populate(objectMap, "inventoryItemId", r.InventoryItemID)
	populate(objectMap, "memLimitMB", r.MemLimitMB)
	populate(objectMap, "memReservationMB", r.MemReservationMB)
	populate(objectMap, "memSharesLevel", r.MemSharesLevel)
	populate(objectMap, "moName", r.MoName)
	populate(objectMap, "moRefId", r.MoRefID)
	populate(objectMap, "provisioningState", r.ProvisioningState)
	populate(objectMap, "statuses", r.Statuses)
	populate(objectMap, "uuid", r.UUID)
	populate(objectMap, "vCenterId", r.VCenterID)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ResourcePoolsList.
func (r ResourcePoolsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", r.NextLink)
	populate(objectMap, "value", r.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ResourceStatus.
func (r ResourceStatus) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "lastUpdatedAt", r.LastUpdatedAt)
	populate(objectMap, "message", r.Message)
	populate(objectMap, "reason", r.Reason)
	populate(objectMap, "severity", r.Severity)
	populate(objectMap, "status", r.Status)
	populate(objectMap, "type", r.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ResourceStatus.
func (r *ResourceStatus) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "lastUpdatedAt":
			err = unpopulateTimeRFC3339(val, &r.LastUpdatedAt)
			delete(rawMsg, key)
		case "message":
			err = unpopulate(val, &r.Message)
			delete(rawMsg, key)
		case "reason":
			err = unpopulate(val, &r.Reason)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &r.Severity)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &r.Status)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &r.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type StorageProfile.
func (s StorageProfile) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disks", s.Disks)
	populate(objectMap, "scsiControllers", s.ScsiControllers)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type StorageProfileUpdate.
func (s StorageProfileUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "disks", s.Disks)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type SystemData.
func (s SystemData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "createdAt", s.CreatedAt)
	populate(objectMap, "createdBy", s.CreatedBy)
	populate(objectMap, "createdByType", s.CreatedByType)
	populateTimeRFC3339(objectMap, "lastModifiedAt", s.LastModifiedAt)
	populate(objectMap, "lastModifiedBy", s.LastModifiedBy)
	populate(objectMap, "lastModifiedByType", s.LastModifiedByType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SystemData.
func (s *SystemData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "createdAt":
			err = unpopulateTimeRFC3339(val, &s.CreatedAt)
			delete(rawMsg, key)
		case "createdBy":
			err = unpopulate(val, &s.CreatedBy)
			delete(rawMsg, key)
		case "createdByType":
			err = unpopulate(val, &s.CreatedByType)
			delete(rawMsg, key)
		case "lastModifiedAt":
			err = unpopulateTimeRFC3339(val, &s.LastModifiedAt)
			delete(rawMsg, key)
		case "lastModifiedBy":
			err = unpopulate(val, &s.LastModifiedBy)
			delete(rawMsg, key)
		case "lastModifiedByType":
			err = unpopulate(val, &s.LastModifiedByType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VCenter.
func (v VCenter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "extendedLocation", v.ExtendedLocation)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "kind", v.Kind)
	populate(objectMap, "location", v.Location)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "systemData", v.SystemData)
	populate(objectMap, "tags", v.Tags)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type VCenterProperties.
func (v VCenterProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "connectionStatus", v.ConnectionStatus)
	populate(objectMap, "credentials", v.Credentials)
	populate(objectMap, "customResourceName", v.CustomResourceName)
	populate(objectMap, "fqdn", v.Fqdn)
	populate(objectMap, "instanceUuid", v.InstanceUUID)
	populate(objectMap, "port", v.Port)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populate(objectMap, "statuses", v.Statuses)
	populate(objectMap, "uuid", v.UUID)
	populate(objectMap, "version", v.Version)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type VCentersList.
func (v VCentersList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachine.
func (v VirtualMachine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "extendedLocation", v.ExtendedLocation)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "identity", v.Identity)
	populate(objectMap, "kind", v.Kind)
	populate(objectMap, "location", v.Location)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "systemData", v.SystemData)
	populate(objectMap, "tags", v.Tags)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// GetInventoryItemProperties implements the InventoryItemPropertiesClassification interface for type VirtualMachineInventoryItem.
func (v *VirtualMachineInventoryItem) GetInventoryItemProperties() *InventoryItemProperties {
	return &InventoryItemProperties{
		InventoryType:     v.InventoryType,
		ManagedResourceID: v.ManagedResourceID,
		MoRefID:           v.MoRefID,
		MoName:            v.MoName,
		ProvisioningState: v.ProvisioningState,
	}
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineInventoryItem.
func (v VirtualMachineInventoryItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "folderPath", v.FolderPath)
	populate(objectMap, "host", v.Host)
	populate(objectMap, "ipAddresses", v.IPAddresses)
	populate(objectMap, "instanceUuid", v.InstanceUUID)
	objectMap["inventoryType"] = InventoryTypeVirtualMachine
	populate(objectMap, "managedResourceId", v.ManagedResourceID)
	populate(objectMap, "moName", v.MoName)
	populate(objectMap, "moRefId", v.MoRefID)
	populate(objectMap, "osName", v.OSName)
	populate(objectMap, "osType", v.OSType)
	populate(objectMap, "powerState", v.PowerState)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populate(objectMap, "resourcePool", v.ResourcePool)
	populate(objectMap, "smbiosUuid", v.SmbiosUUID)
	populate(objectMap, "toolsRunningStatus", v.ToolsRunningStatus)
	populate(objectMap, "toolsVersion", v.ToolsVersion)
	populate(objectMap, "toolsVersionStatus", v.ToolsVersionStatus)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualMachineInventoryItem.
func (v *VirtualMachineInventoryItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "folderPath":
			err = unpopulate(val, &v.FolderPath)
			delete(rawMsg, key)
		case "host":
			err = unpopulate(val, &v.Host)
			delete(rawMsg, key)
		case "ipAddresses":
			err = unpopulate(val, &v.IPAddresses)
			delete(rawMsg, key)
		case "instanceUuid":
			err = unpopulate(val, &v.InstanceUUID)
			delete(rawMsg, key)
		case "inventoryType":
			err = unpopulate(val, &v.InventoryType)
			delete(rawMsg, key)
		case "managedResourceId":
			err = unpopulate(val, &v.ManagedResourceID)
			delete(rawMsg, key)
		case "moName":
			err = unpopulate(val, &v.MoName)
			delete(rawMsg, key)
		case "moRefId":
			err = unpopulate(val, &v.MoRefID)
			delete(rawMsg, key)
		case "osName":
			err = unpopulate(val, &v.OSName)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, &v.OSType)
			delete(rawMsg, key)
		case "powerState":
			err = unpopulate(val, &v.PowerState)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &v.ProvisioningState)
			delete(rawMsg, key)
		case "resourcePool":
			err = unpopulate(val, &v.ResourcePool)
			delete(rawMsg, key)
		case "smbiosUuid":
			err = unpopulate(val, &v.SmbiosUUID)
			delete(rawMsg, key)
		case "toolsRunningStatus":
			err = unpopulate(val, &v.ToolsRunningStatus)
			delete(rawMsg, key)
		case "toolsVersion":
			err = unpopulate(val, &v.ToolsVersion)
			delete(rawMsg, key)
		case "toolsVersionStatus":
			err = unpopulate(val, &v.ToolsVersionStatus)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineProperties.
func (v VirtualMachineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customResourceName", v.CustomResourceName)
	populate(objectMap, "firmwareType", v.FirmwareType)
	populate(objectMap, "folderPath", v.FolderPath)
	populate(objectMap, "guestAgentProfile", v.GuestAgentProfile)
	populate(objectMap, "hardwareProfile", v.HardwareProfile)
	populate(objectMap, "instanceUuid", v.InstanceUUID)
	populate(objectMap, "inventoryItemId", v.InventoryItemID)
	populate(objectMap, "moName", v.MoName)
	populate(objectMap, "moRefId", v.MoRefID)
	populate(objectMap, "networkProfile", v.NetworkProfile)
	populate(objectMap, "osProfile", v.OSProfile)
	populate(objectMap, "placementProfile", v.PlacementProfile)
	populate(objectMap, "powerState", v.PowerState)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populate(objectMap, "resourcePoolId", v.ResourcePoolID)
	populate(objectMap, "smbiosUuid", v.SmbiosUUID)
	populate(objectMap, "statuses", v.Statuses)
	populate(objectMap, "storageProfile", v.StorageProfile)
	populate(objectMap, "templateId", v.TemplateID)
	populate(objectMap, "uuid", v.UUID)
	populate(objectMap, "vCenterId", v.VCenterID)
	populate(objectMap, "vmId", v.VMID)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineTemplate.
func (v VirtualMachineTemplate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "extendedLocation", v.ExtendedLocation)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "kind", v.Kind)
	populate(objectMap, "location", v.Location)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "systemData", v.SystemData)
	populate(objectMap, "tags", v.Tags)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// GetInventoryItemProperties implements the InventoryItemPropertiesClassification interface for type VirtualMachineTemplateInventoryItem.
func (v *VirtualMachineTemplateInventoryItem) GetInventoryItemProperties() *InventoryItemProperties {
	return &InventoryItemProperties{
		InventoryType:     v.InventoryType,
		ManagedResourceID: v.ManagedResourceID,
		MoRefID:           v.MoRefID,
		MoName:            v.MoName,
		ProvisioningState: v.ProvisioningState,
	}
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineTemplateInventoryItem.
func (v VirtualMachineTemplateInventoryItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "folderPath", v.FolderPath)
	objectMap["inventoryType"] = InventoryTypeVirtualMachineTemplate
	populate(objectMap, "managedResourceId", v.ManagedResourceID)
	populate(objectMap, "memorySizeMB", v.MemorySizeMB)
	populate(objectMap, "moName", v.MoName)
	populate(objectMap, "moRefId", v.MoRefID)
	populate(objectMap, "numCPUs", v.NumCPUs)
	populate(objectMap, "numCoresPerSocket", v.NumCoresPerSocket)
	populate(objectMap, "osName", v.OSName)
	populate(objectMap, "osType", v.OSType)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualMachineTemplateInventoryItem.
func (v *VirtualMachineTemplateInventoryItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "folderPath":
			err = unpopulate(val, &v.FolderPath)
			delete(rawMsg, key)
		case "inventoryType":
			err = unpopulate(val, &v.InventoryType)
			delete(rawMsg, key)
		case "managedResourceId":
			err = unpopulate(val, &v.ManagedResourceID)
			delete(rawMsg, key)
		case "memorySizeMB":
			err = unpopulate(val, &v.MemorySizeMB)
			delete(rawMsg, key)
		case "moName":
			err = unpopulate(val, &v.MoName)
			delete(rawMsg, key)
		case "moRefId":
			err = unpopulate(val, &v.MoRefID)
			delete(rawMsg, key)
		case "numCPUs":
			err = unpopulate(val, &v.NumCPUs)
			delete(rawMsg, key)
		case "numCoresPerSocket":
			err = unpopulate(val, &v.NumCoresPerSocket)
			delete(rawMsg, key)
		case "osName":
			err = unpopulate(val, &v.OSName)
			delete(rawMsg, key)
		case "osType":
			err = unpopulate(val, &v.OSType)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &v.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineTemplateProperties.
func (v VirtualMachineTemplateProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customResourceName", v.CustomResourceName)
	populate(objectMap, "disks", v.Disks)
	populate(objectMap, "firmwareType", v.FirmwareType)
	populate(objectMap, "folderPath", v.FolderPath)
	populate(objectMap, "inventoryItemId", v.InventoryItemID)
	populate(objectMap, "memorySizeMB", v.MemorySizeMB)
	populate(objectMap, "moName", v.MoName)
	populate(objectMap, "moRefId", v.MoRefID)
	populate(objectMap, "networkInterfaces", v.NetworkInterfaces)
	populate(objectMap, "numCPUs", v.NumCPUs)
	populate(objectMap, "numCoresPerSocket", v.NumCoresPerSocket)
	populate(objectMap, "osName", v.OSName)
	populate(objectMap, "osType", v.OSType)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populate(objectMap, "statuses", v.Statuses)
	populate(objectMap, "toolsVersion", v.ToolsVersion)
	populate(objectMap, "toolsVersionStatus", v.ToolsVersionStatus)
	populate(objectMap, "uuid", v.UUID)
	populate(objectMap, "vCenterId", v.VCenterID)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineTemplatesList.
func (v VirtualMachineTemplatesList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachineUpdate.
func (v VirtualMachineUpdate) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "identity", v.Identity)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "tags", v.Tags)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type VirtualMachinesList.
func (v VirtualMachinesList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type VirtualNetwork.
func (v VirtualNetwork) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "extendedLocation", v.ExtendedLocation)
	populate(objectMap, "id", v.ID)
	populate(objectMap, "kind", v.Kind)
	populate(objectMap, "location", v.Location)
	populate(objectMap, "name", v.Name)
	populate(objectMap, "properties", v.Properties)
	populate(objectMap, "systemData", v.SystemData)
	populate(objectMap, "tags", v.Tags)
	populate(objectMap, "type", v.Type)
	return json.Marshal(objectMap)
}

// GetInventoryItemProperties implements the InventoryItemPropertiesClassification interface for type VirtualNetworkInventoryItem.
func (v *VirtualNetworkInventoryItem) GetInventoryItemProperties() *InventoryItemProperties {
	return &InventoryItemProperties{
		InventoryType:     v.InventoryType,
		ManagedResourceID: v.ManagedResourceID,
		MoRefID:           v.MoRefID,
		MoName:            v.MoName,
		ProvisioningState: v.ProvisioningState,
	}
}

// MarshalJSON implements the json.Marshaller interface for type VirtualNetworkInventoryItem.
func (v VirtualNetworkInventoryItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	objectMap["inventoryType"] = InventoryTypeVirtualNetwork
	populate(objectMap, "managedResourceId", v.ManagedResourceID)
	populate(objectMap, "moName", v.MoName)
	populate(objectMap, "moRefId", v.MoRefID)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VirtualNetworkInventoryItem.
func (v *VirtualNetworkInventoryItem) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "inventoryType":
			err = unpopulate(val, &v.InventoryType)
			delete(rawMsg, key)
		case "managedResourceId":
			err = unpopulate(val, &v.ManagedResourceID)
			delete(rawMsg, key)
		case "moName":
			err = unpopulate(val, &v.MoName)
			delete(rawMsg, key)
		case "moRefId":
			err = unpopulate(val, &v.MoRefID)
			delete(rawMsg, key)
		case "provisioningState":
			err = unpopulate(val, &v.ProvisioningState)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type VirtualNetworkProperties.
func (v VirtualNetworkProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "customResourceName", v.CustomResourceName)
	populate(objectMap, "inventoryItemId", v.InventoryItemID)
	populate(objectMap, "moName", v.MoName)
	populate(objectMap, "moRefId", v.MoRefID)
	populate(objectMap, "provisioningState", v.ProvisioningState)
	populate(objectMap, "statuses", v.Statuses)
	populate(objectMap, "uuid", v.UUID)
	populate(objectMap, "vCenterId", v.VCenterID)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type VirtualNetworksList.
func (v VirtualNetworksList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", v.NextLink)
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
