//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armresources

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// ClientListByResourceGroupPager provides operations for iterating over paged responses.
type ClientListByResourceGroupPager struct {
	client    *Client
	current   ClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceListResult.NextLink == nil || len(*p.current.ResourceListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ClientListByResourceGroupPager) NextPage(ctx context.Context) (ClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return ClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ClientListPager provides operations for iterating over paged responses.
type ClientListPager struct {
	client    *Client
	current   ClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceListResult.NextLink == nil || len(*p.current.ResourceListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ClientListPager) NextPage(ctx context.Context) (ClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DeploymentOperationsClientListAtManagementGroupScopePager provides operations for iterating over paged responses.
type DeploymentOperationsClientListAtManagementGroupScopePager struct {
	client    *DeploymentOperationsClient
	current   DeploymentOperationsClientListAtManagementGroupScopeResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeploymentOperationsClientListAtManagementGroupScopeResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DeploymentOperationsClientListAtManagementGroupScopePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeploymentOperationsListResult.NextLink == nil || len(*p.current.DeploymentOperationsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DeploymentOperationsClientListAtManagementGroupScopePager) NextPage(ctx context.Context) (DeploymentOperationsClientListAtManagementGroupScopeResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DeploymentOperationsClientListAtManagementGroupScopeResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DeploymentOperationsClientListAtManagementGroupScopeResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DeploymentOperationsClientListAtManagementGroupScopeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DeploymentOperationsClientListAtManagementGroupScopeResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAtManagementGroupScopeHandleResponse(resp)
	if err != nil {
		return DeploymentOperationsClientListAtManagementGroupScopeResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DeploymentOperationsClientListAtScopePager provides operations for iterating over paged responses.
type DeploymentOperationsClientListAtScopePager struct {
	client    *DeploymentOperationsClient
	current   DeploymentOperationsClientListAtScopeResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeploymentOperationsClientListAtScopeResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DeploymentOperationsClientListAtScopePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeploymentOperationsListResult.NextLink == nil || len(*p.current.DeploymentOperationsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DeploymentOperationsClientListAtScopePager) NextPage(ctx context.Context) (DeploymentOperationsClientListAtScopeResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DeploymentOperationsClientListAtScopeResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DeploymentOperationsClientListAtScopeResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DeploymentOperationsClientListAtScopeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DeploymentOperationsClientListAtScopeResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAtScopeHandleResponse(resp)
	if err != nil {
		return DeploymentOperationsClientListAtScopeResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DeploymentOperationsClientListAtSubscriptionScopePager provides operations for iterating over paged responses.
type DeploymentOperationsClientListAtSubscriptionScopePager struct {
	client    *DeploymentOperationsClient
	current   DeploymentOperationsClientListAtSubscriptionScopeResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeploymentOperationsClientListAtSubscriptionScopeResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DeploymentOperationsClientListAtSubscriptionScopePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeploymentOperationsListResult.NextLink == nil || len(*p.current.DeploymentOperationsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DeploymentOperationsClientListAtSubscriptionScopePager) NextPage(ctx context.Context) (DeploymentOperationsClientListAtSubscriptionScopeResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DeploymentOperationsClientListAtSubscriptionScopeResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DeploymentOperationsClientListAtSubscriptionScopeResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DeploymentOperationsClientListAtSubscriptionScopeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DeploymentOperationsClientListAtSubscriptionScopeResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAtSubscriptionScopeHandleResponse(resp)
	if err != nil {
		return DeploymentOperationsClientListAtSubscriptionScopeResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DeploymentOperationsClientListAtTenantScopePager provides operations for iterating over paged responses.
type DeploymentOperationsClientListAtTenantScopePager struct {
	client    *DeploymentOperationsClient
	current   DeploymentOperationsClientListAtTenantScopeResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeploymentOperationsClientListAtTenantScopeResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DeploymentOperationsClientListAtTenantScopePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeploymentOperationsListResult.NextLink == nil || len(*p.current.DeploymentOperationsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DeploymentOperationsClientListAtTenantScopePager) NextPage(ctx context.Context) (DeploymentOperationsClientListAtTenantScopeResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DeploymentOperationsClientListAtTenantScopeResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DeploymentOperationsClientListAtTenantScopeResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DeploymentOperationsClientListAtTenantScopeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DeploymentOperationsClientListAtTenantScopeResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAtTenantScopeHandleResponse(resp)
	if err != nil {
		return DeploymentOperationsClientListAtTenantScopeResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DeploymentOperationsClientListPager provides operations for iterating over paged responses.
type DeploymentOperationsClientListPager struct {
	client    *DeploymentOperationsClient
	current   DeploymentOperationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeploymentOperationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DeploymentOperationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeploymentOperationsListResult.NextLink == nil || len(*p.current.DeploymentOperationsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DeploymentOperationsClientListPager) NextPage(ctx context.Context) (DeploymentOperationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DeploymentOperationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DeploymentOperationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DeploymentOperationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DeploymentOperationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return DeploymentOperationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DeploymentsClientListAtManagementGroupScopePager provides operations for iterating over paged responses.
type DeploymentsClientListAtManagementGroupScopePager struct {
	client    *DeploymentsClient
	current   DeploymentsClientListAtManagementGroupScopeResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeploymentsClientListAtManagementGroupScopeResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DeploymentsClientListAtManagementGroupScopePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeploymentListResult.NextLink == nil || len(*p.current.DeploymentListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DeploymentsClientListAtManagementGroupScopePager) NextPage(ctx context.Context) (DeploymentsClientListAtManagementGroupScopeResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DeploymentsClientListAtManagementGroupScopeResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DeploymentsClientListAtManagementGroupScopeResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DeploymentsClientListAtManagementGroupScopeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DeploymentsClientListAtManagementGroupScopeResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAtManagementGroupScopeHandleResponse(resp)
	if err != nil {
		return DeploymentsClientListAtManagementGroupScopeResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DeploymentsClientListAtScopePager provides operations for iterating over paged responses.
type DeploymentsClientListAtScopePager struct {
	client    *DeploymentsClient
	current   DeploymentsClientListAtScopeResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeploymentsClientListAtScopeResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DeploymentsClientListAtScopePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeploymentListResult.NextLink == nil || len(*p.current.DeploymentListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DeploymentsClientListAtScopePager) NextPage(ctx context.Context) (DeploymentsClientListAtScopeResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DeploymentsClientListAtScopeResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DeploymentsClientListAtScopeResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DeploymentsClientListAtScopeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DeploymentsClientListAtScopeResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAtScopeHandleResponse(resp)
	if err != nil {
		return DeploymentsClientListAtScopeResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DeploymentsClientListAtSubscriptionScopePager provides operations for iterating over paged responses.
type DeploymentsClientListAtSubscriptionScopePager struct {
	client    *DeploymentsClient
	current   DeploymentsClientListAtSubscriptionScopeResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeploymentsClientListAtSubscriptionScopeResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DeploymentsClientListAtSubscriptionScopePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeploymentListResult.NextLink == nil || len(*p.current.DeploymentListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DeploymentsClientListAtSubscriptionScopePager) NextPage(ctx context.Context) (DeploymentsClientListAtSubscriptionScopeResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DeploymentsClientListAtSubscriptionScopeResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DeploymentsClientListAtSubscriptionScopeResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DeploymentsClientListAtSubscriptionScopeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DeploymentsClientListAtSubscriptionScopeResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAtSubscriptionScopeHandleResponse(resp)
	if err != nil {
		return DeploymentsClientListAtSubscriptionScopeResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DeploymentsClientListAtTenantScopePager provides operations for iterating over paged responses.
type DeploymentsClientListAtTenantScopePager struct {
	client    *DeploymentsClient
	current   DeploymentsClientListAtTenantScopeResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeploymentsClientListAtTenantScopeResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DeploymentsClientListAtTenantScopePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeploymentListResult.NextLink == nil || len(*p.current.DeploymentListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DeploymentsClientListAtTenantScopePager) NextPage(ctx context.Context) (DeploymentsClientListAtTenantScopeResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DeploymentsClientListAtTenantScopeResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DeploymentsClientListAtTenantScopeResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DeploymentsClientListAtTenantScopeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DeploymentsClientListAtTenantScopeResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAtTenantScopeHandleResponse(resp)
	if err != nil {
		return DeploymentsClientListAtTenantScopeResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DeploymentsClientListByResourceGroupPager provides operations for iterating over paged responses.
type DeploymentsClientListByResourceGroupPager struct {
	client    *DeploymentsClient
	current   DeploymentsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeploymentsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DeploymentsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeploymentListResult.NextLink == nil || len(*p.current.DeploymentListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DeploymentsClientListByResourceGroupPager) NextPage(ctx context.Context) (DeploymentsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DeploymentsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DeploymentsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DeploymentsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DeploymentsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return DeploymentsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *OperationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *OperationsClientListPager) NextPage(ctx context.Context) (OperationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return OperationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return OperationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProvidersClientListAtTenantScopePager provides operations for iterating over paged responses.
type ProvidersClientListAtTenantScopePager struct {
	client    *ProvidersClient
	current   ProvidersClientListAtTenantScopeResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProvidersClientListAtTenantScopeResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProvidersClientListAtTenantScopePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProviderListResult.NextLink == nil || len(*p.current.ProviderListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProvidersClientListAtTenantScopePager) NextPage(ctx context.Context) (ProvidersClientListAtTenantScopeResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProvidersClientListAtTenantScopeResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProvidersClientListAtTenantScopeResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProvidersClientListAtTenantScopeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProvidersClientListAtTenantScopeResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAtTenantScopeHandleResponse(resp)
	if err != nil {
		return ProvidersClientListAtTenantScopeResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProvidersClientListPager provides operations for iterating over paged responses.
type ProvidersClientListPager struct {
	client    *ProvidersClient
	current   ProvidersClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProvidersClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProvidersClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProviderListResult.NextLink == nil || len(*p.current.ProviderListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProvidersClientListPager) NextPage(ctx context.Context) (ProvidersClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProvidersClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProvidersClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProvidersClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProvidersClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ProvidersClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ResourceGroupsClientListPager provides operations for iterating over paged responses.
type ResourceGroupsClientListPager struct {
	client    *ResourceGroupsClient
	current   ResourceGroupsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ResourceGroupsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ResourceGroupsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceGroupListResult.NextLink == nil || len(*p.current.ResourceGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ResourceGroupsClientListPager) NextPage(ctx context.Context) (ResourceGroupsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ResourceGroupsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ResourceGroupsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ResourceGroupsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ResourceGroupsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ResourceGroupsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TagsClientListPager provides operations for iterating over paged responses.
type TagsClientListPager struct {
	client    *TagsClient
	current   TagsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TagsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TagsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagsListResult.NextLink == nil || len(*p.current.TagsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *TagsClientListPager) NextPage(ctx context.Context) (TagsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return TagsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TagsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TagsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TagsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return TagsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}
