//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armservicefabric

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"runtime/debug"
	"testing"

	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/azidentity"
	"golang.org/x/net/http2"
)

var (
	ctx            context.Context
	subscriptionId string
	cred           azcore.TokenCredential
	err            error
	con            *arm.Connection
	mockHost       string
)

func TestClusters_Get(t *testing.T) {
	// From example Get a cluster
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewClustersClient(con,
		"00000000-0000-0000-0000-000000000000")
	res, err := client.Get(ctx,
		"resRg",
		"myCluster",
		&ClustersGetOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.Cluster.ID == nil {
		t.Fatal("Cluster.ID should not be nil!")
	}
}

func TestClusters_CreateOrUpdate(t *testing.T) {
	// From example Put a cluster with maximum parameters
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewClustersClient(con,
		"00000000-0000-0000-0000-000000000000")
	poller, err := client.BeginCreateOrUpdate(ctx,
		"resRg",
		"myCluster",
		Cluster{
			Resource: Resource{
				Location: to.StringPtr("eastus"),
				Tags:     map[string]*string{},
			},
			Properties: &ClusterProperties{
				AddOnFeatures: []*AddOnFeatures{
					AddOnFeaturesRepairManager.ToPtr(),
					AddOnFeaturesDNSService.ToPtr(),
					AddOnFeaturesBackupRestoreService.ToPtr(),
					AddOnFeaturesResourceMonitorService.ToPtr()},
				ApplicationTypeVersionsCleanupPolicy: &ApplicationTypeVersionsCleanupPolicy{
					MaxUnusedVersionsToKeep: to.Int64Ptr(2),
				},
				AzureActiveDirectory: &AzureActiveDirectory{
					ClientApplication:  to.StringPtr("d151ad89-4bce-4ae8-b3d1-1dc79679fa75"),
					ClusterApplication: to.StringPtr("5886372e-7bf4-4878-a497-8098aba608ae"),
					TenantID:           to.StringPtr("6abcc6a0-8666-43f1-87b8-172cf86a9f9c"),
				},
				CertificateCommonNames: &ServerCertificateCommonNames{
					CommonNames: []*ServerCertificateCommonName{
						{
							CertificateCommonName:       to.StringPtr("abc.com"),
							CertificateIssuerThumbprint: to.StringPtr("12599211F8F14C90AFA9532AD79A6F2CA1C00622"),
						}},
					X509StoreName: StoreNameMy.ToPtr(),
				},
				ClientCertificateCommonNames: []*ClientCertificateCommonName{
					{
						CertificateCommonName:       to.StringPtr("abc.com"),
						CertificateIssuerThumbprint: to.StringPtr("5F3660C715EBBDA31DB1FFDCF508302348DE8E7A"),
						IsAdmin:                     to.BoolPtr(true),
					}},
				ClientCertificateThumbprints: []*ClientCertificateThumbprint{
					{
						CertificateThumbprint: to.StringPtr("5F3660C715EBBDA31DB1FFDCF508302348DE8E7A"),
						IsAdmin:               to.BoolPtr(true),
					}},
				ClusterCodeVersion: to.StringPtr("7.0.470.9590"),
				DiagnosticsStorageAccountConfig: &DiagnosticsStorageAccountConfig{
					BlobEndpoint:            to.StringPtr("https://diag.blob.core.windows.net/"),
					ProtectedAccountKeyName: to.StringPtr("StorageAccountKey1"),
					QueueEndpoint:           to.StringPtr("https://diag.queue.core.windows.net/"),
					StorageAccountName:      to.StringPtr("diag"),
					TableEndpoint:           to.StringPtr("https://diag.table.core.windows.net/"),
				},
				EventStoreServiceEnabled: to.BoolPtr(true),
				FabricSettings: []*SettingsSectionDescription{
					{
						Name: to.StringPtr("UpgradeService"),
						Parameters: []*SettingsParameterDescription{
							{
								Name:  to.StringPtr("AppPollIntervalInSeconds"),
								Value: to.StringPtr("60"),
							}},
					}},
				InfrastructureServiceManager: to.BoolPtr(true),
				ManagementEndpoint:           to.StringPtr("https://myCluster.eastus.cloudapp.azure.com:19080"),
				NodeTypes: []*NodeTypeDescription{
					{
						Name: to.StringPtr("nt1vm"),
						ApplicationPorts: &EndpointRangeDescription{
							EndPort:   to.Int32Ptr(30000),
							StartPort: to.Int32Ptr(20000),
						},
						ClientConnectionEndpointPort: to.Int32Ptr(19000),
						DurabilityLevel:              DurabilityLevelSilver.ToPtr(),
						EphemeralPorts: &EndpointRangeDescription{
							EndPort:   to.Int32Ptr(64000),
							StartPort: to.Int32Ptr(49000),
						},
						HTTPGatewayEndpointPort:   to.Int32Ptr(19007),
						IsPrimary:                 to.BoolPtr(true),
						IsStateless:               to.BoolPtr(false),
						MultipleAvailabilityZones: to.BoolPtr(true),
						VMInstanceCount:           to.Int32Ptr(5),
					}},
				Notifications: []*Notification{
					{
						IsEnabled:            to.BoolPtr(true),
						NotificationCategory: NotificationCategoryWaveProgress.ToPtr(),
						NotificationLevel:    NotificationLevelCritical.ToPtr(),
						NotificationTargets: []*NotificationTarget{
							{
								NotificationChannel: NotificationChannelEmailUser.ToPtr(),
								Receivers: []*string{
									to.StringPtr("****@microsoft.com"),
									to.StringPtr("****@microsoft.com")},
							},
							{
								NotificationChannel: NotificationChannelEmailSubscription.ToPtr(),
								Receivers: []*string{
									to.StringPtr("Owner"),
									to.StringPtr("AccountAdmin")},
							}},
					},
					{
						IsEnabled:            to.BoolPtr(true),
						NotificationCategory: NotificationCategoryWaveProgress.ToPtr(),
						NotificationLevel:    NotificationLevelAll.ToPtr(),
						NotificationTargets: []*NotificationTarget{
							{
								NotificationChannel: NotificationChannelEmailUser.ToPtr(),
								Receivers: []*string{
									to.StringPtr("****@microsoft.com"),
									to.StringPtr("****@microsoft.com")},
							},
							{
								NotificationChannel: NotificationChannelEmailSubscription.ToPtr(),
								Receivers: []*string{
									to.StringPtr("Owner"),
									to.StringPtr("AccountAdmin")},
							}},
					}},
				ReliabilityLevel: ReliabilityLevelPlatinum.ToPtr(),
				ReverseProxyCertificateCommonNames: &ServerCertificateCommonNames{
					CommonNames: []*ServerCertificateCommonName{
						{
							CertificateCommonName:       to.StringPtr("abc.com"),
							CertificateIssuerThumbprint: to.StringPtr("12599211F8F14C90AFA9532AD79A6F2CA1C00622"),
						}},
					X509StoreName: StoreNameMy.ToPtr(),
				},
				SfZonalUpgradeMode: SfZonalUpgradeModeHierarchical.ToPtr(),
				UpgradeDescription: &ClusterUpgradePolicy{
					DeltaHealthPolicy: &ClusterUpgradeDeltaHealthPolicy{
						ApplicationDeltaHealthPolicies: map[string]*ApplicationDeltaHealthPolicy{
							"fabric:/myApp1": &ApplicationDeltaHealthPolicy{
								DefaultServiceTypeDeltaHealthPolicy: &ServiceTypeDeltaHealthPolicy{
									MaxPercentDeltaUnhealthyServices: to.Int32Ptr(0),
								},
								ServiceTypeDeltaHealthPolicies: map[string]*ServiceTypeDeltaHealthPolicy{
									"myServiceType1": &ServiceTypeDeltaHealthPolicy{
										MaxPercentDeltaUnhealthyServices: to.Int32Ptr(0),
									},
								},
							},
						},
						MaxPercentDeltaUnhealthyApplications:       to.Int32Ptr(0),
						MaxPercentDeltaUnhealthyNodes:              to.Int32Ptr(0),
						MaxPercentUpgradeDomainDeltaUnhealthyNodes: to.Int32Ptr(0),
					},
					ForceRestart:              to.BoolPtr(false),
					HealthCheckRetryTimeout:   to.StringPtr("00:05:00"),
					HealthCheckStableDuration: to.StringPtr("00:00:30"),
					HealthCheckWaitDuration:   to.StringPtr("00:00:30"),
					HealthPolicy: &ClusterHealthPolicy{
						ApplicationHealthPolicies: map[string]*ApplicationHealthPolicy{
							"fabric:/myApp1": &ApplicationHealthPolicy{
								DefaultServiceTypeHealthPolicy: &ServiceTypeHealthPolicy{
									MaxPercentUnhealthyServices: to.Int32Ptr(0),
								},
								ServiceTypeHealthPolicies: map[string]*ServiceTypeHealthPolicy{
									"myServiceType1": &ServiceTypeHealthPolicy{
										MaxPercentUnhealthyServices: to.Int32Ptr(100),
									},
								},
							},
						},
						MaxPercentUnhealthyApplications: to.Int32Ptr(0),
						MaxPercentUnhealthyNodes:        to.Int32Ptr(0),
					},
					UpgradeDomainTimeout:          to.StringPtr("00:15:00"),
					UpgradeReplicaSetCheckTimeout: to.StringPtr("00:10:00"),
					UpgradeTimeout:                to.StringPtr("01:00:00"),
				},
				UpgradeMode:                   UpgradeModeManual.ToPtr(),
				UpgradePauseEndTimestampUTC:   to.TimePtr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2021-06-25T22:00:00Z"); return t }()),
				UpgradePauseStartTimestampUTC: to.TimePtr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2021-06-21T22:00:00Z"); return t }()),
				UpgradeWave:                   ClusterUpgradeCadenceWave1.ToPtr(),
				VMImage:                       to.StringPtr("Windows"),
				VmssZonalUpgradeMode:          VmssZonalUpgradeModeParallel.ToPtr(),
			},
		},
		&ClustersBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err := poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.Cluster.ID == nil {
		t.Fatal("Cluster.ID should not be nil!")
	}

	// From example Put a cluster with minimum parameters
	poller, err = client.BeginCreateOrUpdate(ctx,
		"resRg",
		"myCluster",
		Cluster{
			Resource: Resource{
				Location: to.StringPtr("eastus"),
				Tags:     map[string]*string{},
			},
			Properties: &ClusterProperties{
				DiagnosticsStorageAccountConfig: &DiagnosticsStorageAccountConfig{
					BlobEndpoint:            to.StringPtr("https://diag.blob.core.windows.net/"),
					ProtectedAccountKeyName: to.StringPtr("StorageAccountKey1"),
					QueueEndpoint:           to.StringPtr("https://diag.queue.core.windows.net/"),
					StorageAccountName:      to.StringPtr("diag"),
					TableEndpoint:           to.StringPtr("https://diag.table.core.windows.net/"),
				},
				FabricSettings: []*SettingsSectionDescription{
					{
						Name: to.StringPtr("UpgradeService"),
						Parameters: []*SettingsParameterDescription{
							{
								Name:  to.StringPtr("AppPollIntervalInSeconds"),
								Value: to.StringPtr("60"),
							}},
					}},
				ManagementEndpoint: to.StringPtr("http://myCluster.eastus.cloudapp.azure.com:19080"),
				NodeTypes: []*NodeTypeDescription{
					{
						Name: to.StringPtr("nt1vm"),
						ApplicationPorts: &EndpointRangeDescription{
							EndPort:   to.Int32Ptr(30000),
							StartPort: to.Int32Ptr(20000),
						},
						ClientConnectionEndpointPort: to.Int32Ptr(19000),
						DurabilityLevel:              DurabilityLevelBronze.ToPtr(),
						EphemeralPorts: &EndpointRangeDescription{
							EndPort:   to.Int32Ptr(64000),
							StartPort: to.Int32Ptr(49000),
						},
						HTTPGatewayEndpointPort: to.Int32Ptr(19007),
						IsPrimary:               to.BoolPtr(true),
						VMInstanceCount:         to.Int32Ptr(5),
					}},
				ReliabilityLevel: ReliabilityLevelSilver.ToPtr(),
				UpgradeMode:      UpgradeModeAutomatic.ToPtr(),
			},
		},
		&ClustersBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.Cluster.ID == nil {
		t.Fatal("Cluster.ID should not be nil!")
	}
}

func TestClusters_Update(t *testing.T) {
	// From example Patch a cluster
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewClustersClient(con,
		"00000000-0000-0000-0000-000000000000")
	poller, err := client.BeginUpdate(ctx,
		"resRg",
		"myCluster",
		ClusterUpdateParameters{
			Properties: &ClusterPropertiesUpdateParameters{
				EventStoreServiceEnabled: to.BoolPtr(true),
				NodeTypes: []*NodeTypeDescription{
					{
						Name: to.StringPtr("nt1vm"),
						ApplicationPorts: &EndpointRangeDescription{
							EndPort:   to.Int32Ptr(30000),
							StartPort: to.Int32Ptr(20000),
						},
						ClientConnectionEndpointPort: to.Int32Ptr(19000),
						DurabilityLevel:              DurabilityLevelBronze.ToPtr(),
						EphemeralPorts: &EndpointRangeDescription{
							EndPort:   to.Int32Ptr(64000),
							StartPort: to.Int32Ptr(49000),
						},
						HTTPGatewayEndpointPort: to.Int32Ptr(19007),
						IsPrimary:               to.BoolPtr(true),
						VMInstanceCount:         to.Int32Ptr(5),
					},
					{
						Name: to.StringPtr("testnt1"),
						ApplicationPorts: &EndpointRangeDescription{
							EndPort:   to.Int32Ptr(2000),
							StartPort: to.Int32Ptr(1000),
						},
						ClientConnectionEndpointPort: to.Int32Ptr(0),
						DurabilityLevel:              DurabilityLevelBronze.ToPtr(),
						EphemeralPorts: &EndpointRangeDescription{
							EndPort:   to.Int32Ptr(4000),
							StartPort: to.Int32Ptr(3000),
						},
						HTTPGatewayEndpointPort: to.Int32Ptr(0),
						IsPrimary:               to.BoolPtr(false),
						VMInstanceCount:         to.Int32Ptr(3),
					}},
				ReliabilityLevel:              ReliabilityLevelBronze.ToPtr(),
				UpgradeMode:                   UpgradeModeAutomatic.ToPtr(),
				UpgradePauseEndTimestampUTC:   to.TimePtr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2021-06-25T22:00:00Z"); return t }()),
				UpgradePauseStartTimestampUTC: to.TimePtr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2021-06-21T22:00:00Z"); return t }()),
				UpgradeWave:                   ClusterUpgradeCadenceWave0.ToPtr(),
			},
			Tags: map[string]*string{
				"a": to.StringPtr("b"),
			},
		},
		&ClustersBeginUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err := poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.Cluster.ID == nil {
		t.Fatal("Cluster.ID should not be nil!")
	}
}

func TestClusters_Delete(t *testing.T) {
	// From example Delete a cluster
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewClustersClient(con,
		"00000000-0000-0000-0000-000000000000")
	_, err := client.Delete(ctx,
		"resRg",
		"myCluster",
		&ClustersDeleteOptions{})
	if err != nil {
		t.Fatal(err)
	}
}

func TestClusters_ListByResourceGroup(t *testing.T) {
	// From example List cluster by resource group
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewClustersClient(con,
		"00000000-0000-0000-0000-000000000000")
	_, err := client.ListByResourceGroup(ctx,
		"resRg",
		&ClustersListByResourceGroupOptions{})
	if err != nil {
		t.Fatal(err)
	}
}

func TestClusters_List(t *testing.T) {
	// From example List clusters
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewClustersClient(con,
		"00000000-0000-0000-0000-000000000000")
	_, err := client.List(ctx,
		&ClustersListOptions{})
	if err != nil {
		t.Fatal(err)
	}
}

func TestClusters_ListUpgradableVersions(t *testing.T) {
	// From example Get minimum and maximum code versions
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewClustersClient(con,
		"00000000-0000-0000-0000-000000000000")
	_, err := client.ListUpgradableVersions(ctx,
		"resRg",
		"myCluster",
		&ClustersListUpgradableVersionsOptions{})
	if err != nil {
		t.Fatal(err)
	}

	// From example Get upgrade path
	_, err = client.ListUpgradableVersions(ctx,
		"resRg",
		"myCluster",
		&ClustersListUpgradableVersionsOptions{VersionsDescription: &UpgradableVersionsDescription{
			TargetVersion: to.StringPtr("7.2.432.9590"),
		},
		})
	if err != nil {
		t.Fatal(err)
	}
}

func TestClusterVersions_Get(t *testing.T) {
	// From example Get cluster version
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewClusterVersionsClient(con,
		"00000000-0000-0000-0000-000000000000")
	_, err := client.Get(ctx,
		"eastus",
		"6.1.480.9494",
		&ClusterVersionsGetOptions{})
	if err != nil {
		t.Fatal(err)
	}
}

func TestClusterVersions_GetByEnvironment(t *testing.T) {
	// From example Get cluster version by environment
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewClusterVersionsClient(con,
		"00000000-0000-0000-0000-000000000000")
	_, err := client.GetByEnvironment(ctx,
		"eastus",
		Enum14Windows,
		"6.1.480.9494",
		&ClusterVersionsGetByEnvironmentOptions{})
	if err != nil {
		t.Fatal(err)
	}
}

func TestClusterVersions_List(t *testing.T) {
	// From example List cluster versions
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewClusterVersionsClient(con,
		"00000000-0000-0000-0000-000000000000")
	_, err := client.List(ctx,
		"eastus",
		&ClusterVersionsListOptions{})
	if err != nil {
		t.Fatal(err)
	}
}

func TestClusterVersions_ListByEnvironment(t *testing.T) {
	// From example List cluster versions by environment
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewClusterVersionsClient(con,
		"00000000-0000-0000-0000-000000000000")
	_, err := client.ListByEnvironment(ctx,
		"eastus",
		Enum14Windows,
		&ClusterVersionsListByEnvironmentOptions{})
	if err != nil {
		t.Fatal(err)
	}
}

func TestOperations_List(t *testing.T) {
	t.Skip("Warning: No test steps for this operation!")
}

func TestApplicationTypes_Get(t *testing.T) {
	// From example Get an application type
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewApplicationTypesClient(con,
		"00000000-0000-0000-0000-000000000000")
	res, err := client.Get(ctx,
		"resRg",
		"myCluster",
		"myAppType",
		&ApplicationTypesGetOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.ApplicationTypeResource.ID == nil {
		t.Fatal("ApplicationTypeResource.ID should not be nil!")
	}
}

func TestApplicationTypes_CreateOrUpdate(t *testing.T) {
	// From example Put an application type
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewApplicationTypesClient(con,
		"00000000-0000-0000-0000-000000000000")
	res, err := client.CreateOrUpdate(ctx,
		"resRg",
		"myCluster",
		"myAppType",
		ApplicationTypeResource{
			ProxyResource: ProxyResource{
				Tags: map[string]*string{},
			},
		},
		&ApplicationTypesCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.ApplicationTypeResource.ID == nil {
		t.Fatal("ApplicationTypeResource.ID should not be nil!")
	}
}

func TestApplicationTypes_Delete(t *testing.T) {
	// From example Delete an application type
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewApplicationTypesClient(con,
		"00000000-0000-0000-0000-000000000000")
	poller, err := client.BeginDelete(ctx,
		"resRg",
		"myCluster",
		"myAppType",
		&ApplicationTypesBeginDeleteOptions{})
	if err != nil {
		t.Fatal(err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
}

func TestApplicationTypes_List(t *testing.T) {
	// From example Get a list of application type name resources
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewApplicationTypesClient(con,
		"00000000-0000-0000-0000-000000000000")
	_, err := client.List(ctx,
		"resRg",
		"myCluster",
		&ApplicationTypesListOptions{})
	if err != nil {
		t.Fatal(err)
	}
}

func TestApplicationTypeVersions_Get(t *testing.T) {
	// From example Get an application type version
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewApplicationTypeVersionsClient(con,
		"00000000-0000-0000-0000-000000000000")
	res, err := client.Get(ctx,
		"resRg",
		"myCluster",
		"myAppType",
		"1.0",
		&ApplicationTypeVersionsGetOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.ApplicationTypeVersionResource.ID == nil {
		t.Fatal("ApplicationTypeVersionResource.ID should not be nil!")
	}
}

func TestApplicationTypeVersions_CreateOrUpdate(t *testing.T) {
	// From example Put an application type version
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewApplicationTypeVersionsClient(con,
		"00000000-0000-0000-0000-000000000000")
	poller, err := client.BeginCreateOrUpdate(ctx,
		"resRg",
		"myCluster",
		"myAppType",
		"1.0",
		ApplicationTypeVersionResource{
			ProxyResource: ProxyResource{
				Tags: map[string]*string{},
			},
			Properties: &ApplicationTypeVersionResourceProperties{
				AppPackageURL: to.StringPtr("http://fakelink.test.com/MyAppType"),
			},
		},
		&ApplicationTypeVersionsBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err := poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ApplicationTypeVersionResource.ID == nil {
		t.Fatal("ApplicationTypeVersionResource.ID should not be nil!")
	}
}

func TestApplicationTypeVersions_Delete(t *testing.T) {
	// From example Delete an application type version
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewApplicationTypeVersionsClient(con,
		"00000000-0000-0000-0000-000000000000")
	poller, err := client.BeginDelete(ctx,
		"resRg",
		"myCluster",
		"myAppType",
		"1.0",
		&ApplicationTypeVersionsBeginDeleteOptions{})
	if err != nil {
		t.Fatal(err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
}

func TestApplicationTypeVersions_List(t *testing.T) {
	// From example Get a list of application type version resources
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewApplicationTypeVersionsClient(con,
		"00000000-0000-0000-0000-000000000000")
	_, err := client.List(ctx,
		"resRg",
		"myCluster",
		"myAppType",
		&ApplicationTypeVersionsListOptions{})
	if err != nil {
		t.Fatal(err)
	}
}

func TestApplications_Get(t *testing.T) {
	// From example Get an application
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewApplicationsClient(con,
		"00000000-0000-0000-0000-000000000000")
	res, err := client.Get(ctx,
		"resRg",
		"myCluster",
		"myApp",
		&ApplicationsGetOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.ApplicationResource.ID == nil {
		t.Fatal("ApplicationResource.ID should not be nil!")
	}
}

func TestApplications_CreateOrUpdate(t *testing.T) {
	// From example Put an application with maximum parameters
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewApplicationsClient(con,
		"00000000-0000-0000-0000-000000000000")
	poller, err := client.BeginCreateOrUpdate(ctx,
		"resRg",
		"myCluster",
		"myApp",
		ApplicationResource{
			ProxyResource: ProxyResource{
				Tags: map[string]*string{},
			},
			Properties: &ApplicationResourceProperties{
				ApplicationResourceUpdateProperties: ApplicationResourceUpdateProperties{
					MaximumNodes: to.Int64Ptr(3),
					Metrics: []*ApplicationMetricDescription{
						{
							Name:                     to.StringPtr("metric1"),
							MaximumCapacity:          to.Int64Ptr(3),
							ReservationCapacity:      to.Int64Ptr(1),
							TotalApplicationCapacity: to.Int64Ptr(5),
						}},
					MinimumNodes: to.Int64Ptr(1),
					Parameters: map[string]*string{
						"param1": to.StringPtr("value1"),
					},
					RemoveApplicationCapacity: to.BoolPtr(false),
					TypeVersion:               to.StringPtr("1.0"),
					UpgradePolicy: &ApplicationUpgradePolicy{
						ApplicationHealthPolicy: &ArmApplicationHealthPolicy{
							ConsiderWarningAsError: to.BoolPtr(true),
							DefaultServiceTypeHealthPolicy: &ArmServiceTypeHealthPolicy{
								MaxPercentUnhealthyPartitionsPerService: to.Int32Ptr(0),
								MaxPercentUnhealthyReplicasPerPartition: to.Int32Ptr(0),
								MaxPercentUnhealthyServices:             to.Int32Ptr(0),
							},
							MaxPercentUnhealthyDeployedApplications: to.Int32Ptr(0),
						},
						ForceRestart: to.BoolPtr(false),
						RollingUpgradeMonitoringPolicy: &ArmRollingUpgradeMonitoringPolicy{
							FailureAction:             ArmUpgradeFailureActionRollback.ToPtr(),
							HealthCheckRetryTimeout:   to.StringPtr("00:10:00"),
							HealthCheckStableDuration: to.StringPtr("00:05:00"),
							HealthCheckWaitDuration:   to.StringPtr("00:02:00"),
							UpgradeDomainTimeout:      to.StringPtr("1.06:00:00"),
							UpgradeTimeout:            to.StringPtr("01:00:00"),
						},
						UpgradeMode:                   RollingUpgradeModeMonitored.ToPtr(),
						UpgradeReplicaSetCheckTimeout: to.StringPtr("01:00:00"),
					},
				},
				TypeName: to.StringPtr("myAppType"),
			},
		},
		&ApplicationsBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err := poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ApplicationResource.ID == nil {
		t.Fatal("ApplicationResource.ID should not be nil!")
	}

	// From example Put an application with minimum parameters
	poller, err = client.BeginCreateOrUpdate(ctx,
		"resRg",
		"myCluster",
		"myApp",
		ApplicationResource{
			ProxyResource: ProxyResource{
				Location: to.StringPtr("eastus"),
				Tags:     map[string]*string{},
			},
			Properties: &ApplicationResourceProperties{
				ApplicationResourceUpdateProperties: ApplicationResourceUpdateProperties{
					RemoveApplicationCapacity: to.BoolPtr(false),
					TypeVersion:               to.StringPtr("1.0"),
				},
				TypeName: to.StringPtr("myAppType"),
			},
		},
		&ApplicationsBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ApplicationResource.ID == nil {
		t.Fatal("ApplicationResource.ID should not be nil!")
	}

	// From example Put an application with recreate option
	poller, err = client.BeginCreateOrUpdate(ctx,
		"resRg",
		"myCluster",
		"myApp",
		ApplicationResource{
			ProxyResource: ProxyResource{
				Tags: map[string]*string{},
			},
			Properties: &ApplicationResourceProperties{
				ApplicationResourceUpdateProperties: ApplicationResourceUpdateProperties{
					Parameters: map[string]*string{
						"param1": to.StringPtr("value1"),
					},
					TypeVersion: to.StringPtr("1.0"),
					UpgradePolicy: &ApplicationUpgradePolicy{
						RecreateApplication: to.BoolPtr(true),
					},
				},
				TypeName: to.StringPtr("myAppType"),
			},
		},
		&ApplicationsBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ApplicationResource.ID == nil {
		t.Fatal("ApplicationResource.ID should not be nil!")
	}
}

func TestApplications_Update(t *testing.T) {
	// From example Patch an application
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewApplicationsClient(con,
		"00000000-0000-0000-0000-000000000000")
	poller, err := client.BeginUpdate(ctx,
		"resRg",
		"myCluster",
		"myApp",
		ApplicationResourceUpdate{
			ProxyResource: ProxyResource{
				Location: to.StringPtr("eastus"),
				Tags:     map[string]*string{},
			},
			Properties: &ApplicationResourceUpdateProperties{
				Metrics: []*ApplicationMetricDescription{
					{
						Name:                     to.StringPtr("metric1"),
						MaximumCapacity:          to.Int64Ptr(3),
						ReservationCapacity:      to.Int64Ptr(1),
						TotalApplicationCapacity: to.Int64Ptr(5),
					}},
				RemoveApplicationCapacity: to.BoolPtr(false),
				TypeVersion:               to.StringPtr("1.0"),
			},
		},
		&ApplicationsBeginUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err := poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ApplicationResource.ID == nil {
		t.Fatal("ApplicationResource.ID should not be nil!")
	}
}

func TestApplications_Delete(t *testing.T) {
	// From example Delete an application
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewApplicationsClient(con,
		"00000000-0000-0000-0000-000000000000")
	poller, err := client.BeginDelete(ctx,
		"resRg",
		"myCluster",
		"myApp",
		&ApplicationsBeginDeleteOptions{})
	if err != nil {
		t.Fatal(err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
}

func TestApplications_List(t *testing.T) {
	// From example Get a list of application resources
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewApplicationsClient(con,
		"00000000-0000-0000-0000-000000000000")
	_, err := client.List(ctx,
		"resRg",
		"myCluster",
		&ApplicationsListOptions{})
	if err != nil {
		t.Fatal(err)
	}
}

func TestServices_Get(t *testing.T) {
	// From example Get a service
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewServicesClient(con,
		"00000000-0000-0000-0000-000000000000")
	res, err := client.Get(ctx,
		"resRg",
		"myCluster",
		"myApp",
		"myService",
		&ServicesGetOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.ServiceResource.ID == nil {
		t.Fatal("ServiceResource.ID should not be nil!")
	}
}

func TestServices_CreateOrUpdate(t *testing.T) {
	// From example Put a service with maximum parameters
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewServicesClient(con,
		"00000000-0000-0000-0000-000000000000")
	poller, err := client.BeginCreateOrUpdate(ctx,
		"resRg",
		"myCluster",
		"myApp",
		"myService",
		ServiceResource{
			ProxyResource: ProxyResource{
				Tags: map[string]*string{},
			},
			Properties: &StatelessServiceProperties{
				ServiceResourceProperties: ServiceResourceProperties{
					ServiceResourcePropertiesBase: ServiceResourcePropertiesBase{
						CorrelationScheme: []*ServiceCorrelationDescription{
							{
								Scheme:      ServiceCorrelationSchemeAffinity.ToPtr(),
								ServiceName: to.StringPtr("fabric:/app1/app1~svc1"),
							}},
						DefaultMoveCost:      MoveCostMedium.ToPtr(),
						PlacementConstraints: to.StringPtr("NodeType==frontend"),
						ServiceLoadMetrics: []*ServiceLoadMetricDescription{
							{
								Name:   to.StringPtr("metric1"),
								Weight: ServiceLoadMetricWeightLow.ToPtr(),
							}},
						ServicePlacementPolicies: []ServicePlacementPolicyDescription{},
					},
					PartitionDescription: &SingletonPartitionSchemeDescription{
						PartitionSchemeDescription: PartitionSchemeDescription{
							PartitionScheme: PartitionSchemeSingleton.ToPtr(),
						},
					},
					ServiceDNSName:               to.StringPtr("my.service.dns"),
					ServiceKind:                  ServiceKindStateless.ToPtr(),
					ServicePackageActivationMode: ArmServicePackageActivationModeSharedProcess.ToPtr(),
					ServiceTypeName:              to.StringPtr("myServiceType"),
				},
				InstanceCount: to.Int32Ptr(5),
			},
		},
		&ServicesBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err := poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ServiceResource.ID == nil {
		t.Fatal("ServiceResource.ID should not be nil!")
	}

	// From example Put a service with minimum parameters
	poller, err = client.BeginCreateOrUpdate(ctx,
		"resRg",
		"myCluster",
		"myApp",
		"myService",
		ServiceResource{
			ProxyResource: ProxyResource{
				Tags: map[string]*string{},
			},
			Properties: &StatelessServiceProperties{
				ServiceResourceProperties: ServiceResourceProperties{
					PartitionDescription: &SingletonPartitionSchemeDescription{
						PartitionSchemeDescription: PartitionSchemeDescription{
							PartitionScheme: PartitionSchemeSingleton.ToPtr(),
						},
					},
					ServiceKind:     ServiceKindStateless.ToPtr(),
					ServiceTypeName: to.StringPtr("myServiceType"),
				},
				InstanceCount: to.Int32Ptr(1),
			},
		},
		&ServicesBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ServiceResource.ID == nil {
		t.Fatal("ServiceResource.ID should not be nil!")
	}
}

func TestServices_Update(t *testing.T) {
	// From example Patch a service
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewServicesClient(con,
		"00000000-0000-0000-0000-000000000000")
	poller, err := client.BeginUpdate(ctx,
		"resRg",
		"myCluster",
		"myApp",
		"myService",
		ServiceResourceUpdate{
			ProxyResource: ProxyResource{
				Tags: map[string]*string{},
			},
			Properties: &StatelessServiceUpdateProperties{
				ServiceResourceUpdateProperties: ServiceResourceUpdateProperties{
					ServiceResourcePropertiesBase: ServiceResourcePropertiesBase{
						ServiceLoadMetrics: []*ServiceLoadMetricDescription{
							{
								Name:   to.StringPtr("metric1"),
								Weight: ServiceLoadMetricWeightLow.ToPtr(),
							}},
					},
					ServiceKind: ServiceKindStateless.ToPtr(),
				},
			},
		},
		&ServicesBeginUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err := poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ServiceResource.ID == nil {
		t.Fatal("ServiceResource.ID should not be nil!")
	}
}

func TestServices_Delete(t *testing.T) {
	// From example Delete a service
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewServicesClient(con,
		"00000000-0000-0000-0000-000000000000")
	poller, err := client.BeginDelete(ctx,
		"resRg",
		"myCluster",
		"myApp",
		"myService",
		&ServicesBeginDeleteOptions{})
	if err != nil {
		t.Fatal(err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
}

func TestServices_List(t *testing.T) {
	// From example Get a list of service resources
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewServicesClient(con,
		"00000000-0000-0000-0000-000000000000")
	_, err := client.List(ctx,
		"resRg",
		"myCluster",
		"myApp",
		&ServicesListOptions{})
	if err != nil {
		t.Fatal(err)
	}
}

// TestMain will exec each test
func TestMain(m *testing.M) {
	setUp()
	retCode := m.Run() // exec test and this returns an exit code to pass to os
	tearDown()
	os.Exit(retCode)
}

func getEnv(key, fallback string) string {
	if value, ok := os.LookupEnv(key); ok {
		return value
	}
	return fallback
}

func setUp() {
	ctx = context.Background()
	subscriptionId = getEnv("SUBSCRIPTION_ID", "00000000-0000-0000-0000-000000000000")
	mockHost = getEnv("AZURE_VIRTUAL_SERVER_HOST", "https://localhost:8443")

	tr := &http.Transport{}
	if err := http2.ConfigureTransport(tr); err != nil {
		fmt.Printf("Failed to configure http2 transport: %v", err)
	}
	tr.TLSClientConfig.InsecureSkipVerify = true
	client := &http.Client{Transport: tr}
	cred, err = azidentity.NewEnvironmentCredential(&azidentity.EnvironmentCredentialOptions{AuthorityHost: mockHost, HTTPClient: client})
	if err != nil {
		panic(err)
	}

	con = arm.NewConnection(mockHost, cred, &arm.ConnectionOptions{
		Logging: policy.LogOptions{
			IncludeBody: true,
		},
		HTTPClient: client,
	})
}

func tearDown() {

}
