//go:build go1.18
// +build go1.18

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armservicemap

import (
	"encoding/json"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"reflect"
)

// GetRelationship implements the RelationshipClassification interface for type Acceptor.
func (a *Acceptor) GetRelationship() *Relationship {
	return &Relationship{
		Kind: a.Kind,
		ID: a.ID,
		Type: a.Type,
		Name: a.Name,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Acceptor.
func (a Acceptor) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", a.ID)
	objectMap["kind"] = RelationshipKindRelAcceptor
	populate(objectMap, "name", a.Name)
	populate(objectMap, "properties", a.Properties)
	populate(objectMap, "type", a.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Acceptor.
func (a *Acceptor) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, &a.ID)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, &a.Kind)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, &a.Name)
				delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, &a.Properties)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, &a.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type AcceptorProperties.
func (a AcceptorProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "destination", a.Destination)
	populateTimeRFC3339(objectMap, "endTime", a.EndTime)
	populate(objectMap, "source", a.Source)
	populateTimeRFC3339(objectMap, "startTime", a.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AcceptorProperties.
func (a *AcceptorProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "destination":
				err = unpopulate(val, &a.Destination)
				delete(rawMsg, key)
		case "endTime":
				err = unpopulateTimeRFC3339(val, &a.EndTime)
				delete(rawMsg, key)
		case "source":
				err = unpopulate(val, &a.Source)
				delete(rawMsg, key)
		case "startTime":
				err = unpopulateTimeRFC3339(val, &a.StartTime)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetHostingConfiguration implements the HostingConfigurationClassification interface for type AzureHostingConfiguration.
func (a *AzureHostingConfiguration) GetHostingConfiguration() *HostingConfiguration {
	return &HostingConfiguration{
		Provider: a.Provider,
		Kind: a.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureHostingConfiguration.
func (a AzureHostingConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cloudService", a.CloudService)
	populate(objectMap, "faultDomain", a.FaultDomain)
	populate(objectMap, "image", a.Image)
	objectMap["kind"] = HostingConfigurationKindProviderAzure
	populate(objectMap, "location", a.Location)
	populate(objectMap, "name", a.Name)
	populate(objectMap, "provider", a.Provider)
	populate(objectMap, "resourceGroup", a.ResourceGroup)
	populate(objectMap, "resourceId", a.ResourceID)
	populate(objectMap, "serviceFabricCluster", a.ServiceFabricCluster)
	populate(objectMap, "size", a.Size)
	populate(objectMap, "subscriptionId", a.SubscriptionID)
	populate(objectMap, "updateDomain", a.UpdateDomain)
	populate(objectMap, "vmId", a.VMID)
	populate(objectMap, "vmScaleSet", a.VMScaleSet)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureHostingConfiguration.
func (a *AzureHostingConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cloudService":
				err = unpopulate(val, &a.CloudService)
				delete(rawMsg, key)
		case "faultDomain":
				err = unpopulate(val, &a.FaultDomain)
				delete(rawMsg, key)
		case "image":
				err = unpopulate(val, &a.Image)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, &a.Kind)
				delete(rawMsg, key)
		case "location":
				err = unpopulate(val, &a.Location)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, &a.Name)
				delete(rawMsg, key)
		case "provider":
				err = unpopulate(val, &a.Provider)
				delete(rawMsg, key)
		case "resourceGroup":
				err = unpopulate(val, &a.ResourceGroup)
				delete(rawMsg, key)
		case "resourceId":
				err = unpopulate(val, &a.ResourceID)
				delete(rawMsg, key)
		case "serviceFabricCluster":
				err = unpopulate(val, &a.ServiceFabricCluster)
				delete(rawMsg, key)
		case "size":
				err = unpopulate(val, &a.Size)
				delete(rawMsg, key)
		case "subscriptionId":
				err = unpopulate(val, &a.SubscriptionID)
				delete(rawMsg, key)
		case "updateDomain":
				err = unpopulate(val, &a.UpdateDomain)
				delete(rawMsg, key)
		case "vmId":
				err = unpopulate(val, &a.VMID)
				delete(rawMsg, key)
		case "vmScaleSet":
				err = unpopulate(val, &a.VMScaleSet)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetProcessHostingConfiguration implements the ProcessHostingConfigurationClassification interface for type AzureProcessHostingConfiguration.
func (a *AzureProcessHostingConfiguration) GetProcessHostingConfiguration() *ProcessHostingConfiguration {
	return &ProcessHostingConfiguration{
		Provider: a.Provider,
		Kind: a.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type AzureProcessHostingConfiguration.
func (a AzureProcessHostingConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "cloudService", a.CloudService)
	objectMap["kind"] = ProcessHostingConfigurationKindProviderAzure
	populate(objectMap, "provider", a.Provider)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AzureProcessHostingConfiguration.
func (a *AzureProcessHostingConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "cloudService":
				err = unpopulate(val, &a.CloudService)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, &a.Kind)
				delete(rawMsg, key)
		case "provider":
				err = unpopulate(val, &a.Provider)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetCoreResource implements the CoreResourceClassification interface for type ClientGroup.
func (c *ClientGroup) GetCoreResource() *CoreResource {
	return &CoreResource{
		Etag: c.Etag,
		Kind: c.Kind,
		ID: c.ID,
		Type: c.Type,
		Name: c.Name,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ClientGroup.
func (c ClientGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", c.Etag)
	populate(objectMap, "id", c.ID)
	objectMap["kind"] = CoreResourceKindClientGroup
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClientGroup.
func (c *ClientGroup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
				err = unpopulate(val, &c.Etag)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, &c.ID)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, &c.Kind)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, &c.Name)
				delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, &c.Properties)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, &c.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClientGroupMemberProperties.
func (c ClientGroupMemberProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "ipAddress", c.IPAddress)
	populate(objectMap, "port", c.Port)
	populate(objectMap, "processes", c.Processes)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ClientGroupMembersCollection.
func (c ClientGroupMembersCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ClientGroupMembersCount.
func (c ClientGroupMembersCount) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accuracy", c.Accuracy)
	populate(objectMap, "count", c.Count)
	populateTimeRFC3339(objectMap, "endTime", c.EndTime)
	populate(objectMap, "groupId", c.GroupID)
	populateTimeRFC3339(objectMap, "startTime", c.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClientGroupMembersCount.
func (c *ClientGroupMembersCount) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "accuracy":
				err = unpopulate(val, &c.Accuracy)
				delete(rawMsg, key)
		case "count":
				err = unpopulate(val, &c.Count)
				delete(rawMsg, key)
		case "endTime":
				err = unpopulateTimeRFC3339(val, &c.EndTime)
				delete(rawMsg, key)
		case "groupId":
				err = unpopulate(val, &c.GroupID)
				delete(rawMsg, key)
		case "startTime":
				err = unpopulateTimeRFC3339(val, &c.StartTime)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ClientGroupProperties.
func (c ClientGroupProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientsOf", c.ClientsOf)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClientGroupProperties.
func (c *ClientGroupProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "clientsOf":
				c.ClientsOf, err = unmarshalResourceReferenceClassification(val)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetResourceReference implements the ResourceReferenceClassification interface for type ClientGroupReference.
func (c *ClientGroupReference) GetResourceReference() *ResourceReference {
	return &ResourceReference{
		ID: c.ID,
		Type: c.Type,
		Name: c.Name,
		Kind: c.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ClientGroupReference.
func (c ClientGroupReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", c.ID)
	objectMap["kind"] = ResourceReferenceKindRefClientgroup
	populate(objectMap, "name", c.Name)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ClientGroupReference.
func (c *ClientGroupReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, &c.ID)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, &c.Kind)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, &c.Name)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, &c.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetRelationship implements the RelationshipClassification interface for type Connection.
func (c *Connection) GetRelationship() *Relationship {
	return &Relationship{
		Kind: c.Kind,
		ID: c.ID,
		Type: c.Type,
		Name: c.Name,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Connection.
func (c Connection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", c.ID)
	objectMap["kind"] = RelationshipKindRelConnection
	populate(objectMap, "name", c.Name)
	populate(objectMap, "properties", c.Properties)
	populate(objectMap, "type", c.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Connection.
func (c *Connection) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, &c.ID)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, &c.Kind)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, &c.Name)
				delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, &c.Properties)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, &c.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionCollection.
func (c ConnectionCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", c.NextLink)
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ConnectionProperties.
func (c ConnectionProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "destination", c.Destination)
	populateTimeRFC3339(objectMap, "endTime", c.EndTime)
	populate(objectMap, "failureState", c.FailureState)
	populate(objectMap, "serverPort", c.ServerPort)
	populate(objectMap, "source", c.Source)
	populateTimeRFC3339(objectMap, "startTime", c.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConnectionProperties.
func (c *ConnectionProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "destination":
				c.Destination, err = unmarshalResourceReferenceClassification(val)
				delete(rawMsg, key)
		case "endTime":
				err = unpopulateTimeRFC3339(val, &c.EndTime)
				delete(rawMsg, key)
		case "failureState":
				err = unpopulate(val, &c.FailureState)
				delete(rawMsg, key)
		case "serverPort":
				err = unpopulate(val, &c.ServerPort)
				delete(rawMsg, key)
		case "source":
				c.Source, err = unmarshalResourceReferenceClassification(val)
				delete(rawMsg, key)
		case "startTime":
				err = unpopulateTimeRFC3339(val, &c.StartTime)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetCoreResource implements the CoreResourceClassification interface for type CoreResource.
func (c *CoreResource) GetCoreResource() *CoreResource { return c }

// GetHostingConfiguration implements the HostingConfigurationClassification interface for type HostingConfiguration.
func (h *HostingConfiguration) GetHostingConfiguration() *HostingConfiguration { return h }

// MarshalJSON implements the json.Marshaller interface for type Liveness.
func (l Liveness) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", l.EndTime)
	populate(objectMap, "live", l.Live)
	populateTimeRFC3339(objectMap, "startTime", l.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Liveness.
func (l *Liveness) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
				err = unpopulateTimeRFC3339(val, &l.EndTime)
				delete(rawMsg, key)
		case "live":
				err = unpopulate(val, &l.Live)
				delete(rawMsg, key)
		case "startTime":
				err = unpopulateTimeRFC3339(val, &l.StartTime)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetCoreResource implements the CoreResourceClassification interface for type Machine.
func (m *Machine) GetCoreResource() *CoreResource {
	return &CoreResource{
		Etag: m.Etag,
		Kind: m.Kind,
		ID: m.ID,
		Type: m.Type,
		Name: m.Name,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Machine.
func (m Machine) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", m.Etag)
	populate(objectMap, "id", m.ID)
	objectMap["kind"] = CoreResourceKindMachine
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Machine.
func (m *Machine) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
				err = unpopulate(val, &m.Etag)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, &m.ID)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, &m.Kind)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, &m.Name)
				delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, &m.Properties)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, &m.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MachineCollection.
func (m MachineCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// GetCoreResource implements the CoreResourceClassification interface for type MachineGroup.
func (m *MachineGroup) GetCoreResource() *CoreResource {
	return &CoreResource{
		Etag: m.Etag,
		Kind: m.Kind,
		ID: m.ID,
		Type: m.Type,
		Name: m.Name,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MachineGroup.
func (m MachineGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", m.Etag)
	populate(objectMap, "id", m.ID)
	objectMap["kind"] = CoreResourceKindMachineGroup
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MachineGroup.
func (m *MachineGroup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
				err = unpopulate(val, &m.Etag)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, &m.ID)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, &m.Kind)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, &m.Name)
				delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, &m.Properties)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, &m.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MachineGroupCollection.
func (m MachineGroupCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", m.NextLink)
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// GetMapRequest implements the MapRequestClassification interface for type MachineGroupMapRequest.
func (m *MachineGroupMapRequest) GetMapRequest() *MapRequest {
	return &MapRequest{
		StartTime: m.StartTime,
		EndTime: m.EndTime,
		Kind: m.Kind,
	}
}

// GetMultipleMachinesMapRequest implements the MultipleMachinesMapRequestClassification interface for type MachineGroupMapRequest.
func (m *MachineGroupMapRequest) GetMultipleMachinesMapRequest() *MultipleMachinesMapRequest {
	return &MultipleMachinesMapRequest{
		FilterProcesses: m.FilterProcesses,
		StartTime: m.StartTime,
		EndTime: m.EndTime,
		Kind: m.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MachineGroupMapRequest.
func (m MachineGroupMapRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", m.EndTime)
	populate(objectMap, "filterProcesses", m.FilterProcesses)
	objectMap["kind"] = MapRequestKindMapMachineGroupDependency
	populate(objectMap, "machineGroupId", m.MachineGroupID)
	populateTimeRFC3339(objectMap, "startTime", m.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MachineGroupMapRequest.
func (m *MachineGroupMapRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
				err = unpopulateTimeRFC3339(val, &m.EndTime)
				delete(rawMsg, key)
		case "filterProcesses":
				err = unpopulate(val, &m.FilterProcesses)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, &m.Kind)
				delete(rawMsg, key)
		case "machineGroupId":
				err = unpopulate(val, &m.MachineGroupID)
				delete(rawMsg, key)
		case "startTime":
				err = unpopulateTimeRFC3339(val, &m.StartTime)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MachineGroupProperties.
func (m MachineGroupProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "count", m.Count)
	populate(objectMap, "displayName", m.DisplayName)
	populate(objectMap, "groupType", m.GroupType)
	populate(objectMap, "machines", m.Machines)
	return json.Marshal(objectMap)
}

// GetMapRequest implements the MapRequestClassification interface for type MachineListMapRequest.
func (m *MachineListMapRequest) GetMapRequest() *MapRequest {
	return &MapRequest{
		StartTime: m.StartTime,
		EndTime: m.EndTime,
		Kind: m.Kind,
	}
}

// GetMultipleMachinesMapRequest implements the MultipleMachinesMapRequestClassification interface for type MachineListMapRequest.
func (m *MachineListMapRequest) GetMultipleMachinesMapRequest() *MultipleMachinesMapRequest {
	return &MultipleMachinesMapRequest{
		FilterProcesses: m.FilterProcesses,
		StartTime: m.StartTime,
		EndTime: m.EndTime,
		Kind: m.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MachineListMapRequest.
func (m MachineListMapRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", m.EndTime)
	populate(objectMap, "filterProcesses", m.FilterProcesses)
	objectMap["kind"] = MapRequestKindMapMachineListDependency
	populate(objectMap, "machineIds", m.MachineIDs)
	populateTimeRFC3339(objectMap, "startTime", m.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MachineListMapRequest.
func (m *MachineListMapRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
				err = unpopulateTimeRFC3339(val, &m.EndTime)
				delete(rawMsg, key)
		case "filterProcesses":
				err = unpopulate(val, &m.FilterProcesses)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, &m.Kind)
				delete(rawMsg, key)
		case "machineIds":
				err = unpopulate(val, &m.MachineIDs)
				delete(rawMsg, key)
		case "startTime":
				err = unpopulateTimeRFC3339(val, &m.StartTime)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MachineProperties.
func (m MachineProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "agent", m.Agent)
	populateTimeRFC3339(objectMap, "bootTime", m.BootTime)
	populate(objectMap, "computerName", m.ComputerName)
	populate(objectMap, "displayName", m.DisplayName)
	populate(objectMap, "fullyQualifiedDomainName", m.FullyQualifiedDomainName)
	populate(objectMap, "hosting", m.Hosting)
	populate(objectMap, "hypervisor", m.Hypervisor)
	populate(objectMap, "monitoringState", m.MonitoringState)
	populate(objectMap, "networking", m.Networking)
	populate(objectMap, "operatingSystem", m.OperatingSystem)
	populate(objectMap, "resources", m.Resources)
	populateTimeRFC3339(objectMap, "timestamp", m.Timestamp)
	populate(objectMap, "timezone", m.Timezone)
	populate(objectMap, "virtualMachine", m.VirtualMachine)
	populate(objectMap, "virtualizationState", m.VirtualizationState)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MachineProperties.
func (m *MachineProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "agent":
				err = unpopulate(val, &m.Agent)
				delete(rawMsg, key)
		case "bootTime":
				err = unpopulateTimeRFC3339(val, &m.BootTime)
				delete(rawMsg, key)
		case "computerName":
				err = unpopulate(val, &m.ComputerName)
				delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, &m.DisplayName)
				delete(rawMsg, key)
		case "fullyQualifiedDomainName":
				err = unpopulate(val, &m.FullyQualifiedDomainName)
				delete(rawMsg, key)
		case "hosting":
				m.Hosting, err = unmarshalHostingConfigurationClassification(val)
				delete(rawMsg, key)
		case "hypervisor":
				err = unpopulate(val, &m.Hypervisor)
				delete(rawMsg, key)
		case "monitoringState":
				err = unpopulate(val, &m.MonitoringState)
				delete(rawMsg, key)
		case "networking":
				err = unpopulate(val, &m.Networking)
				delete(rawMsg, key)
		case "operatingSystem":
				err = unpopulate(val, &m.OperatingSystem)
				delete(rawMsg, key)
		case "resources":
				err = unpopulate(val, &m.Resources)
				delete(rawMsg, key)
		case "timestamp":
				err = unpopulateTimeRFC3339(val, &m.Timestamp)
				delete(rawMsg, key)
		case "timezone":
				err = unpopulate(val, &m.Timezone)
				delete(rawMsg, key)
		case "virtualMachine":
				err = unpopulate(val, &m.VirtualMachine)
				delete(rawMsg, key)
		case "virtualizationState":
				err = unpopulate(val, &m.VirtualizationState)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetResourceReference implements the ResourceReferenceClassification interface for type MachineReference.
func (m *MachineReference) GetResourceReference() *ResourceReference {
	return &ResourceReference{
		ID: m.ID,
		Type: m.Type,
		Name: m.Name,
		Kind: m.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MachineReference.
func (m MachineReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	objectMap["kind"] = ResourceReferenceKindRefMachine
	populate(objectMap, "name", m.Name)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MachineReference.
func (m *MachineReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, &m.ID)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, &m.Kind)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, &m.Name)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, &m.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetResourceReference implements the ResourceReferenceClassification interface for type MachineReferenceWithHints.
func (m *MachineReferenceWithHints) GetResourceReference() *ResourceReference {
	return &ResourceReference{
		ID: m.ID,
		Type: m.Type,
		Name: m.Name,
		Kind: m.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type MachineReferenceWithHints.
func (m MachineReferenceWithHints) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", m.ID)
	objectMap["kind"] = ResourceReferenceKindRefMachinewithhints
	populate(objectMap, "name", m.Name)
	populate(objectMap, "properties", m.Properties)
	populate(objectMap, "type", m.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MachineReferenceWithHints.
func (m *MachineReferenceWithHints) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, &m.ID)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, &m.Kind)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, &m.Name)
				delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, &m.Properties)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, &m.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MachinesSummaryProperties.
func (m MachinesSummaryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", m.EndTime)
	populate(objectMap, "live", m.Live)
	populate(objectMap, "os", m.OS)
	populateTimeRFC3339(objectMap, "startTime", m.StartTime)
	populate(objectMap, "total", m.Total)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MachinesSummaryProperties.
func (m *MachinesSummaryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
				err = unpopulateTimeRFC3339(val, &m.EndTime)
				delete(rawMsg, key)
		case "live":
				err = unpopulate(val, &m.Live)
				delete(rawMsg, key)
		case "os":
				err = unpopulate(val, &m.OS)
				delete(rawMsg, key)
		case "startTime":
				err = unpopulateTimeRFC3339(val, &m.StartTime)
				delete(rawMsg, key)
		case "total":
				err = unpopulate(val, &m.Total)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MapEdges.
func (m MapEdges) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "acceptors", m.Acceptors)
	populate(objectMap, "connections", m.Connections)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type MapNodes.
func (m MapNodes) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "clientGroups", m.ClientGroups)
	populate(objectMap, "machines", m.Machines)
	populate(objectMap, "ports", m.Ports)
	populate(objectMap, "processes", m.Processes)
	return json.Marshal(objectMap)
}

// GetMapRequest implements the MapRequestClassification interface for type MapRequest.
func (m *MapRequest) GetMapRequest() *MapRequest { return m }

// MarshalJSON implements the json.Marshaller interface for type MapRequest.
func (m MapRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", m.EndTime)
	objectMap["kind"] = m.Kind
	populateTimeRFC3339(objectMap, "startTime", m.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MapRequest.
func (m *MapRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
				err = unpopulateTimeRFC3339(val, &m.EndTime)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, &m.Kind)
				delete(rawMsg, key)
		case "startTime":
				err = unpopulateTimeRFC3339(val, &m.StartTime)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type MapResponse.
func (m MapResponse) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", m.EndTime)
	populate(objectMap, "map", m.Map)
	populateTimeRFC3339(objectMap, "startTime", m.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MapResponse.
func (m *MapResponse) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
				err = unpopulateTimeRFC3339(val, &m.EndTime)
				delete(rawMsg, key)
		case "map":
				err = unpopulate(val, &m.Map)
				delete(rawMsg, key)
		case "startTime":
				err = unpopulateTimeRFC3339(val, &m.StartTime)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetMapRequest implements the MapRequestClassification interface for type MultipleMachinesMapRequest.
func (m *MultipleMachinesMapRequest) GetMapRequest() *MapRequest {
	return &MapRequest{
		StartTime: m.StartTime,
		EndTime: m.EndTime,
		Kind: m.Kind,
	}
}

// GetMultipleMachinesMapRequest implements the MultipleMachinesMapRequestClassification interface for type MultipleMachinesMapRequest.
func (m *MultipleMachinesMapRequest) GetMultipleMachinesMapRequest() *MultipleMachinesMapRequest { return m }

// MarshalJSON implements the json.Marshaller interface for type MultipleMachinesMapRequest.
func (m MultipleMachinesMapRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", m.EndTime)
	populate(objectMap, "filterProcesses", m.FilterProcesses)
	objectMap["kind"] = "MultipleMachinesMapRequest"
	populateTimeRFC3339(objectMap, "startTime", m.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MultipleMachinesMapRequest.
func (m *MultipleMachinesMapRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
				err = unpopulateTimeRFC3339(val, &m.EndTime)
				delete(rawMsg, key)
		case "filterProcesses":
				err = unpopulate(val, &m.FilterProcesses)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, &m.Kind)
				delete(rawMsg, key)
		case "startTime":
				err = unpopulateTimeRFC3339(val, &m.StartTime)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type NetworkConfiguration.
func (n NetworkConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dnsNames", n.DNSNames)
	populate(objectMap, "defaultIpv4Gateways", n.DefaultIPv4Gateways)
	populate(objectMap, "ipv4Interfaces", n.IPv4Interfaces)
	populate(objectMap, "ipv6Interfaces", n.IPv6Interfaces)
	populate(objectMap, "macAddresses", n.MacAddresses)
	return json.Marshal(objectMap)
}

// GetCoreResource implements the CoreResourceClassification interface for type Port.
func (p *Port) GetCoreResource() *CoreResource {
	return &CoreResource{
		Etag: p.Etag,
		Kind: p.Kind,
		ID: p.ID,
		Type: p.Type,
		Name: p.Name,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Port.
func (p Port) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", p.Etag)
	populate(objectMap, "id", p.ID)
	objectMap["kind"] = CoreResourceKindPort
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Port.
func (p *Port) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
				err = unpopulate(val, &p.Etag)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, &p.ID)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, &p.Kind)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, &p.Name)
				delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, &p.Properties)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, &p.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type PortCollection.
func (p PortCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type PortProperties.
func (p PortProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "ipAddress", p.IPAddress)
	populate(objectMap, "machine", p.Machine)
	populate(objectMap, "monitoringState", p.MonitoringState)
	populate(objectMap, "portNumber", p.PortNumber)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PortProperties.
func (p *PortProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "displayName":
				err = unpopulate(val, &p.DisplayName)
				delete(rawMsg, key)
		case "ipAddress":
				err = unpopulate(val, &p.IPAddress)
				delete(rawMsg, key)
		case "machine":
				p.Machine, err = unmarshalResourceReferenceClassification(val)
				delete(rawMsg, key)
		case "monitoringState":
				err = unpopulate(val, &p.MonitoringState)
				delete(rawMsg, key)
		case "portNumber":
				err = unpopulate(val, &p.PortNumber)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetResourceReference implements the ResourceReferenceClassification interface for type PortReference.
func (p *PortReference) GetResourceReference() *ResourceReference {
	return &ResourceReference{
		ID: p.ID,
		Type: p.Type,
		Name: p.Name,
		Kind: p.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type PortReference.
func (p PortReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", p.ID)
	objectMap["kind"] = ResourceReferenceKindRefPort
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type PortReference.
func (p *PortReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, &p.ID)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, &p.Kind)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, &p.Name)
				delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, &p.Properties)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, &p.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetCoreResource implements the CoreResourceClassification interface for type Process.
func (p *Process) GetCoreResource() *CoreResource {
	return &CoreResource{
		Etag: p.Etag,
		Kind: p.Kind,
		ID: p.ID,
		Type: p.Type,
		Name: p.Name,
	}
}

// MarshalJSON implements the json.Marshaller interface for type Process.
func (p Process) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "etag", p.Etag)
	populate(objectMap, "id", p.ID)
	objectMap["kind"] = CoreResourceKindProcess
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Process.
func (p *Process) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
				err = unpopulate(val, &p.Etag)
				delete(rawMsg, key)
		case "id":
				err = unpopulate(val, &p.ID)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, &p.Kind)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, &p.Name)
				delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, &p.Properties)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, &p.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type ProcessCollection.
func (p ProcessCollection) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", p.NextLink)
	populate(objectMap, "value", p.Value)
	return json.Marshal(objectMap)
}

// MarshalJSON implements the json.Marshaller interface for type ProcessDetails.
func (p ProcessDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "commandLine", p.CommandLine)
	populate(objectMap, "companyName", p.CompanyName)
	populate(objectMap, "description", p.Description)
	populate(objectMap, "executablePath", p.ExecutablePath)
	populate(objectMap, "fileVersion", p.FileVersion)
	populate(objectMap, "firstPid", p.FirstPid)
	populate(objectMap, "internalName", p.InternalName)
	populate(objectMap, "persistentKey", p.PersistentKey)
	populate(objectMap, "poolId", p.PoolID)
	populate(objectMap, "productName", p.ProductName)
	populate(objectMap, "productVersion", p.ProductVersion)
	populate(objectMap, "services", p.Services)
	populate(objectMap, "workingDirectory", p.WorkingDirectory)
	populate(objectMap, "zoneName", p.ZoneName)
	return json.Marshal(objectMap)
}

// GetProcessHostingConfiguration implements the ProcessHostingConfigurationClassification interface for type ProcessHostingConfiguration.
func (p *ProcessHostingConfiguration) GetProcessHostingConfiguration() *ProcessHostingConfiguration { return p }

// MarshalJSON implements the json.Marshaller interface for type ProcessProperties.
func (p ProcessProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "acceptorOf", p.AcceptorOf)
	populate(objectMap, "clientOf", p.ClientOf)
	populate(objectMap, "details", p.Details)
	populate(objectMap, "displayName", p.DisplayName)
	populate(objectMap, "executableName", p.ExecutableName)
	populate(objectMap, "group", p.Group)
	populate(objectMap, "hosting", p.Hosting)
	populate(objectMap, "machine", p.Machine)
	populate(objectMap, "monitoringState", p.MonitoringState)
	populate(objectMap, "role", p.Role)
	populateTimeRFC3339(objectMap, "startTime", p.StartTime)
	populateTimeRFC3339(objectMap, "timestamp", p.Timestamp)
	populate(objectMap, "user", p.User)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProcessProperties.
func (p *ProcessProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "acceptorOf":
				p.AcceptorOf, err = unmarshalResourceReferenceClassification(val)
				delete(rawMsg, key)
		case "clientOf":
				p.ClientOf, err = unmarshalResourceReferenceClassification(val)
				delete(rawMsg, key)
		case "details":
				err = unpopulate(val, &p.Details)
				delete(rawMsg, key)
		case "displayName":
				err = unpopulate(val, &p.DisplayName)
				delete(rawMsg, key)
		case "executableName":
				err = unpopulate(val, &p.ExecutableName)
				delete(rawMsg, key)
		case "group":
				err = unpopulate(val, &p.Group)
				delete(rawMsg, key)
		case "hosting":
				p.Hosting, err = unmarshalProcessHostingConfigurationClassification(val)
				delete(rawMsg, key)
		case "machine":
				p.Machine, err = unmarshalResourceReferenceClassification(val)
				delete(rawMsg, key)
		case "monitoringState":
				err = unpopulate(val, &p.MonitoringState)
				delete(rawMsg, key)
		case "role":
				err = unpopulate(val, &p.Role)
				delete(rawMsg, key)
		case "startTime":
				err = unpopulateTimeRFC3339(val, &p.StartTime)
				delete(rawMsg, key)
		case "timestamp":
				err = unpopulateTimeRFC3339(val, &p.Timestamp)
				delete(rawMsg, key)
		case "user":
				err = unpopulate(val, &p.User)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetResourceReference implements the ResourceReferenceClassification interface for type ProcessReference.
func (p *ProcessReference) GetResourceReference() *ResourceReference {
	return &ResourceReference{
		ID: p.ID,
		Type: p.Type,
		Name: p.Name,
		Kind: p.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type ProcessReference.
func (p ProcessReference) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "id", p.ID)
	objectMap["kind"] = ResourceReferenceKindRefProcess
	populate(objectMap, "name", p.Name)
	populate(objectMap, "properties", p.Properties)
	populate(objectMap, "type", p.Type)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ProcessReference.
func (p *ProcessReference) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
				err = unpopulate(val, &p.ID)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, &p.Kind)
				delete(rawMsg, key)
		case "name":
				err = unpopulate(val, &p.Name)
				delete(rawMsg, key)
		case "properties":
				err = unpopulate(val, &p.Properties)
				delete(rawMsg, key)
		case "type":
				err = unpopulate(val, &p.Type)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetRelationship implements the RelationshipClassification interface for type Relationship.
func (r *Relationship) GetRelationship() *Relationship { return r }

// MarshalJSON implements the json.Marshaller interface for type RelationshipProperties.
func (r RelationshipProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "destination", r.Destination)
	populateTimeRFC3339(objectMap, "endTime", r.EndTime)
	populate(objectMap, "source", r.Source)
	populateTimeRFC3339(objectMap, "startTime", r.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type RelationshipProperties.
func (r *RelationshipProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "destination":
				r.Destination, err = unmarshalResourceReferenceClassification(val)
				delete(rawMsg, key)
		case "endTime":
				err = unpopulateTimeRFC3339(val, &r.EndTime)
				delete(rawMsg, key)
		case "source":
				r.Source, err = unmarshalResourceReferenceClassification(val)
				delete(rawMsg, key)
		case "startTime":
				err = unpopulateTimeRFC3339(val, &r.StartTime)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// GetResourceReference implements the ResourceReferenceClassification interface for type ResourceReference.
func (r *ResourceReference) GetResourceReference() *ResourceReference { return r }

// GetMapRequest implements the MapRequestClassification interface for type SingleMachineDependencyMapRequest.
func (s *SingleMachineDependencyMapRequest) GetMapRequest() *MapRequest {
	return &MapRequest{
		StartTime: s.StartTime,
		EndTime: s.EndTime,
		Kind: s.Kind,
	}
}

// MarshalJSON implements the json.Marshaller interface for type SingleMachineDependencyMapRequest.
func (s SingleMachineDependencyMapRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", s.EndTime)
	objectMap["kind"] = MapRequestKindMapSingleMachineDependency
	populate(objectMap, "machineId", s.MachineID)
	populateTimeRFC3339(objectMap, "startTime", s.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SingleMachineDependencyMapRequest.
func (s *SingleMachineDependencyMapRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
				err = unpopulateTimeRFC3339(val, &s.EndTime)
				delete(rawMsg, key)
		case "kind":
				err = unpopulate(val, &s.Kind)
				delete(rawMsg, key)
		case "machineId":
				err = unpopulate(val, &s.MachineID)
				delete(rawMsg, key)
		case "startTime":
				err = unpopulateTimeRFC3339(val, &s.StartTime)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MarshalJSON implements the json.Marshaller interface for type SummaryProperties.
func (s SummaryProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populateTimeRFC3339(objectMap, "endTime", s.EndTime)
	populateTimeRFC3339(objectMap, "startTime", s.StartTime)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SummaryProperties.
func (s *SummaryProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
				err = unpopulateTimeRFC3339(val, &s.EndTime)
				delete(rawMsg, key)
		case "startTime":
				err = unpopulateTimeRFC3339(val, &s.StartTime)
				delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}

