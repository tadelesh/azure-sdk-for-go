//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armeventgrid

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// DomainTopicsClientListByDomainPager provides operations for iterating over paged responses.
type DomainTopicsClientListByDomainPager struct {
	client    *DomainTopicsClient
	current   DomainTopicsClientListByDomainResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DomainTopicsClientListByDomainResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DomainTopicsClientListByDomainPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DomainTopicsListResult.NextLink == nil || len(*p.current.DomainTopicsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DomainTopicsClientListByDomainPager) NextPage(ctx context.Context) (DomainTopicsClientListByDomainResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DomainTopicsClientListByDomainResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DomainTopicsClientListByDomainResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DomainTopicsClientListByDomainResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DomainTopicsClientListByDomainResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByDomainHandleResponse(resp)
	if err != nil {
		return DomainTopicsClientListByDomainResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DomainsClientListByResourceGroupPager provides operations for iterating over paged responses.
type DomainsClientListByResourceGroupPager struct {
	client    *DomainsClient
	current   DomainsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DomainsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DomainsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DomainsListResult.NextLink == nil || len(*p.current.DomainsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DomainsClientListByResourceGroupPager) NextPage(ctx context.Context) (DomainsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DomainsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DomainsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DomainsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DomainsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return DomainsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DomainsClientListBySubscriptionPager provides operations for iterating over paged responses.
type DomainsClientListBySubscriptionPager struct {
	client    *DomainsClient
	current   DomainsClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DomainsClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DomainsClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DomainsListResult.NextLink == nil || len(*p.current.DomainsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DomainsClientListBySubscriptionPager) NextPage(ctx context.Context) (DomainsClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DomainsClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DomainsClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DomainsClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DomainsClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return DomainsClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// EventSubscriptionsClientListByDomainTopicPager provides operations for iterating over paged responses.
type EventSubscriptionsClientListByDomainTopicPager struct {
	client    *EventSubscriptionsClient
	current   EventSubscriptionsClientListByDomainTopicResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EventSubscriptionsClientListByDomainTopicResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *EventSubscriptionsClientListByDomainTopicPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EventSubscriptionsListResult.NextLink == nil || len(*p.current.EventSubscriptionsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *EventSubscriptionsClientListByDomainTopicPager) NextPage(ctx context.Context) (EventSubscriptionsClientListByDomainTopicResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return EventSubscriptionsClientListByDomainTopicResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return EventSubscriptionsClientListByDomainTopicResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return EventSubscriptionsClientListByDomainTopicResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return EventSubscriptionsClientListByDomainTopicResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByDomainTopicHandleResponse(resp)
	if err != nil {
		return EventSubscriptionsClientListByDomainTopicResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// EventSubscriptionsClientListByResourcePager provides operations for iterating over paged responses.
type EventSubscriptionsClientListByResourcePager struct {
	client    *EventSubscriptionsClient
	current   EventSubscriptionsClientListByResourceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EventSubscriptionsClientListByResourceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *EventSubscriptionsClientListByResourcePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EventSubscriptionsListResult.NextLink == nil || len(*p.current.EventSubscriptionsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *EventSubscriptionsClientListByResourcePager) NextPage(ctx context.Context) (EventSubscriptionsClientListByResourceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return EventSubscriptionsClientListByResourceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return EventSubscriptionsClientListByResourceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return EventSubscriptionsClientListByResourceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return EventSubscriptionsClientListByResourceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceHandleResponse(resp)
	if err != nil {
		return EventSubscriptionsClientListByResourceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// EventSubscriptionsClientListGlobalByResourceGroupForTopicTypePager provides operations for iterating over paged responses.
type EventSubscriptionsClientListGlobalByResourceGroupForTopicTypePager struct {
	client    *EventSubscriptionsClient
	current   EventSubscriptionsClientListGlobalByResourceGroupForTopicTypeResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EventSubscriptionsClientListGlobalByResourceGroupForTopicTypeResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *EventSubscriptionsClientListGlobalByResourceGroupForTopicTypePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EventSubscriptionsListResult.NextLink == nil || len(*p.current.EventSubscriptionsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *EventSubscriptionsClientListGlobalByResourceGroupForTopicTypePager) NextPage(ctx context.Context) (EventSubscriptionsClientListGlobalByResourceGroupForTopicTypeResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return EventSubscriptionsClientListGlobalByResourceGroupForTopicTypeResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return EventSubscriptionsClientListGlobalByResourceGroupForTopicTypeResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return EventSubscriptionsClientListGlobalByResourceGroupForTopicTypeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return EventSubscriptionsClientListGlobalByResourceGroupForTopicTypeResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listGlobalByResourceGroupForTopicTypeHandleResponse(resp)
	if err != nil {
		return EventSubscriptionsClientListGlobalByResourceGroupForTopicTypeResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// EventSubscriptionsClientListGlobalByResourceGroupPager provides operations for iterating over paged responses.
type EventSubscriptionsClientListGlobalByResourceGroupPager struct {
	client    *EventSubscriptionsClient
	current   EventSubscriptionsClientListGlobalByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EventSubscriptionsClientListGlobalByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *EventSubscriptionsClientListGlobalByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EventSubscriptionsListResult.NextLink == nil || len(*p.current.EventSubscriptionsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *EventSubscriptionsClientListGlobalByResourceGroupPager) NextPage(ctx context.Context) (EventSubscriptionsClientListGlobalByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return EventSubscriptionsClientListGlobalByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return EventSubscriptionsClientListGlobalByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return EventSubscriptionsClientListGlobalByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return EventSubscriptionsClientListGlobalByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listGlobalByResourceGroupHandleResponse(resp)
	if err != nil {
		return EventSubscriptionsClientListGlobalByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// EventSubscriptionsClientListGlobalBySubscriptionForTopicTypePager provides operations for iterating over paged responses.
type EventSubscriptionsClientListGlobalBySubscriptionForTopicTypePager struct {
	client    *EventSubscriptionsClient
	current   EventSubscriptionsClientListGlobalBySubscriptionForTopicTypeResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EventSubscriptionsClientListGlobalBySubscriptionForTopicTypeResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *EventSubscriptionsClientListGlobalBySubscriptionForTopicTypePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EventSubscriptionsListResult.NextLink == nil || len(*p.current.EventSubscriptionsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *EventSubscriptionsClientListGlobalBySubscriptionForTopicTypePager) NextPage(ctx context.Context) (EventSubscriptionsClientListGlobalBySubscriptionForTopicTypeResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return EventSubscriptionsClientListGlobalBySubscriptionForTopicTypeResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return EventSubscriptionsClientListGlobalBySubscriptionForTopicTypeResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return EventSubscriptionsClientListGlobalBySubscriptionForTopicTypeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return EventSubscriptionsClientListGlobalBySubscriptionForTopicTypeResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listGlobalBySubscriptionForTopicTypeHandleResponse(resp)
	if err != nil {
		return EventSubscriptionsClientListGlobalBySubscriptionForTopicTypeResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// EventSubscriptionsClientListGlobalBySubscriptionPager provides operations for iterating over paged responses.
type EventSubscriptionsClientListGlobalBySubscriptionPager struct {
	client    *EventSubscriptionsClient
	current   EventSubscriptionsClientListGlobalBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EventSubscriptionsClientListGlobalBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *EventSubscriptionsClientListGlobalBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EventSubscriptionsListResult.NextLink == nil || len(*p.current.EventSubscriptionsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *EventSubscriptionsClientListGlobalBySubscriptionPager) NextPage(ctx context.Context) (EventSubscriptionsClientListGlobalBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return EventSubscriptionsClientListGlobalBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return EventSubscriptionsClientListGlobalBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return EventSubscriptionsClientListGlobalBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return EventSubscriptionsClientListGlobalBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listGlobalBySubscriptionHandleResponse(resp)
	if err != nil {
		return EventSubscriptionsClientListGlobalBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// EventSubscriptionsClientListRegionalByResourceGroupForTopicTypePager provides operations for iterating over paged responses.
type EventSubscriptionsClientListRegionalByResourceGroupForTopicTypePager struct {
	client    *EventSubscriptionsClient
	current   EventSubscriptionsClientListRegionalByResourceGroupForTopicTypeResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EventSubscriptionsClientListRegionalByResourceGroupForTopicTypeResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *EventSubscriptionsClientListRegionalByResourceGroupForTopicTypePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EventSubscriptionsListResult.NextLink == nil || len(*p.current.EventSubscriptionsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *EventSubscriptionsClientListRegionalByResourceGroupForTopicTypePager) NextPage(ctx context.Context) (EventSubscriptionsClientListRegionalByResourceGroupForTopicTypeResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return EventSubscriptionsClientListRegionalByResourceGroupForTopicTypeResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return EventSubscriptionsClientListRegionalByResourceGroupForTopicTypeResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return EventSubscriptionsClientListRegionalByResourceGroupForTopicTypeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return EventSubscriptionsClientListRegionalByResourceGroupForTopicTypeResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listRegionalByResourceGroupForTopicTypeHandleResponse(resp)
	if err != nil {
		return EventSubscriptionsClientListRegionalByResourceGroupForTopicTypeResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// EventSubscriptionsClientListRegionalByResourceGroupPager provides operations for iterating over paged responses.
type EventSubscriptionsClientListRegionalByResourceGroupPager struct {
	client    *EventSubscriptionsClient
	current   EventSubscriptionsClientListRegionalByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EventSubscriptionsClientListRegionalByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *EventSubscriptionsClientListRegionalByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EventSubscriptionsListResult.NextLink == nil || len(*p.current.EventSubscriptionsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *EventSubscriptionsClientListRegionalByResourceGroupPager) NextPage(ctx context.Context) (EventSubscriptionsClientListRegionalByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return EventSubscriptionsClientListRegionalByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return EventSubscriptionsClientListRegionalByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return EventSubscriptionsClientListRegionalByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return EventSubscriptionsClientListRegionalByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listRegionalByResourceGroupHandleResponse(resp)
	if err != nil {
		return EventSubscriptionsClientListRegionalByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// EventSubscriptionsClientListRegionalBySubscriptionForTopicTypePager provides operations for iterating over paged responses.
type EventSubscriptionsClientListRegionalBySubscriptionForTopicTypePager struct {
	client    *EventSubscriptionsClient
	current   EventSubscriptionsClientListRegionalBySubscriptionForTopicTypeResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EventSubscriptionsClientListRegionalBySubscriptionForTopicTypeResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *EventSubscriptionsClientListRegionalBySubscriptionForTopicTypePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EventSubscriptionsListResult.NextLink == nil || len(*p.current.EventSubscriptionsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *EventSubscriptionsClientListRegionalBySubscriptionForTopicTypePager) NextPage(ctx context.Context) (EventSubscriptionsClientListRegionalBySubscriptionForTopicTypeResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return EventSubscriptionsClientListRegionalBySubscriptionForTopicTypeResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return EventSubscriptionsClientListRegionalBySubscriptionForTopicTypeResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return EventSubscriptionsClientListRegionalBySubscriptionForTopicTypeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return EventSubscriptionsClientListRegionalBySubscriptionForTopicTypeResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listRegionalBySubscriptionForTopicTypeHandleResponse(resp)
	if err != nil {
		return EventSubscriptionsClientListRegionalBySubscriptionForTopicTypeResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// EventSubscriptionsClientListRegionalBySubscriptionPager provides operations for iterating over paged responses.
type EventSubscriptionsClientListRegionalBySubscriptionPager struct {
	client    *EventSubscriptionsClient
	current   EventSubscriptionsClientListRegionalBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EventSubscriptionsClientListRegionalBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *EventSubscriptionsClientListRegionalBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EventSubscriptionsListResult.NextLink == nil || len(*p.current.EventSubscriptionsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *EventSubscriptionsClientListRegionalBySubscriptionPager) NextPage(ctx context.Context) (EventSubscriptionsClientListRegionalBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return EventSubscriptionsClientListRegionalBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return EventSubscriptionsClientListRegionalBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return EventSubscriptionsClientListRegionalBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return EventSubscriptionsClientListRegionalBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listRegionalBySubscriptionHandleResponse(resp)
	if err != nil {
		return EventSubscriptionsClientListRegionalBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *OperationsClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *OperationsClientListPager) NextPage(ctx context.Context) (OperationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return OperationsClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return OperationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PrivateEndpointConnectionsClientListByResourcePager provides operations for iterating over paged responses.
type PrivateEndpointConnectionsClientListByResourcePager struct {
	client    *PrivateEndpointConnectionsClient
	current   PrivateEndpointConnectionsClientListByResourceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateEndpointConnectionsClientListByResourceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PrivateEndpointConnectionsClientListByResourcePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointConnectionListResult.NextLink == nil || len(*p.current.PrivateEndpointConnectionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PrivateEndpointConnectionsClientListByResourcePager) NextPage(ctx context.Context) (PrivateEndpointConnectionsClientListByResourceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PrivateEndpointConnectionsClientListByResourceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PrivateEndpointConnectionsClientListByResourceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PrivateEndpointConnectionsClientListByResourceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PrivateEndpointConnectionsClientListByResourceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceHandleResponse(resp)
	if err != nil {
		return PrivateEndpointConnectionsClientListByResourceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PrivateLinkResourcesClientListByResourcePager provides operations for iterating over paged responses.
type PrivateLinkResourcesClientListByResourcePager struct {
	client    *PrivateLinkResourcesClient
	current   PrivateLinkResourcesClientListByResourceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateLinkResourcesClientListByResourceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PrivateLinkResourcesClientListByResourcePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateLinkResourcesListResult.NextLink == nil || len(*p.current.PrivateLinkResourcesListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PrivateLinkResourcesClientListByResourcePager) NextPage(ctx context.Context) (PrivateLinkResourcesClientListByResourceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PrivateLinkResourcesClientListByResourceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PrivateLinkResourcesClientListByResourceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PrivateLinkResourcesClientListByResourceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PrivateLinkResourcesClientListByResourceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceHandleResponse(resp)
	if err != nil {
		return PrivateLinkResourcesClientListByResourceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SystemTopicEventSubscriptionsClientListBySystemTopicPager provides operations for iterating over paged responses.
type SystemTopicEventSubscriptionsClientListBySystemTopicPager struct {
	client    *SystemTopicEventSubscriptionsClient
	current   SystemTopicEventSubscriptionsClientListBySystemTopicResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SystemTopicEventSubscriptionsClientListBySystemTopicResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SystemTopicEventSubscriptionsClientListBySystemTopicPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EventSubscriptionsListResult.NextLink == nil || len(*p.current.EventSubscriptionsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SystemTopicEventSubscriptionsClientListBySystemTopicPager) NextPage(ctx context.Context) (SystemTopicEventSubscriptionsClientListBySystemTopicResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SystemTopicEventSubscriptionsClientListBySystemTopicResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SystemTopicEventSubscriptionsClientListBySystemTopicResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SystemTopicEventSubscriptionsClientListBySystemTopicResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SystemTopicEventSubscriptionsClientListBySystemTopicResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySystemTopicHandleResponse(resp)
	if err != nil {
		return SystemTopicEventSubscriptionsClientListBySystemTopicResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SystemTopicsClientListByResourceGroupPager provides operations for iterating over paged responses.
type SystemTopicsClientListByResourceGroupPager struct {
	client    *SystemTopicsClient
	current   SystemTopicsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SystemTopicsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SystemTopicsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SystemTopicsListResult.NextLink == nil || len(*p.current.SystemTopicsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SystemTopicsClientListByResourceGroupPager) NextPage(ctx context.Context) (SystemTopicsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SystemTopicsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SystemTopicsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SystemTopicsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SystemTopicsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return SystemTopicsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SystemTopicsClientListBySubscriptionPager provides operations for iterating over paged responses.
type SystemTopicsClientListBySubscriptionPager struct {
	client    *SystemTopicsClient
	current   SystemTopicsClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SystemTopicsClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SystemTopicsClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SystemTopicsListResult.NextLink == nil || len(*p.current.SystemTopicsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SystemTopicsClientListBySubscriptionPager) NextPage(ctx context.Context) (SystemTopicsClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SystemTopicsClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SystemTopicsClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SystemTopicsClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SystemTopicsClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return SystemTopicsClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TopicTypesClientListEventTypesPager provides operations for iterating over paged responses.
type TopicTypesClientListEventTypesPager struct {
	client    *TopicTypesClient
	current   TopicTypesClientListEventTypesResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TopicTypesClientListEventTypesPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *TopicTypesClientListEventTypesPager) NextPage(ctx context.Context) (TopicTypesClientListEventTypesResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return TopicTypesClientListEventTypesResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TopicTypesClientListEventTypesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TopicTypesClientListEventTypesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TopicTypesClientListEventTypesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listEventTypesHandleResponse(resp)
	if err != nil {
		return TopicTypesClientListEventTypesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TopicTypesClientListPager provides operations for iterating over paged responses.
type TopicTypesClientListPager struct {
	client    *TopicTypesClient
	current   TopicTypesClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TopicTypesClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *TopicTypesClientListPager) NextPage(ctx context.Context) (TopicTypesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return TopicTypesClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TopicTypesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TopicTypesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TopicTypesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return TopicTypesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TopicsClientListByResourceGroupPager provides operations for iterating over paged responses.
type TopicsClientListByResourceGroupPager struct {
	client    *TopicsClient
	current   TopicsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TopicsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TopicsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TopicsListResult.NextLink == nil || len(*p.current.TopicsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *TopicsClientListByResourceGroupPager) NextPage(ctx context.Context) (TopicsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return TopicsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TopicsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TopicsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TopicsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return TopicsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TopicsClientListBySubscriptionPager provides operations for iterating over paged responses.
type TopicsClientListBySubscriptionPager struct {
	client    *TopicsClient
	current   TopicsClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TopicsClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TopicsClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TopicsListResult.NextLink == nil || len(*p.current.TopicsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *TopicsClientListBySubscriptionPager) NextPage(ctx context.Context) (TopicsClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return TopicsClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TopicsClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TopicsClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TopicsClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return TopicsClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TopicsClientListEventTypesPager provides operations for iterating over paged responses.
type TopicsClientListEventTypesPager struct {
	client    *TopicsClient
	current   TopicsClientListEventTypesResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TopicsClientListEventTypesPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *TopicsClientListEventTypesPager) NextPage(ctx context.Context) (TopicsClientListEventTypesResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return TopicsClientListEventTypesResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TopicsClientListEventTypesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TopicsClientListEventTypesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TopicsClientListEventTypesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listEventTypesHandleResponse(resp)
	if err != nil {
		return TopicsClientListEventTypesResponse{}, err
	}
	p.current = result
	return p.current, nil
}
