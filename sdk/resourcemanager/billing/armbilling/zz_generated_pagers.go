//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armbilling

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AccountsClientListInvoiceSectionsByCreateSubscriptionPermissionPager provides operations for iterating over paged responses.
type AccountsClientListInvoiceSectionsByCreateSubscriptionPermissionPager struct {
	client    *AccountsClient
	current   AccountsClientListInvoiceSectionsByCreateSubscriptionPermissionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AccountsClientListInvoiceSectionsByCreateSubscriptionPermissionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AccountsClientListInvoiceSectionsByCreateSubscriptionPermissionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InvoiceSectionListWithCreateSubPermissionResult.NextLink == nil || len(*p.current.InvoiceSectionListWithCreateSubPermissionResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AccountsClientListInvoiceSectionsByCreateSubscriptionPermissionPager) NextPage(ctx context.Context) (AccountsClientListInvoiceSectionsByCreateSubscriptionPermissionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AccountsClientListInvoiceSectionsByCreateSubscriptionPermissionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AccountsClientListInvoiceSectionsByCreateSubscriptionPermissionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AccountsClientListInvoiceSectionsByCreateSubscriptionPermissionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AccountsClientListInvoiceSectionsByCreateSubscriptionPermissionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listInvoiceSectionsByCreateSubscriptionPermissionHandleResponse(resp)
	if err != nil {
		return AccountsClientListInvoiceSectionsByCreateSubscriptionPermissionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AccountsClientListPager provides operations for iterating over paged responses.
type AccountsClientListPager struct {
	client    *AccountsClient
	current   AccountsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AccountsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AccountsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AccountListResult.NextLink == nil || len(*p.current.AccountListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AccountsClientListPager) NextPage(ctx context.Context) (AccountsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AccountsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AccountsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AccountsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AccountsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return AccountsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AgreementsClientListByBillingAccountPager provides operations for iterating over paged responses.
type AgreementsClientListByBillingAccountPager struct {
	client    *AgreementsClient
	current   AgreementsClientListByBillingAccountResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AgreementsClientListByBillingAccountResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AgreementsClientListByBillingAccountPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AgreementListResult.NextLink == nil || len(*p.current.AgreementListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AgreementsClientListByBillingAccountPager) NextPage(ctx context.Context) (AgreementsClientListByBillingAccountResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AgreementsClientListByBillingAccountResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AgreementsClientListByBillingAccountResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AgreementsClientListByBillingAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AgreementsClientListByBillingAccountResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		return AgreementsClientListByBillingAccountResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CustomersClientListByBillingAccountPager provides operations for iterating over paged responses.
type CustomersClientListByBillingAccountPager struct {
	client    *CustomersClient
	current   CustomersClientListByBillingAccountResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomersClientListByBillingAccountResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CustomersClientListByBillingAccountPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomerListResult.NextLink == nil || len(*p.current.CustomerListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CustomersClientListByBillingAccountPager) NextPage(ctx context.Context) (CustomersClientListByBillingAccountResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CustomersClientListByBillingAccountResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CustomersClientListByBillingAccountResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CustomersClientListByBillingAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CustomersClientListByBillingAccountResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		return CustomersClientListByBillingAccountResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CustomersClientListByBillingProfilePager provides operations for iterating over paged responses.
type CustomersClientListByBillingProfilePager struct {
	client    *CustomersClient
	current   CustomersClientListByBillingProfileResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomersClientListByBillingProfileResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CustomersClientListByBillingProfilePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomerListResult.NextLink == nil || len(*p.current.CustomerListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CustomersClientListByBillingProfilePager) NextPage(ctx context.Context) (CustomersClientListByBillingProfileResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CustomersClientListByBillingProfileResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CustomersClientListByBillingProfileResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CustomersClientListByBillingProfileResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CustomersClientListByBillingProfileResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		return CustomersClientListByBillingProfileResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// EnrollmentAccountsClientListPager provides operations for iterating over paged responses.
type EnrollmentAccountsClientListPager struct {
	client    *EnrollmentAccountsClient
	current   EnrollmentAccountsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EnrollmentAccountsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *EnrollmentAccountsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EnrollmentAccountListResult.NextLink == nil || len(*p.current.EnrollmentAccountListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *EnrollmentAccountsClientListPager) NextPage(ctx context.Context) (EnrollmentAccountsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return EnrollmentAccountsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return EnrollmentAccountsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return EnrollmentAccountsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return EnrollmentAccountsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return EnrollmentAccountsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// InstructionsClientListByBillingProfilePager provides operations for iterating over paged responses.
type InstructionsClientListByBillingProfilePager struct {
	client    *InstructionsClient
	current   InstructionsClientListByBillingProfileResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InstructionsClientListByBillingProfileResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *InstructionsClientListByBillingProfilePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InstructionListResult.NextLink == nil || len(*p.current.InstructionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *InstructionsClientListByBillingProfilePager) NextPage(ctx context.Context) (InstructionsClientListByBillingProfileResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return InstructionsClientListByBillingProfileResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return InstructionsClientListByBillingProfileResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return InstructionsClientListByBillingProfileResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return InstructionsClientListByBillingProfileResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		return InstructionsClientListByBillingProfileResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// InvoiceSectionsClientListByBillingProfilePager provides operations for iterating over paged responses.
type InvoiceSectionsClientListByBillingProfilePager struct {
	client    *InvoiceSectionsClient
	current   InvoiceSectionsClientListByBillingProfileResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InvoiceSectionsClientListByBillingProfileResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *InvoiceSectionsClientListByBillingProfilePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InvoiceSectionListResult.NextLink == nil || len(*p.current.InvoiceSectionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *InvoiceSectionsClientListByBillingProfilePager) NextPage(ctx context.Context) (InvoiceSectionsClientListByBillingProfileResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return InvoiceSectionsClientListByBillingProfileResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return InvoiceSectionsClientListByBillingProfileResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return InvoiceSectionsClientListByBillingProfileResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return InvoiceSectionsClientListByBillingProfileResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		return InvoiceSectionsClientListByBillingProfileResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// InvoicesClientListByBillingAccountPager provides operations for iterating over paged responses.
type InvoicesClientListByBillingAccountPager struct {
	client    *InvoicesClient
	current   InvoicesClientListByBillingAccountResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InvoicesClientListByBillingAccountResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *InvoicesClientListByBillingAccountPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InvoiceListResult.NextLink == nil || len(*p.current.InvoiceListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *InvoicesClientListByBillingAccountPager) NextPage(ctx context.Context) (InvoicesClientListByBillingAccountResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return InvoicesClientListByBillingAccountResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return InvoicesClientListByBillingAccountResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return InvoicesClientListByBillingAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return InvoicesClientListByBillingAccountResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		return InvoicesClientListByBillingAccountResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// InvoicesClientListByBillingProfilePager provides operations for iterating over paged responses.
type InvoicesClientListByBillingProfilePager struct {
	client    *InvoicesClient
	current   InvoicesClientListByBillingProfileResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InvoicesClientListByBillingProfileResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *InvoicesClientListByBillingProfilePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InvoiceListResult.NextLink == nil || len(*p.current.InvoiceListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *InvoicesClientListByBillingProfilePager) NextPage(ctx context.Context) (InvoicesClientListByBillingProfileResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return InvoicesClientListByBillingProfileResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return InvoicesClientListByBillingProfileResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return InvoicesClientListByBillingProfileResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return InvoicesClientListByBillingProfileResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		return InvoicesClientListByBillingProfileResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// InvoicesClientListByBillingSubscriptionPager provides operations for iterating over paged responses.
type InvoicesClientListByBillingSubscriptionPager struct {
	client    *InvoicesClient
	current   InvoicesClientListByBillingSubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InvoicesClientListByBillingSubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *InvoicesClientListByBillingSubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InvoiceListResult.NextLink == nil || len(*p.current.InvoiceListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *InvoicesClientListByBillingSubscriptionPager) NextPage(ctx context.Context) (InvoicesClientListByBillingSubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return InvoicesClientListByBillingSubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return InvoicesClientListByBillingSubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return InvoicesClientListByBillingSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return InvoicesClientListByBillingSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingSubscriptionHandleResponse(resp)
	if err != nil {
		return InvoicesClientListByBillingSubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *OperationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *OperationsClientListPager) NextPage(ctx context.Context) (OperationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return OperationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return OperationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PeriodsClientListPager provides operations for iterating over paged responses.
type PeriodsClientListPager struct {
	client    *PeriodsClient
	current   PeriodsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PeriodsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PeriodsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PeriodsListResult.NextLink == nil || len(*p.current.PeriodsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PeriodsClientListPager) NextPage(ctx context.Context) (PeriodsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PeriodsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PeriodsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PeriodsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PeriodsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return PeriodsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PermissionsClientListByBillingAccountPager provides operations for iterating over paged responses.
type PermissionsClientListByBillingAccountPager struct {
	client    *PermissionsClient
	current   PermissionsClientListByBillingAccountResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PermissionsClientListByBillingAccountResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PermissionsClientListByBillingAccountPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PermissionsListResult.NextLink == nil || len(*p.current.PermissionsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PermissionsClientListByBillingAccountPager) NextPage(ctx context.Context) (PermissionsClientListByBillingAccountResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PermissionsClientListByBillingAccountResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PermissionsClientListByBillingAccountResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PermissionsClientListByBillingAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PermissionsClientListByBillingAccountResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		return PermissionsClientListByBillingAccountResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PermissionsClientListByBillingProfilePager provides operations for iterating over paged responses.
type PermissionsClientListByBillingProfilePager struct {
	client    *PermissionsClient
	current   PermissionsClientListByBillingProfileResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PermissionsClientListByBillingProfileResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PermissionsClientListByBillingProfilePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PermissionsListResult.NextLink == nil || len(*p.current.PermissionsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PermissionsClientListByBillingProfilePager) NextPage(ctx context.Context) (PermissionsClientListByBillingProfileResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PermissionsClientListByBillingProfileResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PermissionsClientListByBillingProfileResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PermissionsClientListByBillingProfileResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PermissionsClientListByBillingProfileResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		return PermissionsClientListByBillingProfileResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PermissionsClientListByCustomerPager provides operations for iterating over paged responses.
type PermissionsClientListByCustomerPager struct {
	client    *PermissionsClient
	current   PermissionsClientListByCustomerResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PermissionsClientListByCustomerResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PermissionsClientListByCustomerPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PermissionsListResult.NextLink == nil || len(*p.current.PermissionsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PermissionsClientListByCustomerPager) NextPage(ctx context.Context) (PermissionsClientListByCustomerResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PermissionsClientListByCustomerResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PermissionsClientListByCustomerResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PermissionsClientListByCustomerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PermissionsClientListByCustomerResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByCustomerHandleResponse(resp)
	if err != nil {
		return PermissionsClientListByCustomerResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PermissionsClientListByInvoiceSectionsPager provides operations for iterating over paged responses.
type PermissionsClientListByInvoiceSectionsPager struct {
	client    *PermissionsClient
	current   PermissionsClientListByInvoiceSectionsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PermissionsClientListByInvoiceSectionsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PermissionsClientListByInvoiceSectionsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PermissionsListResult.NextLink == nil || len(*p.current.PermissionsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PermissionsClientListByInvoiceSectionsPager) NextPage(ctx context.Context) (PermissionsClientListByInvoiceSectionsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PermissionsClientListByInvoiceSectionsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PermissionsClientListByInvoiceSectionsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PermissionsClientListByInvoiceSectionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PermissionsClientListByInvoiceSectionsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByInvoiceSectionsHandleResponse(resp)
	if err != nil {
		return PermissionsClientListByInvoiceSectionsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProductsClientListByBillingAccountPager provides operations for iterating over paged responses.
type ProductsClientListByBillingAccountPager struct {
	client    *ProductsClient
	current   ProductsClientListByBillingAccountResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductsClientListByBillingAccountResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProductsClientListByBillingAccountPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductsListResult.NextLink == nil || len(*p.current.ProductsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProductsClientListByBillingAccountPager) NextPage(ctx context.Context) (ProductsClientListByBillingAccountResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProductsClientListByBillingAccountResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProductsClientListByBillingAccountResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProductsClientListByBillingAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProductsClientListByBillingAccountResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		return ProductsClientListByBillingAccountResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProductsClientListByBillingProfilePager provides operations for iterating over paged responses.
type ProductsClientListByBillingProfilePager struct {
	client    *ProductsClient
	current   ProductsClientListByBillingProfileResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductsClientListByBillingProfileResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProductsClientListByBillingProfilePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductsListResult.NextLink == nil || len(*p.current.ProductsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProductsClientListByBillingProfilePager) NextPage(ctx context.Context) (ProductsClientListByBillingProfileResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProductsClientListByBillingProfileResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProductsClientListByBillingProfileResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProductsClientListByBillingProfileResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProductsClientListByBillingProfileResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		return ProductsClientListByBillingProfileResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProductsClientListByCustomerPager provides operations for iterating over paged responses.
type ProductsClientListByCustomerPager struct {
	client    *ProductsClient
	current   ProductsClientListByCustomerResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductsClientListByCustomerResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProductsClientListByCustomerPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductsListResult.NextLink == nil || len(*p.current.ProductsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProductsClientListByCustomerPager) NextPage(ctx context.Context) (ProductsClientListByCustomerResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProductsClientListByCustomerResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProductsClientListByCustomerResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProductsClientListByCustomerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProductsClientListByCustomerResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByCustomerHandleResponse(resp)
	if err != nil {
		return ProductsClientListByCustomerResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProductsClientListByInvoiceSectionPager provides operations for iterating over paged responses.
type ProductsClientListByInvoiceSectionPager struct {
	client    *ProductsClient
	current   ProductsClientListByInvoiceSectionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductsClientListByInvoiceSectionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProductsClientListByInvoiceSectionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductsListResult.NextLink == nil || len(*p.current.ProductsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProductsClientListByInvoiceSectionPager) NextPage(ctx context.Context) (ProductsClientListByInvoiceSectionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProductsClientListByInvoiceSectionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProductsClientListByInvoiceSectionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProductsClientListByInvoiceSectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProductsClientListByInvoiceSectionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByInvoiceSectionHandleResponse(resp)
	if err != nil {
		return ProductsClientListByInvoiceSectionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProfilesClientListByBillingAccountPager provides operations for iterating over paged responses.
type ProfilesClientListByBillingAccountPager struct {
	client    *ProfilesClient
	current   ProfilesClientListByBillingAccountResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProfilesClientListByBillingAccountResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProfilesClientListByBillingAccountPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProfileListResult.NextLink == nil || len(*p.current.ProfileListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProfilesClientListByBillingAccountPager) NextPage(ctx context.Context) (ProfilesClientListByBillingAccountResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProfilesClientListByBillingAccountResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProfilesClientListByBillingAccountResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProfilesClientListByBillingAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProfilesClientListByBillingAccountResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		return ProfilesClientListByBillingAccountResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ReservationsClientListByBillingAccountPager provides operations for iterating over paged responses.
type ReservationsClientListByBillingAccountPager struct {
	client    *ReservationsClient
	current   ReservationsClientListByBillingAccountResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationsClientListByBillingAccountResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ReservationsClientListByBillingAccountPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReservationsListResult.NextLink == nil || len(*p.current.ReservationsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ReservationsClientListByBillingAccountPager) NextPage(ctx context.Context) (ReservationsClientListByBillingAccountResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ReservationsClientListByBillingAccountResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ReservationsClientListByBillingAccountResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ReservationsClientListByBillingAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ReservationsClientListByBillingAccountResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		return ReservationsClientListByBillingAccountResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ReservationsClientListByBillingProfilePager provides operations for iterating over paged responses.
type ReservationsClientListByBillingProfilePager struct {
	client    *ReservationsClient
	current   ReservationsClientListByBillingProfileResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReservationsClientListByBillingProfileResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ReservationsClientListByBillingProfilePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReservationsListResult.NextLink == nil || len(*p.current.ReservationsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ReservationsClientListByBillingProfilePager) NextPage(ctx context.Context) (ReservationsClientListByBillingProfileResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ReservationsClientListByBillingProfileResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ReservationsClientListByBillingProfileResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ReservationsClientListByBillingProfileResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ReservationsClientListByBillingProfileResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		return ReservationsClientListByBillingProfileResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RoleAssignmentsClientListByBillingAccountPager provides operations for iterating over paged responses.
type RoleAssignmentsClientListByBillingAccountPager struct {
	client    *RoleAssignmentsClient
	current   RoleAssignmentsClientListByBillingAccountResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleAssignmentsClientListByBillingAccountResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RoleAssignmentsClientListByBillingAccountPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleAssignmentListResult.NextLink == nil || len(*p.current.RoleAssignmentListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RoleAssignmentsClientListByBillingAccountPager) NextPage(ctx context.Context) (RoleAssignmentsClientListByBillingAccountResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RoleAssignmentsClientListByBillingAccountResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RoleAssignmentsClientListByBillingAccountResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RoleAssignmentsClientListByBillingAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RoleAssignmentsClientListByBillingAccountResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		return RoleAssignmentsClientListByBillingAccountResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RoleAssignmentsClientListByBillingProfilePager provides operations for iterating over paged responses.
type RoleAssignmentsClientListByBillingProfilePager struct {
	client    *RoleAssignmentsClient
	current   RoleAssignmentsClientListByBillingProfileResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleAssignmentsClientListByBillingProfileResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RoleAssignmentsClientListByBillingProfilePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleAssignmentListResult.NextLink == nil || len(*p.current.RoleAssignmentListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RoleAssignmentsClientListByBillingProfilePager) NextPage(ctx context.Context) (RoleAssignmentsClientListByBillingProfileResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RoleAssignmentsClientListByBillingProfileResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RoleAssignmentsClientListByBillingProfileResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RoleAssignmentsClientListByBillingProfileResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RoleAssignmentsClientListByBillingProfileResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		return RoleAssignmentsClientListByBillingProfileResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RoleAssignmentsClientListByInvoiceSectionPager provides operations for iterating over paged responses.
type RoleAssignmentsClientListByInvoiceSectionPager struct {
	client    *RoleAssignmentsClient
	current   RoleAssignmentsClientListByInvoiceSectionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleAssignmentsClientListByInvoiceSectionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RoleAssignmentsClientListByInvoiceSectionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleAssignmentListResult.NextLink == nil || len(*p.current.RoleAssignmentListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RoleAssignmentsClientListByInvoiceSectionPager) NextPage(ctx context.Context) (RoleAssignmentsClientListByInvoiceSectionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RoleAssignmentsClientListByInvoiceSectionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RoleAssignmentsClientListByInvoiceSectionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RoleAssignmentsClientListByInvoiceSectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RoleAssignmentsClientListByInvoiceSectionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByInvoiceSectionHandleResponse(resp)
	if err != nil {
		return RoleAssignmentsClientListByInvoiceSectionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RoleDefinitionsClientListByBillingAccountPager provides operations for iterating over paged responses.
type RoleDefinitionsClientListByBillingAccountPager struct {
	client    *RoleDefinitionsClient
	current   RoleDefinitionsClientListByBillingAccountResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleDefinitionsClientListByBillingAccountResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RoleDefinitionsClientListByBillingAccountPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleDefinitionListResult.NextLink == nil || len(*p.current.RoleDefinitionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RoleDefinitionsClientListByBillingAccountPager) NextPage(ctx context.Context) (RoleDefinitionsClientListByBillingAccountResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RoleDefinitionsClientListByBillingAccountResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RoleDefinitionsClientListByBillingAccountResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RoleDefinitionsClientListByBillingAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RoleDefinitionsClientListByBillingAccountResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		return RoleDefinitionsClientListByBillingAccountResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RoleDefinitionsClientListByBillingProfilePager provides operations for iterating over paged responses.
type RoleDefinitionsClientListByBillingProfilePager struct {
	client    *RoleDefinitionsClient
	current   RoleDefinitionsClientListByBillingProfileResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleDefinitionsClientListByBillingProfileResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RoleDefinitionsClientListByBillingProfilePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleDefinitionListResult.NextLink == nil || len(*p.current.RoleDefinitionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RoleDefinitionsClientListByBillingProfilePager) NextPage(ctx context.Context) (RoleDefinitionsClientListByBillingProfileResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RoleDefinitionsClientListByBillingProfileResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RoleDefinitionsClientListByBillingProfileResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RoleDefinitionsClientListByBillingProfileResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RoleDefinitionsClientListByBillingProfileResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		return RoleDefinitionsClientListByBillingProfileResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RoleDefinitionsClientListByInvoiceSectionPager provides operations for iterating over paged responses.
type RoleDefinitionsClientListByInvoiceSectionPager struct {
	client    *RoleDefinitionsClient
	current   RoleDefinitionsClientListByInvoiceSectionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleDefinitionsClientListByInvoiceSectionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RoleDefinitionsClientListByInvoiceSectionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleDefinitionListResult.NextLink == nil || len(*p.current.RoleDefinitionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RoleDefinitionsClientListByInvoiceSectionPager) NextPage(ctx context.Context) (RoleDefinitionsClientListByInvoiceSectionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RoleDefinitionsClientListByInvoiceSectionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RoleDefinitionsClientListByInvoiceSectionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RoleDefinitionsClientListByInvoiceSectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RoleDefinitionsClientListByInvoiceSectionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByInvoiceSectionHandleResponse(resp)
	if err != nil {
		return RoleDefinitionsClientListByInvoiceSectionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SubscriptionsClientListByBillingAccountPager provides operations for iterating over paged responses.
type SubscriptionsClientListByBillingAccountPager struct {
	client    *SubscriptionsClient
	current   SubscriptionsClientListByBillingAccountResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubscriptionsClientListByBillingAccountResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SubscriptionsClientListByBillingAccountPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubscriptionsListResult.NextLink == nil || len(*p.current.SubscriptionsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SubscriptionsClientListByBillingAccountPager) NextPage(ctx context.Context) (SubscriptionsClientListByBillingAccountResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SubscriptionsClientListByBillingAccountResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SubscriptionsClientListByBillingAccountResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SubscriptionsClientListByBillingAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SubscriptionsClientListByBillingAccountResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingAccountHandleResponse(resp)
	if err != nil {
		return SubscriptionsClientListByBillingAccountResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SubscriptionsClientListByBillingProfilePager provides operations for iterating over paged responses.
type SubscriptionsClientListByBillingProfilePager struct {
	client    *SubscriptionsClient
	current   SubscriptionsClientListByBillingProfileResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubscriptionsClientListByBillingProfileResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SubscriptionsClientListByBillingProfilePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubscriptionsListResult.NextLink == nil || len(*p.current.SubscriptionsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SubscriptionsClientListByBillingProfilePager) NextPage(ctx context.Context) (SubscriptionsClientListByBillingProfileResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SubscriptionsClientListByBillingProfileResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SubscriptionsClientListByBillingProfileResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SubscriptionsClientListByBillingProfileResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SubscriptionsClientListByBillingProfileResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBillingProfileHandleResponse(resp)
	if err != nil {
		return SubscriptionsClientListByBillingProfileResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SubscriptionsClientListByCustomerPager provides operations for iterating over paged responses.
type SubscriptionsClientListByCustomerPager struct {
	client    *SubscriptionsClient
	current   SubscriptionsClientListByCustomerResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubscriptionsClientListByCustomerResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SubscriptionsClientListByCustomerPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubscriptionsListResult.NextLink == nil || len(*p.current.SubscriptionsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SubscriptionsClientListByCustomerPager) NextPage(ctx context.Context) (SubscriptionsClientListByCustomerResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SubscriptionsClientListByCustomerResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SubscriptionsClientListByCustomerResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SubscriptionsClientListByCustomerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SubscriptionsClientListByCustomerResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByCustomerHandleResponse(resp)
	if err != nil {
		return SubscriptionsClientListByCustomerResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SubscriptionsClientListByInvoiceSectionPager provides operations for iterating over paged responses.
type SubscriptionsClientListByInvoiceSectionPager struct {
	client    *SubscriptionsClient
	current   SubscriptionsClientListByInvoiceSectionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubscriptionsClientListByInvoiceSectionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SubscriptionsClientListByInvoiceSectionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubscriptionsListResult.NextLink == nil || len(*p.current.SubscriptionsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SubscriptionsClientListByInvoiceSectionPager) NextPage(ctx context.Context) (SubscriptionsClientListByInvoiceSectionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SubscriptionsClientListByInvoiceSectionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SubscriptionsClientListByInvoiceSectionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SubscriptionsClientListByInvoiceSectionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SubscriptionsClientListByInvoiceSectionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByInvoiceSectionHandleResponse(resp)
	if err != nil {
		return SubscriptionsClientListByInvoiceSectionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TransactionsClientListByInvoicePager provides operations for iterating over paged responses.
type TransactionsClientListByInvoicePager struct {
	client    *TransactionsClient
	current   TransactionsClientListByInvoiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TransactionsClientListByInvoiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TransactionsClientListByInvoicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TransactionListResult.NextLink == nil || len(*p.current.TransactionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *TransactionsClientListByInvoicePager) NextPage(ctx context.Context) (TransactionsClientListByInvoiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return TransactionsClientListByInvoiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TransactionsClientListByInvoiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TransactionsClientListByInvoiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TransactionsClientListByInvoiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByInvoiceHandleResponse(resp)
	if err != nil {
		return TransactionsClientListByInvoiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}
