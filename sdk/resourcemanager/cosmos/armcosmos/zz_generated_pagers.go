//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcosmos

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// CassandraClustersClientListByResourceGroupPager provides operations for iterating over paged responses.
type CassandraClustersClientListByResourceGroupPager struct {
	client    *CassandraClustersClient
	current   CassandraClustersClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CassandraClustersClientListByResourceGroupPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *CassandraClustersClientListByResourceGroupPager) NextPage(ctx context.Context) (CassandraClustersClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return CassandraClustersClientListByResourceGroupResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CassandraClustersClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CassandraClustersClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CassandraClustersClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return CassandraClustersClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CassandraClustersClientListBySubscriptionPager provides operations for iterating over paged responses.
type CassandraClustersClientListBySubscriptionPager struct {
	client    *CassandraClustersClient
	current   CassandraClustersClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CassandraClustersClientListBySubscriptionPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *CassandraClustersClientListBySubscriptionPager) NextPage(ctx context.Context) (CassandraClustersClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return CassandraClustersClientListBySubscriptionResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CassandraClustersClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CassandraClustersClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CassandraClustersClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return CassandraClustersClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CassandraDataCentersClientListPager provides operations for iterating over paged responses.
type CassandraDataCentersClientListPager struct {
	client    *CassandraDataCentersClient
	current   CassandraDataCentersClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CassandraDataCentersClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *CassandraDataCentersClientListPager) NextPage(ctx context.Context) (CassandraDataCentersClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return CassandraDataCentersClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CassandraDataCentersClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CassandraDataCentersClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CassandraDataCentersClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return CassandraDataCentersClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CassandraResourcesClientListCassandraKeyspacesPager provides operations for iterating over paged responses.
type CassandraResourcesClientListCassandraKeyspacesPager struct {
	client    *CassandraResourcesClient
	current   CassandraResourcesClientListCassandraKeyspacesResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CassandraResourcesClientListCassandraKeyspacesPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *CassandraResourcesClientListCassandraKeyspacesPager) NextPage(ctx context.Context) (CassandraResourcesClientListCassandraKeyspacesResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return CassandraResourcesClientListCassandraKeyspacesResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CassandraResourcesClientListCassandraKeyspacesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CassandraResourcesClientListCassandraKeyspacesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CassandraResourcesClientListCassandraKeyspacesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listCassandraKeyspacesHandleResponse(resp)
	if err != nil {
		return CassandraResourcesClientListCassandraKeyspacesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CassandraResourcesClientListCassandraTablesPager provides operations for iterating over paged responses.
type CassandraResourcesClientListCassandraTablesPager struct {
	client    *CassandraResourcesClient
	current   CassandraResourcesClientListCassandraTablesResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CassandraResourcesClientListCassandraTablesPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *CassandraResourcesClientListCassandraTablesPager) NextPage(ctx context.Context) (CassandraResourcesClientListCassandraTablesResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return CassandraResourcesClientListCassandraTablesResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CassandraResourcesClientListCassandraTablesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CassandraResourcesClientListCassandraTablesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CassandraResourcesClientListCassandraTablesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listCassandraTablesHandleResponse(resp)
	if err != nil {
		return CassandraResourcesClientListCassandraTablesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CollectionClientListMetricDefinitionsPager provides operations for iterating over paged responses.
type CollectionClientListMetricDefinitionsPager struct {
	client    *CollectionClient
	current   CollectionClientListMetricDefinitionsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CollectionClientListMetricDefinitionsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *CollectionClientListMetricDefinitionsPager) NextPage(ctx context.Context) (CollectionClientListMetricDefinitionsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return CollectionClientListMetricDefinitionsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CollectionClientListMetricDefinitionsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CollectionClientListMetricDefinitionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CollectionClientListMetricDefinitionsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricDefinitionsHandleResponse(resp)
	if err != nil {
		return CollectionClientListMetricDefinitionsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CollectionClientListMetricsPager provides operations for iterating over paged responses.
type CollectionClientListMetricsPager struct {
	client    *CollectionClient
	current   CollectionClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CollectionClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *CollectionClientListMetricsPager) NextPage(ctx context.Context) (CollectionClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return CollectionClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CollectionClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CollectionClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CollectionClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return CollectionClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CollectionClientListUsagesPager provides operations for iterating over paged responses.
type CollectionClientListUsagesPager struct {
	client    *CollectionClient
	current   CollectionClientListUsagesResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CollectionClientListUsagesPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *CollectionClientListUsagesPager) NextPage(ctx context.Context) (CollectionClientListUsagesResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return CollectionClientListUsagesResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CollectionClientListUsagesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CollectionClientListUsagesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CollectionClientListUsagesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listUsagesHandleResponse(resp)
	if err != nil {
		return CollectionClientListUsagesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CollectionPartitionClientListMetricsPager provides operations for iterating over paged responses.
type CollectionPartitionClientListMetricsPager struct {
	client    *CollectionPartitionClient
	current   CollectionPartitionClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CollectionPartitionClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *CollectionPartitionClientListMetricsPager) NextPage(ctx context.Context) (CollectionPartitionClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return CollectionPartitionClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CollectionPartitionClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CollectionPartitionClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CollectionPartitionClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return CollectionPartitionClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CollectionPartitionClientListUsagesPager provides operations for iterating over paged responses.
type CollectionPartitionClientListUsagesPager struct {
	client    *CollectionPartitionClient
	current   CollectionPartitionClientListUsagesResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CollectionPartitionClientListUsagesPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *CollectionPartitionClientListUsagesPager) NextPage(ctx context.Context) (CollectionPartitionClientListUsagesResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return CollectionPartitionClientListUsagesResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CollectionPartitionClientListUsagesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CollectionPartitionClientListUsagesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CollectionPartitionClientListUsagesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listUsagesHandleResponse(resp)
	if err != nil {
		return CollectionPartitionClientListUsagesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CollectionPartitionRegionClientListMetricsPager provides operations for iterating over paged responses.
type CollectionPartitionRegionClientListMetricsPager struct {
	client    *CollectionPartitionRegionClient
	current   CollectionPartitionRegionClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CollectionPartitionRegionClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *CollectionPartitionRegionClientListMetricsPager) NextPage(ctx context.Context) (CollectionPartitionRegionClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return CollectionPartitionRegionClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CollectionPartitionRegionClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CollectionPartitionRegionClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CollectionPartitionRegionClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return CollectionPartitionRegionClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CollectionRegionClientListMetricsPager provides operations for iterating over paged responses.
type CollectionRegionClientListMetricsPager struct {
	client    *CollectionRegionClient
	current   CollectionRegionClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CollectionRegionClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *CollectionRegionClientListMetricsPager) NextPage(ctx context.Context) (CollectionRegionClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return CollectionRegionClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CollectionRegionClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CollectionRegionClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CollectionRegionClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return CollectionRegionClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DatabaseAccountRegionClientListMetricsPager provides operations for iterating over paged responses.
type DatabaseAccountRegionClientListMetricsPager struct {
	client    *DatabaseAccountRegionClient
	current   DatabaseAccountRegionClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DatabaseAccountRegionClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *DatabaseAccountRegionClientListMetricsPager) NextPage(ctx context.Context) (DatabaseAccountRegionClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return DatabaseAccountRegionClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DatabaseAccountRegionClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DatabaseAccountRegionClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DatabaseAccountRegionClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return DatabaseAccountRegionClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DatabaseAccountsClientListByResourceGroupPager provides operations for iterating over paged responses.
type DatabaseAccountsClientListByResourceGroupPager struct {
	client    *DatabaseAccountsClient
	current   DatabaseAccountsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DatabaseAccountsClientListByResourceGroupPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *DatabaseAccountsClientListByResourceGroupPager) NextPage(ctx context.Context) (DatabaseAccountsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return DatabaseAccountsClientListByResourceGroupResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DatabaseAccountsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DatabaseAccountsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DatabaseAccountsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return DatabaseAccountsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DatabaseAccountsClientListMetricDefinitionsPager provides operations for iterating over paged responses.
type DatabaseAccountsClientListMetricDefinitionsPager struct {
	client    *DatabaseAccountsClient
	current   DatabaseAccountsClientListMetricDefinitionsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DatabaseAccountsClientListMetricDefinitionsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *DatabaseAccountsClientListMetricDefinitionsPager) NextPage(ctx context.Context) (DatabaseAccountsClientListMetricDefinitionsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return DatabaseAccountsClientListMetricDefinitionsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DatabaseAccountsClientListMetricDefinitionsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DatabaseAccountsClientListMetricDefinitionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DatabaseAccountsClientListMetricDefinitionsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricDefinitionsHandleResponse(resp)
	if err != nil {
		return DatabaseAccountsClientListMetricDefinitionsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DatabaseAccountsClientListMetricsPager provides operations for iterating over paged responses.
type DatabaseAccountsClientListMetricsPager struct {
	client    *DatabaseAccountsClient
	current   DatabaseAccountsClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DatabaseAccountsClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *DatabaseAccountsClientListMetricsPager) NextPage(ctx context.Context) (DatabaseAccountsClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return DatabaseAccountsClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DatabaseAccountsClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DatabaseAccountsClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DatabaseAccountsClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return DatabaseAccountsClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DatabaseAccountsClientListPager provides operations for iterating over paged responses.
type DatabaseAccountsClientListPager struct {
	client    *DatabaseAccountsClient
	current   DatabaseAccountsClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DatabaseAccountsClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *DatabaseAccountsClientListPager) NextPage(ctx context.Context) (DatabaseAccountsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return DatabaseAccountsClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DatabaseAccountsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DatabaseAccountsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DatabaseAccountsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return DatabaseAccountsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DatabaseAccountsClientListUsagesPager provides operations for iterating over paged responses.
type DatabaseAccountsClientListUsagesPager struct {
	client    *DatabaseAccountsClient
	current   DatabaseAccountsClientListUsagesResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DatabaseAccountsClientListUsagesPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *DatabaseAccountsClientListUsagesPager) NextPage(ctx context.Context) (DatabaseAccountsClientListUsagesResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return DatabaseAccountsClientListUsagesResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DatabaseAccountsClientListUsagesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DatabaseAccountsClientListUsagesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DatabaseAccountsClientListUsagesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listUsagesHandleResponse(resp)
	if err != nil {
		return DatabaseAccountsClientListUsagesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DatabaseClientListMetricDefinitionsPager provides operations for iterating over paged responses.
type DatabaseClientListMetricDefinitionsPager struct {
	client    *DatabaseClient
	current   DatabaseClientListMetricDefinitionsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DatabaseClientListMetricDefinitionsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *DatabaseClientListMetricDefinitionsPager) NextPage(ctx context.Context) (DatabaseClientListMetricDefinitionsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return DatabaseClientListMetricDefinitionsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DatabaseClientListMetricDefinitionsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DatabaseClientListMetricDefinitionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DatabaseClientListMetricDefinitionsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricDefinitionsHandleResponse(resp)
	if err != nil {
		return DatabaseClientListMetricDefinitionsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DatabaseClientListMetricsPager provides operations for iterating over paged responses.
type DatabaseClientListMetricsPager struct {
	client    *DatabaseClient
	current   DatabaseClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DatabaseClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *DatabaseClientListMetricsPager) NextPage(ctx context.Context) (DatabaseClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return DatabaseClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DatabaseClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DatabaseClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DatabaseClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return DatabaseClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DatabaseClientListUsagesPager provides operations for iterating over paged responses.
type DatabaseClientListUsagesPager struct {
	client    *DatabaseClient
	current   DatabaseClientListUsagesResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DatabaseClientListUsagesPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *DatabaseClientListUsagesPager) NextPage(ctx context.Context) (DatabaseClientListUsagesResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return DatabaseClientListUsagesResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DatabaseClientListUsagesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DatabaseClientListUsagesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DatabaseClientListUsagesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listUsagesHandleResponse(resp)
	if err != nil {
		return DatabaseClientListUsagesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GremlinResourcesClientListGremlinDatabasesPager provides operations for iterating over paged responses.
type GremlinResourcesClientListGremlinDatabasesPager struct {
	client    *GremlinResourcesClient
	current   GremlinResourcesClientListGremlinDatabasesResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GremlinResourcesClientListGremlinDatabasesPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *GremlinResourcesClientListGremlinDatabasesPager) NextPage(ctx context.Context) (GremlinResourcesClientListGremlinDatabasesResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return GremlinResourcesClientListGremlinDatabasesResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GremlinResourcesClientListGremlinDatabasesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GremlinResourcesClientListGremlinDatabasesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GremlinResourcesClientListGremlinDatabasesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listGremlinDatabasesHandleResponse(resp)
	if err != nil {
		return GremlinResourcesClientListGremlinDatabasesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GremlinResourcesClientListGremlinGraphsPager provides operations for iterating over paged responses.
type GremlinResourcesClientListGremlinGraphsPager struct {
	client    *GremlinResourcesClient
	current   GremlinResourcesClientListGremlinGraphsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GremlinResourcesClientListGremlinGraphsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *GremlinResourcesClientListGremlinGraphsPager) NextPage(ctx context.Context) (GremlinResourcesClientListGremlinGraphsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return GremlinResourcesClientListGremlinGraphsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GremlinResourcesClientListGremlinGraphsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GremlinResourcesClientListGremlinGraphsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GremlinResourcesClientListGremlinGraphsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listGremlinGraphsHandleResponse(resp)
	if err != nil {
		return GremlinResourcesClientListGremlinGraphsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// LocationsClientListPager provides operations for iterating over paged responses.
type LocationsClientListPager struct {
	client    *LocationsClient
	current   LocationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *LocationsClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *LocationsClientListPager) NextPage(ctx context.Context) (LocationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return LocationsClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return LocationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return LocationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return LocationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return LocationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// MongoDBResourcesClientListMongoDBCollectionsPager provides operations for iterating over paged responses.
type MongoDBResourcesClientListMongoDBCollectionsPager struct {
	client    *MongoDBResourcesClient
	current   MongoDBResourcesClientListMongoDBCollectionsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *MongoDBResourcesClientListMongoDBCollectionsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *MongoDBResourcesClientListMongoDBCollectionsPager) NextPage(ctx context.Context) (MongoDBResourcesClientListMongoDBCollectionsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return MongoDBResourcesClientListMongoDBCollectionsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return MongoDBResourcesClientListMongoDBCollectionsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return MongoDBResourcesClientListMongoDBCollectionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return MongoDBResourcesClientListMongoDBCollectionsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMongoDBCollectionsHandleResponse(resp)
	if err != nil {
		return MongoDBResourcesClientListMongoDBCollectionsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// MongoDBResourcesClientListMongoDBDatabasesPager provides operations for iterating over paged responses.
type MongoDBResourcesClientListMongoDBDatabasesPager struct {
	client    *MongoDBResourcesClient
	current   MongoDBResourcesClientListMongoDBDatabasesResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *MongoDBResourcesClientListMongoDBDatabasesPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *MongoDBResourcesClientListMongoDBDatabasesPager) NextPage(ctx context.Context) (MongoDBResourcesClientListMongoDBDatabasesResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return MongoDBResourcesClientListMongoDBDatabasesResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return MongoDBResourcesClientListMongoDBDatabasesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return MongoDBResourcesClientListMongoDBDatabasesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return MongoDBResourcesClientListMongoDBDatabasesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMongoDBDatabasesHandleResponse(resp)
	if err != nil {
		return MongoDBResourcesClientListMongoDBDatabasesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// NotebookWorkspacesClientListByDatabaseAccountPager provides operations for iterating over paged responses.
type NotebookWorkspacesClientListByDatabaseAccountPager struct {
	client    *NotebookWorkspacesClient
	current   NotebookWorkspacesClientListByDatabaseAccountResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *NotebookWorkspacesClientListByDatabaseAccountPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *NotebookWorkspacesClientListByDatabaseAccountPager) NextPage(ctx context.Context) (NotebookWorkspacesClientListByDatabaseAccountResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return NotebookWorkspacesClientListByDatabaseAccountResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return NotebookWorkspacesClientListByDatabaseAccountResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return NotebookWorkspacesClientListByDatabaseAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return NotebookWorkspacesClientListByDatabaseAccountResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByDatabaseAccountHandleResponse(resp)
	if err != nil {
		return NotebookWorkspacesClientListByDatabaseAccountResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *OperationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *OperationsClientListPager) NextPage(ctx context.Context) (OperationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return OperationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return OperationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PartitionKeyRangeIDClientListMetricsPager provides operations for iterating over paged responses.
type PartitionKeyRangeIDClientListMetricsPager struct {
	client    *PartitionKeyRangeIDClient
	current   PartitionKeyRangeIDClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PartitionKeyRangeIDClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *PartitionKeyRangeIDClientListMetricsPager) NextPage(ctx context.Context) (PartitionKeyRangeIDClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return PartitionKeyRangeIDClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PartitionKeyRangeIDClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PartitionKeyRangeIDClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PartitionKeyRangeIDClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return PartitionKeyRangeIDClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PartitionKeyRangeIDRegionClientListMetricsPager provides operations for iterating over paged responses.
type PartitionKeyRangeIDRegionClientListMetricsPager struct {
	client    *PartitionKeyRangeIDRegionClient
	current   PartitionKeyRangeIDRegionClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PartitionKeyRangeIDRegionClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *PartitionKeyRangeIDRegionClientListMetricsPager) NextPage(ctx context.Context) (PartitionKeyRangeIDRegionClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return PartitionKeyRangeIDRegionClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PartitionKeyRangeIDRegionClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PartitionKeyRangeIDRegionClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PartitionKeyRangeIDRegionClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return PartitionKeyRangeIDRegionClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PercentileClientListMetricsPager provides operations for iterating over paged responses.
type PercentileClientListMetricsPager struct {
	client    *PercentileClient
	current   PercentileClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PercentileClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *PercentileClientListMetricsPager) NextPage(ctx context.Context) (PercentileClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return PercentileClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PercentileClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PercentileClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PercentileClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return PercentileClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PercentileSourceTargetClientListMetricsPager provides operations for iterating over paged responses.
type PercentileSourceTargetClientListMetricsPager struct {
	client    *PercentileSourceTargetClient
	current   PercentileSourceTargetClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PercentileSourceTargetClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *PercentileSourceTargetClientListMetricsPager) NextPage(ctx context.Context) (PercentileSourceTargetClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return PercentileSourceTargetClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PercentileSourceTargetClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PercentileSourceTargetClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PercentileSourceTargetClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return PercentileSourceTargetClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PercentileTargetClientListMetricsPager provides operations for iterating over paged responses.
type PercentileTargetClientListMetricsPager struct {
	client    *PercentileTargetClient
	current   PercentileTargetClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PercentileTargetClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *PercentileTargetClientListMetricsPager) NextPage(ctx context.Context) (PercentileTargetClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return PercentileTargetClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PercentileTargetClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PercentileTargetClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PercentileTargetClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return PercentileTargetClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PrivateEndpointConnectionsClientListByDatabaseAccountPager provides operations for iterating over paged responses.
type PrivateEndpointConnectionsClientListByDatabaseAccountPager struct {
	client    *PrivateEndpointConnectionsClient
	current   PrivateEndpointConnectionsClientListByDatabaseAccountResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PrivateEndpointConnectionsClientListByDatabaseAccountPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *PrivateEndpointConnectionsClientListByDatabaseAccountPager) NextPage(ctx context.Context) (PrivateEndpointConnectionsClientListByDatabaseAccountResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return PrivateEndpointConnectionsClientListByDatabaseAccountResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PrivateEndpointConnectionsClientListByDatabaseAccountResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PrivateEndpointConnectionsClientListByDatabaseAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PrivateEndpointConnectionsClientListByDatabaseAccountResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByDatabaseAccountHandleResponse(resp)
	if err != nil {
		return PrivateEndpointConnectionsClientListByDatabaseAccountResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PrivateLinkResourcesClientListByDatabaseAccountPager provides operations for iterating over paged responses.
type PrivateLinkResourcesClientListByDatabaseAccountPager struct {
	client    *PrivateLinkResourcesClient
	current   PrivateLinkResourcesClientListByDatabaseAccountResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PrivateLinkResourcesClientListByDatabaseAccountPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *PrivateLinkResourcesClientListByDatabaseAccountPager) NextPage(ctx context.Context) (PrivateLinkResourcesClientListByDatabaseAccountResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return PrivateLinkResourcesClientListByDatabaseAccountResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PrivateLinkResourcesClientListByDatabaseAccountResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PrivateLinkResourcesClientListByDatabaseAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PrivateLinkResourcesClientListByDatabaseAccountResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByDatabaseAccountHandleResponse(resp)
	if err != nil {
		return PrivateLinkResourcesClientListByDatabaseAccountResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RestorableDatabaseAccountsClientListByLocationPager provides operations for iterating over paged responses.
type RestorableDatabaseAccountsClientListByLocationPager struct {
	client    *RestorableDatabaseAccountsClient
	current   RestorableDatabaseAccountsClientListByLocationResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RestorableDatabaseAccountsClientListByLocationPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *RestorableDatabaseAccountsClientListByLocationPager) NextPage(ctx context.Context) (RestorableDatabaseAccountsClientListByLocationResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return RestorableDatabaseAccountsClientListByLocationResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RestorableDatabaseAccountsClientListByLocationResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RestorableDatabaseAccountsClientListByLocationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RestorableDatabaseAccountsClientListByLocationResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		return RestorableDatabaseAccountsClientListByLocationResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RestorableDatabaseAccountsClientListPager provides operations for iterating over paged responses.
type RestorableDatabaseAccountsClientListPager struct {
	client    *RestorableDatabaseAccountsClient
	current   RestorableDatabaseAccountsClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RestorableDatabaseAccountsClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *RestorableDatabaseAccountsClientListPager) NextPage(ctx context.Context) (RestorableDatabaseAccountsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return RestorableDatabaseAccountsClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RestorableDatabaseAccountsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RestorableDatabaseAccountsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RestorableDatabaseAccountsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return RestorableDatabaseAccountsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RestorableMongodbCollectionsClientListPager provides operations for iterating over paged responses.
type RestorableMongodbCollectionsClientListPager struct {
	client    *RestorableMongodbCollectionsClient
	current   RestorableMongodbCollectionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RestorableMongodbCollectionsClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *RestorableMongodbCollectionsClientListPager) NextPage(ctx context.Context) (RestorableMongodbCollectionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return RestorableMongodbCollectionsClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RestorableMongodbCollectionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RestorableMongodbCollectionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RestorableMongodbCollectionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return RestorableMongodbCollectionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RestorableMongodbDatabasesClientListPager provides operations for iterating over paged responses.
type RestorableMongodbDatabasesClientListPager struct {
	client    *RestorableMongodbDatabasesClient
	current   RestorableMongodbDatabasesClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RestorableMongodbDatabasesClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *RestorableMongodbDatabasesClientListPager) NextPage(ctx context.Context) (RestorableMongodbDatabasesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return RestorableMongodbDatabasesClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RestorableMongodbDatabasesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RestorableMongodbDatabasesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RestorableMongodbDatabasesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return RestorableMongodbDatabasesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RestorableMongodbResourcesClientListPager provides operations for iterating over paged responses.
type RestorableMongodbResourcesClientListPager struct {
	client    *RestorableMongodbResourcesClient
	current   RestorableMongodbResourcesClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RestorableMongodbResourcesClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *RestorableMongodbResourcesClientListPager) NextPage(ctx context.Context) (RestorableMongodbResourcesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return RestorableMongodbResourcesClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RestorableMongodbResourcesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RestorableMongodbResourcesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RestorableMongodbResourcesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return RestorableMongodbResourcesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RestorableSQLContainersClientListPager provides operations for iterating over paged responses.
type RestorableSQLContainersClientListPager struct {
	client    *RestorableSQLContainersClient
	current   RestorableSQLContainersClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RestorableSQLContainersClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *RestorableSQLContainersClientListPager) NextPage(ctx context.Context) (RestorableSQLContainersClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return RestorableSQLContainersClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RestorableSQLContainersClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RestorableSQLContainersClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RestorableSQLContainersClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return RestorableSQLContainersClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RestorableSQLDatabasesClientListPager provides operations for iterating over paged responses.
type RestorableSQLDatabasesClientListPager struct {
	client    *RestorableSQLDatabasesClient
	current   RestorableSQLDatabasesClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RestorableSQLDatabasesClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *RestorableSQLDatabasesClientListPager) NextPage(ctx context.Context) (RestorableSQLDatabasesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return RestorableSQLDatabasesClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RestorableSQLDatabasesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RestorableSQLDatabasesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RestorableSQLDatabasesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return RestorableSQLDatabasesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RestorableSQLResourcesClientListPager provides operations for iterating over paged responses.
type RestorableSQLResourcesClientListPager struct {
	client    *RestorableSQLResourcesClient
	current   RestorableSQLResourcesClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RestorableSQLResourcesClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *RestorableSQLResourcesClientListPager) NextPage(ctx context.Context) (RestorableSQLResourcesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return RestorableSQLResourcesClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RestorableSQLResourcesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RestorableSQLResourcesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RestorableSQLResourcesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return RestorableSQLResourcesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SQLResourcesClientListSQLContainersPager provides operations for iterating over paged responses.
type SQLResourcesClientListSQLContainersPager struct {
	client    *SQLResourcesClient
	current   SQLResourcesClientListSQLContainersResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SQLResourcesClientListSQLContainersPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *SQLResourcesClientListSQLContainersPager) NextPage(ctx context.Context) (SQLResourcesClientListSQLContainersResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return SQLResourcesClientListSQLContainersResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SQLResourcesClientListSQLContainersResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SQLResourcesClientListSQLContainersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SQLResourcesClientListSQLContainersResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listSQLContainersHandleResponse(resp)
	if err != nil {
		return SQLResourcesClientListSQLContainersResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SQLResourcesClientListSQLDatabasesPager provides operations for iterating over paged responses.
type SQLResourcesClientListSQLDatabasesPager struct {
	client    *SQLResourcesClient
	current   SQLResourcesClientListSQLDatabasesResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SQLResourcesClientListSQLDatabasesPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *SQLResourcesClientListSQLDatabasesPager) NextPage(ctx context.Context) (SQLResourcesClientListSQLDatabasesResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return SQLResourcesClientListSQLDatabasesResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SQLResourcesClientListSQLDatabasesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SQLResourcesClientListSQLDatabasesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SQLResourcesClientListSQLDatabasesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listSQLDatabasesHandleResponse(resp)
	if err != nil {
		return SQLResourcesClientListSQLDatabasesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SQLResourcesClientListSQLRoleAssignmentsPager provides operations for iterating over paged responses.
type SQLResourcesClientListSQLRoleAssignmentsPager struct {
	client    *SQLResourcesClient
	current   SQLResourcesClientListSQLRoleAssignmentsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SQLResourcesClientListSQLRoleAssignmentsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *SQLResourcesClientListSQLRoleAssignmentsPager) NextPage(ctx context.Context) (SQLResourcesClientListSQLRoleAssignmentsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return SQLResourcesClientListSQLRoleAssignmentsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SQLResourcesClientListSQLRoleAssignmentsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SQLResourcesClientListSQLRoleAssignmentsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SQLResourcesClientListSQLRoleAssignmentsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listSQLRoleAssignmentsHandleResponse(resp)
	if err != nil {
		return SQLResourcesClientListSQLRoleAssignmentsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SQLResourcesClientListSQLRoleDefinitionsPager provides operations for iterating over paged responses.
type SQLResourcesClientListSQLRoleDefinitionsPager struct {
	client    *SQLResourcesClient
	current   SQLResourcesClientListSQLRoleDefinitionsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SQLResourcesClientListSQLRoleDefinitionsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *SQLResourcesClientListSQLRoleDefinitionsPager) NextPage(ctx context.Context) (SQLResourcesClientListSQLRoleDefinitionsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return SQLResourcesClientListSQLRoleDefinitionsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SQLResourcesClientListSQLRoleDefinitionsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SQLResourcesClientListSQLRoleDefinitionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SQLResourcesClientListSQLRoleDefinitionsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listSQLRoleDefinitionsHandleResponse(resp)
	if err != nil {
		return SQLResourcesClientListSQLRoleDefinitionsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SQLResourcesClientListSQLStoredProceduresPager provides operations for iterating over paged responses.
type SQLResourcesClientListSQLStoredProceduresPager struct {
	client    *SQLResourcesClient
	current   SQLResourcesClientListSQLStoredProceduresResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SQLResourcesClientListSQLStoredProceduresPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *SQLResourcesClientListSQLStoredProceduresPager) NextPage(ctx context.Context) (SQLResourcesClientListSQLStoredProceduresResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return SQLResourcesClientListSQLStoredProceduresResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SQLResourcesClientListSQLStoredProceduresResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SQLResourcesClientListSQLStoredProceduresResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SQLResourcesClientListSQLStoredProceduresResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listSQLStoredProceduresHandleResponse(resp)
	if err != nil {
		return SQLResourcesClientListSQLStoredProceduresResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SQLResourcesClientListSQLTriggersPager provides operations for iterating over paged responses.
type SQLResourcesClientListSQLTriggersPager struct {
	client    *SQLResourcesClient
	current   SQLResourcesClientListSQLTriggersResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SQLResourcesClientListSQLTriggersPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *SQLResourcesClientListSQLTriggersPager) NextPage(ctx context.Context) (SQLResourcesClientListSQLTriggersResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return SQLResourcesClientListSQLTriggersResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SQLResourcesClientListSQLTriggersResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SQLResourcesClientListSQLTriggersResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SQLResourcesClientListSQLTriggersResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listSQLTriggersHandleResponse(resp)
	if err != nil {
		return SQLResourcesClientListSQLTriggersResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SQLResourcesClientListSQLUserDefinedFunctionsPager provides operations for iterating over paged responses.
type SQLResourcesClientListSQLUserDefinedFunctionsPager struct {
	client    *SQLResourcesClient
	current   SQLResourcesClientListSQLUserDefinedFunctionsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SQLResourcesClientListSQLUserDefinedFunctionsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *SQLResourcesClientListSQLUserDefinedFunctionsPager) NextPage(ctx context.Context) (SQLResourcesClientListSQLUserDefinedFunctionsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return SQLResourcesClientListSQLUserDefinedFunctionsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SQLResourcesClientListSQLUserDefinedFunctionsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SQLResourcesClientListSQLUserDefinedFunctionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SQLResourcesClientListSQLUserDefinedFunctionsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listSQLUserDefinedFunctionsHandleResponse(resp)
	if err != nil {
		return SQLResourcesClientListSQLUserDefinedFunctionsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TableResourcesClientListTablesPager provides operations for iterating over paged responses.
type TableResourcesClientListTablesPager struct {
	client    *TableResourcesClient
	current   TableResourcesClientListTablesResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TableResourcesClientListTablesPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *TableResourcesClientListTablesPager) NextPage(ctx context.Context) (TableResourcesClientListTablesResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return TableResourcesClientListTablesResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TableResourcesClientListTablesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TableResourcesClientListTablesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TableResourcesClientListTablesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listTablesHandleResponse(resp)
	if err != nil {
		return TableResourcesClientListTablesResponse{}, err
	}
	p.current = result
	return p.current, nil
}
