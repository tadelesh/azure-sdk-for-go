//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armdatashare

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AccountsClientListByResourceGroupPager provides operations for iterating over paged responses.
type AccountsClientListByResourceGroupPager struct {
	client    *AccountsClient
	current   AccountsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AccountsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AccountsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AccountList.NextLink == nil || len(*p.current.AccountList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AccountsClientListByResourceGroupPager) NextPage(ctx context.Context) (AccountsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AccountsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AccountsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AccountsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AccountsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return AccountsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AccountsClientListBySubscriptionPager provides operations for iterating over paged responses.
type AccountsClientListBySubscriptionPager struct {
	client    *AccountsClient
	current   AccountsClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AccountsClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AccountsClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AccountList.NextLink == nil || len(*p.current.AccountList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AccountsClientListBySubscriptionPager) NextPage(ctx context.Context) (AccountsClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AccountsClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AccountsClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AccountsClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AccountsClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return AccountsClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ConsumerInvitationsClientListInvitationsPager provides operations for iterating over paged responses.
type ConsumerInvitationsClientListInvitationsPager struct {
	client    *ConsumerInvitationsClient
	current   ConsumerInvitationsClientListInvitationsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ConsumerInvitationsClientListInvitationsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ConsumerInvitationsClientListInvitationsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ConsumerInvitationList.NextLink == nil || len(*p.current.ConsumerInvitationList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ConsumerInvitationsClientListInvitationsPager) NextPage(ctx context.Context) (ConsumerInvitationsClientListInvitationsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ConsumerInvitationsClientListInvitationsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ConsumerInvitationsClientListInvitationsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ConsumerInvitationsClientListInvitationsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ConsumerInvitationsClientListInvitationsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listInvitationsHandleResponse(resp)
	if err != nil {
		return ConsumerInvitationsClientListInvitationsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ConsumerSourceDataSetsClientListByShareSubscriptionPager provides operations for iterating over paged responses.
type ConsumerSourceDataSetsClientListByShareSubscriptionPager struct {
	client    *ConsumerSourceDataSetsClient
	current   ConsumerSourceDataSetsClientListByShareSubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ConsumerSourceDataSetsClientListByShareSubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ConsumerSourceDataSetsClientListByShareSubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ConsumerSourceDataSetList.NextLink == nil || len(*p.current.ConsumerSourceDataSetList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ConsumerSourceDataSetsClientListByShareSubscriptionPager) NextPage(ctx context.Context) (ConsumerSourceDataSetsClientListByShareSubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ConsumerSourceDataSetsClientListByShareSubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ConsumerSourceDataSetsClientListByShareSubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ConsumerSourceDataSetsClientListByShareSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ConsumerSourceDataSetsClientListByShareSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByShareSubscriptionHandleResponse(resp)
	if err != nil {
		return ConsumerSourceDataSetsClientListByShareSubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DataSetMappingsClientListByShareSubscriptionPager provides operations for iterating over paged responses.
type DataSetMappingsClientListByShareSubscriptionPager struct {
	client    *DataSetMappingsClient
	current   DataSetMappingsClientListByShareSubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DataSetMappingsClientListByShareSubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DataSetMappingsClientListByShareSubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DataSetMappingList.NextLink == nil || len(*p.current.DataSetMappingList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DataSetMappingsClientListByShareSubscriptionPager) NextPage(ctx context.Context) (DataSetMappingsClientListByShareSubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DataSetMappingsClientListByShareSubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DataSetMappingsClientListByShareSubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DataSetMappingsClientListByShareSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DataSetMappingsClientListByShareSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByShareSubscriptionHandleResponse(resp)
	if err != nil {
		return DataSetMappingsClientListByShareSubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DataSetsClientListBySharePager provides operations for iterating over paged responses.
type DataSetsClientListBySharePager struct {
	client    *DataSetsClient
	current   DataSetsClientListByShareResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DataSetsClientListByShareResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DataSetsClientListBySharePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DataSetList.NextLink == nil || len(*p.current.DataSetList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DataSetsClientListBySharePager) NextPage(ctx context.Context) (DataSetsClientListByShareResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DataSetsClientListByShareResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DataSetsClientListByShareResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DataSetsClientListByShareResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DataSetsClientListByShareResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByShareHandleResponse(resp)
	if err != nil {
		return DataSetsClientListByShareResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// InvitationsClientListBySharePager provides operations for iterating over paged responses.
type InvitationsClientListBySharePager struct {
	client    *InvitationsClient
	current   InvitationsClientListByShareResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InvitationsClientListByShareResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *InvitationsClientListBySharePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InvitationList.NextLink == nil || len(*p.current.InvitationList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *InvitationsClientListBySharePager) NextPage(ctx context.Context) (InvitationsClientListByShareResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return InvitationsClientListByShareResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return InvitationsClientListByShareResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return InvitationsClientListByShareResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return InvitationsClientListByShareResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByShareHandleResponse(resp)
	if err != nil {
		return InvitationsClientListByShareResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *OperationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationList.NextLink == nil || len(*p.current.OperationList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *OperationsClientListPager) NextPage(ctx context.Context) (OperationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return OperationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return OperationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProviderShareSubscriptionsClientListBySharePager provides operations for iterating over paged responses.
type ProviderShareSubscriptionsClientListBySharePager struct {
	client    *ProviderShareSubscriptionsClient
	current   ProviderShareSubscriptionsClientListByShareResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProviderShareSubscriptionsClientListByShareResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProviderShareSubscriptionsClientListBySharePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProviderShareSubscriptionList.NextLink == nil || len(*p.current.ProviderShareSubscriptionList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProviderShareSubscriptionsClientListBySharePager) NextPage(ctx context.Context) (ProviderShareSubscriptionsClientListByShareResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProviderShareSubscriptionsClientListByShareResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProviderShareSubscriptionsClientListByShareResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProviderShareSubscriptionsClientListByShareResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProviderShareSubscriptionsClientListByShareResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByShareHandleResponse(resp)
	if err != nil {
		return ProviderShareSubscriptionsClientListByShareResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ShareSubscriptionsClientListByAccountPager provides operations for iterating over paged responses.
type ShareSubscriptionsClientListByAccountPager struct {
	client    *ShareSubscriptionsClient
	current   ShareSubscriptionsClientListByAccountResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ShareSubscriptionsClientListByAccountResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ShareSubscriptionsClientListByAccountPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ShareSubscriptionList.NextLink == nil || len(*p.current.ShareSubscriptionList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ShareSubscriptionsClientListByAccountPager) NextPage(ctx context.Context) (ShareSubscriptionsClientListByAccountResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ShareSubscriptionsClientListByAccountResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ShareSubscriptionsClientListByAccountResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ShareSubscriptionsClientListByAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ShareSubscriptionsClientListByAccountResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByAccountHandleResponse(resp)
	if err != nil {
		return ShareSubscriptionsClientListByAccountResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ShareSubscriptionsClientListSourceShareSynchronizationSettingsPager provides operations for iterating over paged responses.
type ShareSubscriptionsClientListSourceShareSynchronizationSettingsPager struct {
	client    *ShareSubscriptionsClient
	current   ShareSubscriptionsClientListSourceShareSynchronizationSettingsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ShareSubscriptionsClientListSourceShareSynchronizationSettingsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ShareSubscriptionsClientListSourceShareSynchronizationSettingsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SourceShareSynchronizationSettingList.NextLink == nil || len(*p.current.SourceShareSynchronizationSettingList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ShareSubscriptionsClientListSourceShareSynchronizationSettingsPager) NextPage(ctx context.Context) (ShareSubscriptionsClientListSourceShareSynchronizationSettingsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ShareSubscriptionsClientListSourceShareSynchronizationSettingsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ShareSubscriptionsClientListSourceShareSynchronizationSettingsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ShareSubscriptionsClientListSourceShareSynchronizationSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ShareSubscriptionsClientListSourceShareSynchronizationSettingsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listSourceShareSynchronizationSettingsHandleResponse(resp)
	if err != nil {
		return ShareSubscriptionsClientListSourceShareSynchronizationSettingsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ShareSubscriptionsClientListSynchronizationDetailsPager provides operations for iterating over paged responses.
type ShareSubscriptionsClientListSynchronizationDetailsPager struct {
	client    *ShareSubscriptionsClient
	current   ShareSubscriptionsClientListSynchronizationDetailsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ShareSubscriptionsClientListSynchronizationDetailsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ShareSubscriptionsClientListSynchronizationDetailsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SynchronizationDetailsList.NextLink == nil || len(*p.current.SynchronizationDetailsList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ShareSubscriptionsClientListSynchronizationDetailsPager) NextPage(ctx context.Context) (ShareSubscriptionsClientListSynchronizationDetailsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ShareSubscriptionsClientListSynchronizationDetailsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ShareSubscriptionsClientListSynchronizationDetailsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ShareSubscriptionsClientListSynchronizationDetailsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ShareSubscriptionsClientListSynchronizationDetailsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listSynchronizationDetailsHandleResponse(resp)
	if err != nil {
		return ShareSubscriptionsClientListSynchronizationDetailsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ShareSubscriptionsClientListSynchronizationsPager provides operations for iterating over paged responses.
type ShareSubscriptionsClientListSynchronizationsPager struct {
	client    *ShareSubscriptionsClient
	current   ShareSubscriptionsClientListSynchronizationsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ShareSubscriptionsClientListSynchronizationsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ShareSubscriptionsClientListSynchronizationsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ShareSubscriptionSynchronizationList.NextLink == nil || len(*p.current.ShareSubscriptionSynchronizationList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ShareSubscriptionsClientListSynchronizationsPager) NextPage(ctx context.Context) (ShareSubscriptionsClientListSynchronizationsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ShareSubscriptionsClientListSynchronizationsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ShareSubscriptionsClientListSynchronizationsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ShareSubscriptionsClientListSynchronizationsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ShareSubscriptionsClientListSynchronizationsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listSynchronizationsHandleResponse(resp)
	if err != nil {
		return ShareSubscriptionsClientListSynchronizationsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SharesClientListByAccountPager provides operations for iterating over paged responses.
type SharesClientListByAccountPager struct {
	client    *SharesClient
	current   SharesClientListByAccountResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SharesClientListByAccountResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SharesClientListByAccountPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ShareList.NextLink == nil || len(*p.current.ShareList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SharesClientListByAccountPager) NextPage(ctx context.Context) (SharesClientListByAccountResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SharesClientListByAccountResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SharesClientListByAccountResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SharesClientListByAccountResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SharesClientListByAccountResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByAccountHandleResponse(resp)
	if err != nil {
		return SharesClientListByAccountResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SharesClientListSynchronizationDetailsPager provides operations for iterating over paged responses.
type SharesClientListSynchronizationDetailsPager struct {
	client    *SharesClient
	current   SharesClientListSynchronizationDetailsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SharesClientListSynchronizationDetailsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SharesClientListSynchronizationDetailsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SynchronizationDetailsList.NextLink == nil || len(*p.current.SynchronizationDetailsList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SharesClientListSynchronizationDetailsPager) NextPage(ctx context.Context) (SharesClientListSynchronizationDetailsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SharesClientListSynchronizationDetailsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SharesClientListSynchronizationDetailsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SharesClientListSynchronizationDetailsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SharesClientListSynchronizationDetailsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listSynchronizationDetailsHandleResponse(resp)
	if err != nil {
		return SharesClientListSynchronizationDetailsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SharesClientListSynchronizationsPager provides operations for iterating over paged responses.
type SharesClientListSynchronizationsPager struct {
	client    *SharesClient
	current   SharesClientListSynchronizationsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SharesClientListSynchronizationsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SharesClientListSynchronizationsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ShareSynchronizationList.NextLink == nil || len(*p.current.ShareSynchronizationList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SharesClientListSynchronizationsPager) NextPage(ctx context.Context) (SharesClientListSynchronizationsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SharesClientListSynchronizationsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SharesClientListSynchronizationsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SharesClientListSynchronizationsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SharesClientListSynchronizationsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listSynchronizationsHandleResponse(resp)
	if err != nil {
		return SharesClientListSynchronizationsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SynchronizationSettingsClientListBySharePager provides operations for iterating over paged responses.
type SynchronizationSettingsClientListBySharePager struct {
	client    *SynchronizationSettingsClient
	current   SynchronizationSettingsClientListByShareResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SynchronizationSettingsClientListByShareResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SynchronizationSettingsClientListBySharePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SynchronizationSettingList.NextLink == nil || len(*p.current.SynchronizationSettingList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SynchronizationSettingsClientListBySharePager) NextPage(ctx context.Context) (SynchronizationSettingsClientListByShareResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SynchronizationSettingsClientListByShareResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SynchronizationSettingsClientListByShareResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SynchronizationSettingsClientListByShareResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SynchronizationSettingsClientListByShareResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByShareHandleResponse(resp)
	if err != nil {
		return SynchronizationSettingsClientListByShareResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TriggersClientListByShareSubscriptionPager provides operations for iterating over paged responses.
type TriggersClientListByShareSubscriptionPager struct {
	client    *TriggersClient
	current   TriggersClientListByShareSubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TriggersClientListByShareSubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TriggersClientListByShareSubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TriggerList.NextLink == nil || len(*p.current.TriggerList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *TriggersClientListByShareSubscriptionPager) NextPage(ctx context.Context) (TriggersClientListByShareSubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return TriggersClientListByShareSubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TriggersClientListByShareSubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TriggersClientListByShareSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TriggersClientListByShareSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByShareSubscriptionHandleResponse(resp)
	if err != nil {
		return TriggersClientListByShareSubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}
