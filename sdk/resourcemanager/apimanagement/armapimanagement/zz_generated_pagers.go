//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armapimanagement

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// APIClientListByServicePager provides operations for iterating over paged responses.
type APIClientListByServicePager struct {
	client    *APIClient
	current   APIClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *APIClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APICollection.NextLink == nil || len(*p.current.APICollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *APIClientListByServicePager) NextPage(ctx context.Context) (APIClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return APIClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return APIClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return APIClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return APIClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return APIClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// APIClientListByTagsPager provides operations for iterating over paged responses.
type APIClientListByTagsPager struct {
	client    *APIClient
	current   APIClientListByTagsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIClientListByTagsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *APIClientListByTagsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagResourceCollection.NextLink == nil || len(*p.current.TagResourceCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *APIClientListByTagsPager) NextPage(ctx context.Context) (APIClientListByTagsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return APIClientListByTagsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return APIClientListByTagsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return APIClientListByTagsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return APIClientListByTagsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByTagsHandleResponse(resp)
	if err != nil {
		return APIClientListByTagsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// APIDiagnosticClientListByServicePager provides operations for iterating over paged responses.
type APIDiagnosticClientListByServicePager struct {
	client    *APIDiagnosticClient
	current   APIDiagnosticClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIDiagnosticClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *APIDiagnosticClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiagnosticCollection.NextLink == nil || len(*p.current.DiagnosticCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *APIDiagnosticClientListByServicePager) NextPage(ctx context.Context) (APIDiagnosticClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return APIDiagnosticClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return APIDiagnosticClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return APIDiagnosticClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return APIDiagnosticClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return APIDiagnosticClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// APIIssueAttachmentClientListByServicePager provides operations for iterating over paged responses.
type APIIssueAttachmentClientListByServicePager struct {
	client    *APIIssueAttachmentClient
	current   APIIssueAttachmentClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIIssueAttachmentClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *APIIssueAttachmentClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IssueAttachmentCollection.NextLink == nil || len(*p.current.IssueAttachmentCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *APIIssueAttachmentClientListByServicePager) NextPage(ctx context.Context) (APIIssueAttachmentClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return APIIssueAttachmentClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return APIIssueAttachmentClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return APIIssueAttachmentClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return APIIssueAttachmentClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return APIIssueAttachmentClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// APIIssueClientListByServicePager provides operations for iterating over paged responses.
type APIIssueClientListByServicePager struct {
	client    *APIIssueClient
	current   APIIssueClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIIssueClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *APIIssueClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IssueCollection.NextLink == nil || len(*p.current.IssueCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *APIIssueClientListByServicePager) NextPage(ctx context.Context) (APIIssueClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return APIIssueClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return APIIssueClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return APIIssueClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return APIIssueClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return APIIssueClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// APIIssueCommentClientListByServicePager provides operations for iterating over paged responses.
type APIIssueCommentClientListByServicePager struct {
	client    *APIIssueCommentClient
	current   APIIssueCommentClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIIssueCommentClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *APIIssueCommentClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IssueCommentCollection.NextLink == nil || len(*p.current.IssueCommentCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *APIIssueCommentClientListByServicePager) NextPage(ctx context.Context) (APIIssueCommentClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return APIIssueCommentClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return APIIssueCommentClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return APIIssueCommentClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return APIIssueCommentClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return APIIssueCommentClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// APIOperationClientListByAPIPager provides operations for iterating over paged responses.
type APIOperationClientListByAPIPager struct {
	client    *APIOperationClient
	current   APIOperationClientListByAPIResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIOperationClientListByAPIResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *APIOperationClientListByAPIPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationCollection.NextLink == nil || len(*p.current.OperationCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *APIOperationClientListByAPIPager) NextPage(ctx context.Context) (APIOperationClientListByAPIResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return APIOperationClientListByAPIResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return APIOperationClientListByAPIResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return APIOperationClientListByAPIResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return APIOperationClientListByAPIResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByAPIHandleResponse(resp)
	if err != nil {
		return APIOperationClientListByAPIResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// APIProductClientListByApisPager provides operations for iterating over paged responses.
type APIProductClientListByApisPager struct {
	client    *APIProductClient
	current   APIProductClientListByApisResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIProductClientListByApisResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *APIProductClientListByApisPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductCollection.NextLink == nil || len(*p.current.ProductCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *APIProductClientListByApisPager) NextPage(ctx context.Context) (APIProductClientListByApisResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return APIProductClientListByApisResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return APIProductClientListByApisResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return APIProductClientListByApisResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return APIProductClientListByApisResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByApisHandleResponse(resp)
	if err != nil {
		return APIProductClientListByApisResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// APIReleaseClientListByServicePager provides operations for iterating over paged responses.
type APIReleaseClientListByServicePager struct {
	client    *APIReleaseClient
	current   APIReleaseClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIReleaseClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *APIReleaseClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APIReleaseCollection.NextLink == nil || len(*p.current.APIReleaseCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *APIReleaseClientListByServicePager) NextPage(ctx context.Context) (APIReleaseClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return APIReleaseClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return APIReleaseClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return APIReleaseClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return APIReleaseClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return APIReleaseClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// APIRevisionClientListByServicePager provides operations for iterating over paged responses.
type APIRevisionClientListByServicePager struct {
	client    *APIRevisionClient
	current   APIRevisionClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIRevisionClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *APIRevisionClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APIRevisionCollection.NextLink == nil || len(*p.current.APIRevisionCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *APIRevisionClientListByServicePager) NextPage(ctx context.Context) (APIRevisionClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return APIRevisionClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return APIRevisionClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return APIRevisionClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return APIRevisionClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return APIRevisionClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// APISchemaClientListByAPIPager provides operations for iterating over paged responses.
type APISchemaClientListByAPIPager struct {
	client    *APISchemaClient
	current   APISchemaClientListByAPIResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APISchemaClientListByAPIResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *APISchemaClientListByAPIPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SchemaCollection.NextLink == nil || len(*p.current.SchemaCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *APISchemaClientListByAPIPager) NextPage(ctx context.Context) (APISchemaClientListByAPIResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return APISchemaClientListByAPIResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return APISchemaClientListByAPIResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return APISchemaClientListByAPIResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return APISchemaClientListByAPIResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByAPIHandleResponse(resp)
	if err != nil {
		return APISchemaClientListByAPIResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// APITagDescriptionClientListByServicePager provides operations for iterating over paged responses.
type APITagDescriptionClientListByServicePager struct {
	client    *APITagDescriptionClient
	current   APITagDescriptionClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APITagDescriptionClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *APITagDescriptionClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagDescriptionCollection.NextLink == nil || len(*p.current.TagDescriptionCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *APITagDescriptionClientListByServicePager) NextPage(ctx context.Context) (APITagDescriptionClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return APITagDescriptionClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return APITagDescriptionClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return APITagDescriptionClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return APITagDescriptionClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return APITagDescriptionClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// APIVersionSetClientListByServicePager provides operations for iterating over paged responses.
type APIVersionSetClientListByServicePager struct {
	client    *APIVersionSetClient
	current   APIVersionSetClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, APIVersionSetClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *APIVersionSetClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APIVersionSetCollection.NextLink == nil || len(*p.current.APIVersionSetCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *APIVersionSetClientListByServicePager) NextPage(ctx context.Context) (APIVersionSetClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return APIVersionSetClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return APIVersionSetClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return APIVersionSetClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return APIVersionSetClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return APIVersionSetClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AuthorizationServerClientListByServicePager provides operations for iterating over paged responses.
type AuthorizationServerClientListByServicePager struct {
	client    *AuthorizationServerClient
	current   AuthorizationServerClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AuthorizationServerClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AuthorizationServerClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AuthorizationServerCollection.NextLink == nil || len(*p.current.AuthorizationServerCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AuthorizationServerClientListByServicePager) NextPage(ctx context.Context) (AuthorizationServerClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AuthorizationServerClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AuthorizationServerClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AuthorizationServerClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AuthorizationServerClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return AuthorizationServerClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BackendClientListByServicePager provides operations for iterating over paged responses.
type BackendClientListByServicePager struct {
	client    *BackendClient
	current   BackendClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BackendClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BackendClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BackendCollection.NextLink == nil || len(*p.current.BackendCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *BackendClientListByServicePager) NextPage(ctx context.Context) (BackendClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return BackendClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BackendClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BackendClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BackendClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return BackendClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CacheClientListByServicePager provides operations for iterating over paged responses.
type CacheClientListByServicePager struct {
	client    *CacheClient
	current   CacheClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CacheClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CacheClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CacheCollection.NextLink == nil || len(*p.current.CacheCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CacheClientListByServicePager) NextPage(ctx context.Context) (CacheClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CacheClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CacheClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CacheClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CacheClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return CacheClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CertificateClientListByServicePager provides operations for iterating over paged responses.
type CertificateClientListByServicePager struct {
	client    *CertificateClient
	current   CertificateClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CertificateClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CertificateClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CertificateCollection.NextLink == nil || len(*p.current.CertificateCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CertificateClientListByServicePager) NextPage(ctx context.Context) (CertificateClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CertificateClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CertificateClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CertificateClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CertificateClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return CertificateClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ContentItemClientListByServicePager provides operations for iterating over paged responses.
type ContentItemClientListByServicePager struct {
	client    *ContentItemClient
	current   ContentItemClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ContentItemClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ContentItemClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ContentItemCollection.NextLink == nil || len(*p.current.ContentItemCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ContentItemClientListByServicePager) NextPage(ctx context.Context) (ContentItemClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ContentItemClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ContentItemClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ContentItemClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ContentItemClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return ContentItemClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ContentTypeClientListByServicePager provides operations for iterating over paged responses.
type ContentTypeClientListByServicePager struct {
	client    *ContentTypeClient
	current   ContentTypeClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ContentTypeClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ContentTypeClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ContentTypeCollection.NextLink == nil || len(*p.current.ContentTypeCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ContentTypeClientListByServicePager) NextPage(ctx context.Context) (ContentTypeClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ContentTypeClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ContentTypeClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ContentTypeClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ContentTypeClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return ContentTypeClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DeletedServicesClientListBySubscriptionPager provides operations for iterating over paged responses.
type DeletedServicesClientListBySubscriptionPager struct {
	client    *DeletedServicesClient
	current   DeletedServicesClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DeletedServicesClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DeletedServicesClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DeletedServicesCollection.NextLink == nil || len(*p.current.DeletedServicesCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DeletedServicesClientListBySubscriptionPager) NextPage(ctx context.Context) (DeletedServicesClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DeletedServicesClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DeletedServicesClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DeletedServicesClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DeletedServicesClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return DeletedServicesClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DiagnosticClientListByServicePager provides operations for iterating over paged responses.
type DiagnosticClientListByServicePager struct {
	client    *DiagnosticClient
	current   DiagnosticClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiagnosticClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DiagnosticClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiagnosticCollection.NextLink == nil || len(*p.current.DiagnosticCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DiagnosticClientListByServicePager) NextPage(ctx context.Context) (DiagnosticClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DiagnosticClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DiagnosticClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DiagnosticClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DiagnosticClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return DiagnosticClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// EmailTemplateClientListByServicePager provides operations for iterating over paged responses.
type EmailTemplateClientListByServicePager struct {
	client    *EmailTemplateClient
	current   EmailTemplateClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EmailTemplateClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *EmailTemplateClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EmailTemplateCollection.NextLink == nil || len(*p.current.EmailTemplateCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *EmailTemplateClientListByServicePager) NextPage(ctx context.Context) (EmailTemplateClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return EmailTemplateClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return EmailTemplateClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return EmailTemplateClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return EmailTemplateClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return EmailTemplateClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GatewayAPIClientListByServicePager provides operations for iterating over paged responses.
type GatewayAPIClientListByServicePager struct {
	client    *GatewayAPIClient
	current   GatewayAPIClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GatewayAPIClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GatewayAPIClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APICollection.NextLink == nil || len(*p.current.APICollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GatewayAPIClientListByServicePager) NextPage(ctx context.Context) (GatewayAPIClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GatewayAPIClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GatewayAPIClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GatewayAPIClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GatewayAPIClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return GatewayAPIClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GatewayCertificateAuthorityClientListByServicePager provides operations for iterating over paged responses.
type GatewayCertificateAuthorityClientListByServicePager struct {
	client    *GatewayCertificateAuthorityClient
	current   GatewayCertificateAuthorityClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GatewayCertificateAuthorityClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GatewayCertificateAuthorityClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GatewayCertificateAuthorityCollection.NextLink == nil || len(*p.current.GatewayCertificateAuthorityCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GatewayCertificateAuthorityClientListByServicePager) NextPage(ctx context.Context) (GatewayCertificateAuthorityClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GatewayCertificateAuthorityClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GatewayCertificateAuthorityClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GatewayCertificateAuthorityClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GatewayCertificateAuthorityClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return GatewayCertificateAuthorityClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GatewayClientListByServicePager provides operations for iterating over paged responses.
type GatewayClientListByServicePager struct {
	client    *GatewayClient
	current   GatewayClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GatewayClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GatewayClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GatewayCollection.NextLink == nil || len(*p.current.GatewayCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GatewayClientListByServicePager) NextPage(ctx context.Context) (GatewayClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GatewayClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GatewayClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GatewayClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GatewayClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return GatewayClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GatewayHostnameConfigurationClientListByServicePager provides operations for iterating over paged responses.
type GatewayHostnameConfigurationClientListByServicePager struct {
	client    *GatewayHostnameConfigurationClient
	current   GatewayHostnameConfigurationClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GatewayHostnameConfigurationClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GatewayHostnameConfigurationClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GatewayHostnameConfigurationCollection.NextLink == nil || len(*p.current.GatewayHostnameConfigurationCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GatewayHostnameConfigurationClientListByServicePager) NextPage(ctx context.Context) (GatewayHostnameConfigurationClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GatewayHostnameConfigurationClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GatewayHostnameConfigurationClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GatewayHostnameConfigurationClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GatewayHostnameConfigurationClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return GatewayHostnameConfigurationClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GlobalSchemaClientListByServicePager provides operations for iterating over paged responses.
type GlobalSchemaClientListByServicePager struct {
	client    *GlobalSchemaClient
	current   GlobalSchemaClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GlobalSchemaClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GlobalSchemaClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GlobalSchemaCollection.NextLink == nil || len(*p.current.GlobalSchemaCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GlobalSchemaClientListByServicePager) NextPage(ctx context.Context) (GlobalSchemaClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GlobalSchemaClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GlobalSchemaClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GlobalSchemaClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GlobalSchemaClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return GlobalSchemaClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GroupClientListByServicePager provides operations for iterating over paged responses.
type GroupClientListByServicePager struct {
	client    *GroupClient
	current   GroupClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GroupClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GroupClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GroupCollection.NextLink == nil || len(*p.current.GroupCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GroupClientListByServicePager) NextPage(ctx context.Context) (GroupClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GroupClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GroupClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GroupClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GroupClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return GroupClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GroupUserClientListPager provides operations for iterating over paged responses.
type GroupUserClientListPager struct {
	client    *GroupUserClient
	current   GroupUserClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GroupUserClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GroupUserClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UserCollection.NextLink == nil || len(*p.current.UserCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GroupUserClientListPager) NextPage(ctx context.Context) (GroupUserClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GroupUserClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GroupUserClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GroupUserClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GroupUserClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return GroupUserClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IdentityProviderClientListByServicePager provides operations for iterating over paged responses.
type IdentityProviderClientListByServicePager struct {
	client    *IdentityProviderClient
	current   IdentityProviderClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IdentityProviderClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IdentityProviderClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IdentityProviderList.NextLink == nil || len(*p.current.IdentityProviderList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IdentityProviderClientListByServicePager) NextPage(ctx context.Context) (IdentityProviderClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IdentityProviderClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IdentityProviderClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IdentityProviderClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IdentityProviderClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return IdentityProviderClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// IssueClientListByServicePager provides operations for iterating over paged responses.
type IssueClientListByServicePager struct {
	client    *IssueClient
	current   IssueClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, IssueClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *IssueClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.IssueCollection.NextLink == nil || len(*p.current.IssueCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *IssueClientListByServicePager) NextPage(ctx context.Context) (IssueClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return IssueClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return IssueClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return IssueClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return IssueClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return IssueClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// LoggerClientListByServicePager provides operations for iterating over paged responses.
type LoggerClientListByServicePager struct {
	client    *LoggerClient
	current   LoggerClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LoggerClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *LoggerClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LoggerCollection.NextLink == nil || len(*p.current.LoggerCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *LoggerClientListByServicePager) NextPage(ctx context.Context) (LoggerClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return LoggerClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return LoggerClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return LoggerClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return LoggerClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return LoggerClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// NamedValueClientListByServicePager provides operations for iterating over paged responses.
type NamedValueClientListByServicePager struct {
	client    *NamedValueClient
	current   NamedValueClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NamedValueClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *NamedValueClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NamedValueCollection.NextLink == nil || len(*p.current.NamedValueCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *NamedValueClientListByServicePager) NextPage(ctx context.Context) (NamedValueClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return NamedValueClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return NamedValueClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return NamedValueClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return NamedValueClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return NamedValueClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// NotificationClientListByServicePager provides operations for iterating over paged responses.
type NotificationClientListByServicePager struct {
	client    *NotificationClient
	current   NotificationClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, NotificationClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *NotificationClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.NotificationCollection.NextLink == nil || len(*p.current.NotificationCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *NotificationClientListByServicePager) NextPage(ctx context.Context) (NotificationClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return NotificationClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return NotificationClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return NotificationClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return NotificationClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return NotificationClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// OpenIDConnectProviderClientListByServicePager provides operations for iterating over paged responses.
type OpenIDConnectProviderClientListByServicePager struct {
	client    *OpenIDConnectProviderClient
	current   OpenIDConnectProviderClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OpenIDConnectProviderClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *OpenIDConnectProviderClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OpenIDConnectProviderCollection.NextLink == nil || len(*p.current.OpenIDConnectProviderCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *OpenIDConnectProviderClientListByServicePager) NextPage(ctx context.Context) (OpenIDConnectProviderClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return OpenIDConnectProviderClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return OpenIDConnectProviderClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return OpenIDConnectProviderClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return OpenIDConnectProviderClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return OpenIDConnectProviderClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// OperationClientListByTagsPager provides operations for iterating over paged responses.
type OperationClientListByTagsPager struct {
	client    *OperationClient
	current   OperationClientListByTagsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationClientListByTagsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *OperationClientListByTagsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagResourceCollection.NextLink == nil || len(*p.current.TagResourceCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *OperationClientListByTagsPager) NextPage(ctx context.Context) (OperationClientListByTagsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return OperationClientListByTagsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return OperationClientListByTagsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return OperationClientListByTagsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return OperationClientListByTagsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByTagsHandleResponse(resp)
	if err != nil {
		return OperationClientListByTagsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *OperationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *OperationsClientListPager) NextPage(ctx context.Context) (OperationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return OperationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return OperationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PortalRevisionClientListByServicePager provides operations for iterating over paged responses.
type PortalRevisionClientListByServicePager struct {
	client    *PortalRevisionClient
	current   PortalRevisionClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PortalRevisionClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PortalRevisionClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PortalRevisionCollection.NextLink == nil || len(*p.current.PortalRevisionCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PortalRevisionClientListByServicePager) NextPage(ctx context.Context) (PortalRevisionClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PortalRevisionClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PortalRevisionClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PortalRevisionClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PortalRevisionClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return PortalRevisionClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PrivateEndpointConnectionClientListByServicePager provides operations for iterating over paged responses.
type PrivateEndpointConnectionClientListByServicePager struct {
	client    *PrivateEndpointConnectionClient
	current   PrivateEndpointConnectionClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PrivateEndpointConnectionClientListByServicePager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *PrivateEndpointConnectionClientListByServicePager) NextPage(ctx context.Context) (PrivateEndpointConnectionClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return PrivateEndpointConnectionClientListByServiceResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PrivateEndpointConnectionClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PrivateEndpointConnectionClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PrivateEndpointConnectionClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return PrivateEndpointConnectionClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProductAPIClientListByProductPager provides operations for iterating over paged responses.
type ProductAPIClientListByProductPager struct {
	client    *ProductAPIClient
	current   ProductAPIClientListByProductResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductAPIClientListByProductResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProductAPIClientListByProductPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.APICollection.NextLink == nil || len(*p.current.APICollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProductAPIClientListByProductPager) NextPage(ctx context.Context) (ProductAPIClientListByProductResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProductAPIClientListByProductResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProductAPIClientListByProductResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProductAPIClientListByProductResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProductAPIClientListByProductResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByProductHandleResponse(resp)
	if err != nil {
		return ProductAPIClientListByProductResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProductClientListByServicePager provides operations for iterating over paged responses.
type ProductClientListByServicePager struct {
	client    *ProductClient
	current   ProductClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProductClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProductCollection.NextLink == nil || len(*p.current.ProductCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProductClientListByServicePager) NextPage(ctx context.Context) (ProductClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProductClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProductClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProductClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProductClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return ProductClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProductClientListByTagsPager provides operations for iterating over paged responses.
type ProductClientListByTagsPager struct {
	client    *ProductClient
	current   ProductClientListByTagsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductClientListByTagsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProductClientListByTagsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagResourceCollection.NextLink == nil || len(*p.current.TagResourceCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProductClientListByTagsPager) NextPage(ctx context.Context) (ProductClientListByTagsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProductClientListByTagsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProductClientListByTagsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProductClientListByTagsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProductClientListByTagsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByTagsHandleResponse(resp)
	if err != nil {
		return ProductClientListByTagsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProductGroupClientListByProductPager provides operations for iterating over paged responses.
type ProductGroupClientListByProductPager struct {
	client    *ProductGroupClient
	current   ProductGroupClientListByProductResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductGroupClientListByProductResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProductGroupClientListByProductPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GroupCollection.NextLink == nil || len(*p.current.GroupCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProductGroupClientListByProductPager) NextPage(ctx context.Context) (ProductGroupClientListByProductResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProductGroupClientListByProductResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProductGroupClientListByProductResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProductGroupClientListByProductResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProductGroupClientListByProductResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByProductHandleResponse(resp)
	if err != nil {
		return ProductGroupClientListByProductResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProductSubscriptionsClientListPager provides operations for iterating over paged responses.
type ProductSubscriptionsClientListPager struct {
	client    *ProductSubscriptionsClient
	current   ProductSubscriptionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProductSubscriptionsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProductSubscriptionsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubscriptionCollection.NextLink == nil || len(*p.current.SubscriptionCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProductSubscriptionsClientListPager) NextPage(ctx context.Context) (ProductSubscriptionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProductSubscriptionsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProductSubscriptionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProductSubscriptionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProductSubscriptionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ProductSubscriptionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RegionClientListByServicePager provides operations for iterating over paged responses.
type RegionClientListByServicePager struct {
	client    *RegionClient
	current   RegionClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RegionClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RegionClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RegionListResult.NextLink == nil || len(*p.current.RegionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RegionClientListByServicePager) NextPage(ctx context.Context) (RegionClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RegionClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RegionClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RegionClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RegionClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return RegionClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ReportsClientListByAPIPager provides operations for iterating over paged responses.
type ReportsClientListByAPIPager struct {
	client    *ReportsClient
	current   ReportsClientListByAPIResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReportsClientListByAPIResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ReportsClientListByAPIPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReportCollection.NextLink == nil || len(*p.current.ReportCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ReportsClientListByAPIPager) NextPage(ctx context.Context) (ReportsClientListByAPIResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ReportsClientListByAPIResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ReportsClientListByAPIResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ReportsClientListByAPIResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ReportsClientListByAPIResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByAPIHandleResponse(resp)
	if err != nil {
		return ReportsClientListByAPIResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ReportsClientListByGeoPager provides operations for iterating over paged responses.
type ReportsClientListByGeoPager struct {
	client    *ReportsClient
	current   ReportsClientListByGeoResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReportsClientListByGeoResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ReportsClientListByGeoPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReportCollection.NextLink == nil || len(*p.current.ReportCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ReportsClientListByGeoPager) NextPage(ctx context.Context) (ReportsClientListByGeoResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ReportsClientListByGeoResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ReportsClientListByGeoResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ReportsClientListByGeoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ReportsClientListByGeoResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByGeoHandleResponse(resp)
	if err != nil {
		return ReportsClientListByGeoResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ReportsClientListByOperationPager provides operations for iterating over paged responses.
type ReportsClientListByOperationPager struct {
	client    *ReportsClient
	current   ReportsClientListByOperationResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReportsClientListByOperationResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ReportsClientListByOperationPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReportCollection.NextLink == nil || len(*p.current.ReportCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ReportsClientListByOperationPager) NextPage(ctx context.Context) (ReportsClientListByOperationResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ReportsClientListByOperationResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ReportsClientListByOperationResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ReportsClientListByOperationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ReportsClientListByOperationResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByOperationHandleResponse(resp)
	if err != nil {
		return ReportsClientListByOperationResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ReportsClientListByProductPager provides operations for iterating over paged responses.
type ReportsClientListByProductPager struct {
	client    *ReportsClient
	current   ReportsClientListByProductResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReportsClientListByProductResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ReportsClientListByProductPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReportCollection.NextLink == nil || len(*p.current.ReportCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ReportsClientListByProductPager) NextPage(ctx context.Context) (ReportsClientListByProductResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ReportsClientListByProductResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ReportsClientListByProductResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ReportsClientListByProductResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ReportsClientListByProductResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByProductHandleResponse(resp)
	if err != nil {
		return ReportsClientListByProductResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ReportsClientListByRequestPager provides operations for iterating over paged responses.
type ReportsClientListByRequestPager struct {
	client    *ReportsClient
	current   ReportsClientListByRequestResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ReportsClientListByRequestPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *ReportsClientListByRequestPager) NextPage(ctx context.Context) (ReportsClientListByRequestResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return ReportsClientListByRequestResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ReportsClientListByRequestResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ReportsClientListByRequestResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ReportsClientListByRequestResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByRequestHandleResponse(resp)
	if err != nil {
		return ReportsClientListByRequestResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ReportsClientListBySubscriptionPager provides operations for iterating over paged responses.
type ReportsClientListBySubscriptionPager struct {
	client    *ReportsClient
	current   ReportsClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReportsClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ReportsClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReportCollection.NextLink == nil || len(*p.current.ReportCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ReportsClientListBySubscriptionPager) NextPage(ctx context.Context) (ReportsClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ReportsClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ReportsClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ReportsClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ReportsClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return ReportsClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ReportsClientListByTimePager provides operations for iterating over paged responses.
type ReportsClientListByTimePager struct {
	client    *ReportsClient
	current   ReportsClientListByTimeResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReportsClientListByTimeResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ReportsClientListByTimePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReportCollection.NextLink == nil || len(*p.current.ReportCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ReportsClientListByTimePager) NextPage(ctx context.Context) (ReportsClientListByTimeResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ReportsClientListByTimeResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ReportsClientListByTimeResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ReportsClientListByTimeResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ReportsClientListByTimeResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByTimeHandleResponse(resp)
	if err != nil {
		return ReportsClientListByTimeResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ReportsClientListByUserPager provides operations for iterating over paged responses.
type ReportsClientListByUserPager struct {
	client    *ReportsClient
	current   ReportsClientListByUserResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ReportsClientListByUserResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ReportsClientListByUserPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ReportCollection.NextLink == nil || len(*p.current.ReportCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ReportsClientListByUserPager) NextPage(ctx context.Context) (ReportsClientListByUserResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ReportsClientListByUserResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ReportsClientListByUserResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ReportsClientListByUserResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ReportsClientListByUserResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByUserHandleResponse(resp)
	if err != nil {
		return ReportsClientListByUserResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SKUsClientListPager provides operations for iterating over paged responses.
type SKUsClientListPager struct {
	client    *SKUsClient
	current   SKUsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SKUsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SKUsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SKUsResult.NextLink == nil || len(*p.current.SKUsResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SKUsClientListPager) NextPage(ctx context.Context) (SKUsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SKUsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SKUsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SKUsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SKUsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return SKUsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ServiceClientListByResourceGroupPager provides operations for iterating over paged responses.
type ServiceClientListByResourceGroupPager struct {
	client    *ServiceClient
	current   ServiceClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServiceClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ServiceClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServiceListResult.NextLink == nil || len(*p.current.ServiceListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ServiceClientListByResourceGroupPager) NextPage(ctx context.Context) (ServiceClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ServiceClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ServiceClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ServiceClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ServiceClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return ServiceClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ServiceClientListPager provides operations for iterating over paged responses.
type ServiceClientListPager struct {
	client    *ServiceClient
	current   ServiceClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServiceClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ServiceClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ServiceListResult.NextLink == nil || len(*p.current.ServiceListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ServiceClientListPager) NextPage(ctx context.Context) (ServiceClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ServiceClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ServiceClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ServiceClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ServiceClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ServiceClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ServiceSKUsClientListAvailableServiceSKUsPager provides operations for iterating over paged responses.
type ServiceSKUsClientListAvailableServiceSKUsPager struct {
	client    *ServiceSKUsClient
	current   ServiceSKUsClientListAvailableServiceSKUsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ServiceSKUsClientListAvailableServiceSKUsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ServiceSKUsClientListAvailableServiceSKUsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceSKUResults.NextLink == nil || len(*p.current.ResourceSKUResults.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ServiceSKUsClientListAvailableServiceSKUsPager) NextPage(ctx context.Context) (ServiceSKUsClientListAvailableServiceSKUsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ServiceSKUsClientListAvailableServiceSKUsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ServiceSKUsClientListAvailableServiceSKUsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ServiceSKUsClientListAvailableServiceSKUsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ServiceSKUsClientListAvailableServiceSKUsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAvailableServiceSKUsHandleResponse(resp)
	if err != nil {
		return ServiceSKUsClientListAvailableServiceSKUsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SubscriptionClientListPager provides operations for iterating over paged responses.
type SubscriptionClientListPager struct {
	client    *SubscriptionClient
	current   SubscriptionClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SubscriptionClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SubscriptionClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubscriptionCollection.NextLink == nil || len(*p.current.SubscriptionCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SubscriptionClientListPager) NextPage(ctx context.Context) (SubscriptionClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SubscriptionClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SubscriptionClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SubscriptionClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SubscriptionClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return SubscriptionClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TagClientListByAPIPager provides operations for iterating over paged responses.
type TagClientListByAPIPager struct {
	client    *TagClient
	current   TagClientListByAPIResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TagClientListByAPIResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TagClientListByAPIPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagCollection.NextLink == nil || len(*p.current.TagCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *TagClientListByAPIPager) NextPage(ctx context.Context) (TagClientListByAPIResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return TagClientListByAPIResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TagClientListByAPIResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TagClientListByAPIResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TagClientListByAPIResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByAPIHandleResponse(resp)
	if err != nil {
		return TagClientListByAPIResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TagClientListByOperationPager provides operations for iterating over paged responses.
type TagClientListByOperationPager struct {
	client    *TagClient
	current   TagClientListByOperationResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TagClientListByOperationResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TagClientListByOperationPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagCollection.NextLink == nil || len(*p.current.TagCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *TagClientListByOperationPager) NextPage(ctx context.Context) (TagClientListByOperationResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return TagClientListByOperationResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TagClientListByOperationResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TagClientListByOperationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TagClientListByOperationResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByOperationHandleResponse(resp)
	if err != nil {
		return TagClientListByOperationResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TagClientListByProductPager provides operations for iterating over paged responses.
type TagClientListByProductPager struct {
	client    *TagClient
	current   TagClientListByProductResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TagClientListByProductResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TagClientListByProductPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagCollection.NextLink == nil || len(*p.current.TagCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *TagClientListByProductPager) NextPage(ctx context.Context) (TagClientListByProductResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return TagClientListByProductResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TagClientListByProductResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TagClientListByProductResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TagClientListByProductResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByProductHandleResponse(resp)
	if err != nil {
		return TagClientListByProductResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TagClientListByServicePager provides operations for iterating over paged responses.
type TagClientListByServicePager struct {
	client    *TagClient
	current   TagClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TagClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TagClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagCollection.NextLink == nil || len(*p.current.TagCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *TagClientListByServicePager) NextPage(ctx context.Context) (TagClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return TagClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TagClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TagClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TagClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return TagClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TagResourceClientListByServicePager provides operations for iterating over paged responses.
type TagResourceClientListByServicePager struct {
	client    *TagResourceClient
	current   TagResourceClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TagResourceClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TagResourceClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TagResourceCollection.NextLink == nil || len(*p.current.TagResourceCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *TagResourceClientListByServicePager) NextPage(ctx context.Context) (TagResourceClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return TagResourceClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TagResourceClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TagResourceClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TagResourceClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return TagResourceClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TenantAccessClientListByServicePager provides operations for iterating over paged responses.
type TenantAccessClientListByServicePager struct {
	client    *TenantAccessClient
	current   TenantAccessClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TenantAccessClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TenantAccessClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AccessInformationCollection.NextLink == nil || len(*p.current.AccessInformationCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *TenantAccessClientListByServicePager) NextPage(ctx context.Context) (TenantAccessClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return TenantAccessClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TenantAccessClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TenantAccessClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TenantAccessClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return TenantAccessClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// TenantSettingsClientListByServicePager provides operations for iterating over paged responses.
type TenantSettingsClientListByServicePager struct {
	client    *TenantSettingsClient
	current   TenantSettingsClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, TenantSettingsClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *TenantSettingsClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.TenantSettingsCollection.NextLink == nil || len(*p.current.TenantSettingsCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *TenantSettingsClientListByServicePager) NextPage(ctx context.Context) (TenantSettingsClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return TenantSettingsClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return TenantSettingsClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return TenantSettingsClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return TenantSettingsClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return TenantSettingsClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// UserClientListByServicePager provides operations for iterating over paged responses.
type UserClientListByServicePager struct {
	client    *UserClient
	current   UserClientListByServiceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UserClientListByServiceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *UserClientListByServicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UserCollection.NextLink == nil || len(*p.current.UserCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *UserClientListByServicePager) NextPage(ctx context.Context) (UserClientListByServiceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return UserClientListByServiceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return UserClientListByServiceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return UserClientListByServiceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return UserClientListByServiceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByServiceHandleResponse(resp)
	if err != nil {
		return UserClientListByServiceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// UserGroupClientListPager provides operations for iterating over paged responses.
type UserGroupClientListPager struct {
	client    *UserGroupClient
	current   UserGroupClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UserGroupClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *UserGroupClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GroupCollection.NextLink == nil || len(*p.current.GroupCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *UserGroupClientListPager) NextPage(ctx context.Context) (UserGroupClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return UserGroupClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return UserGroupClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return UserGroupClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return UserGroupClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return UserGroupClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// UserIdentitiesClientListPager provides operations for iterating over paged responses.
type UserIdentitiesClientListPager struct {
	client    *UserIdentitiesClient
	current   UserIdentitiesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UserIdentitiesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *UserIdentitiesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UserIdentityCollection.NextLink == nil || len(*p.current.UserIdentityCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *UserIdentitiesClientListPager) NextPage(ctx context.Context) (UserIdentitiesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return UserIdentitiesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return UserIdentitiesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return UserIdentitiesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return UserIdentitiesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return UserIdentitiesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// UserSubscriptionClientListPager provides operations for iterating over paged responses.
type UserSubscriptionClientListPager struct {
	client    *UserSubscriptionClient
	current   UserSubscriptionClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UserSubscriptionClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *UserSubscriptionClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SubscriptionCollection.NextLink == nil || len(*p.current.SubscriptionCollection.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *UserSubscriptionClientListPager) NextPage(ctx context.Context) (UserSubscriptionClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return UserSubscriptionClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return UserSubscriptionClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return UserSubscriptionClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return UserSubscriptionClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return UserSubscriptionClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}
