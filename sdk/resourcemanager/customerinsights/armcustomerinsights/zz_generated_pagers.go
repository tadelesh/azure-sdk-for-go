//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcustomerinsights

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AuthorizationPoliciesClientListByHubPager provides operations for iterating over paged responses.
type AuthorizationPoliciesClientListByHubPager struct {
	client    *AuthorizationPoliciesClient
	current   AuthorizationPoliciesClientListByHubResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AuthorizationPoliciesClientListByHubResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AuthorizationPoliciesClientListByHubPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AuthorizationPolicyListResult.NextLink == nil || len(*p.current.AuthorizationPolicyListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AuthorizationPoliciesClientListByHubPager) NextPage(ctx context.Context) (AuthorizationPoliciesClientListByHubResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AuthorizationPoliciesClientListByHubResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AuthorizationPoliciesClientListByHubResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AuthorizationPoliciesClientListByHubResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AuthorizationPoliciesClientListByHubResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByHubHandleResponse(resp)
	if err != nil {
		return AuthorizationPoliciesClientListByHubResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ConnectorMappingsClientListByConnectorPager provides operations for iterating over paged responses.
type ConnectorMappingsClientListByConnectorPager struct {
	client    *ConnectorMappingsClient
	current   ConnectorMappingsClientListByConnectorResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ConnectorMappingsClientListByConnectorResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ConnectorMappingsClientListByConnectorPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ConnectorMappingListResult.NextLink == nil || len(*p.current.ConnectorMappingListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ConnectorMappingsClientListByConnectorPager) NextPage(ctx context.Context) (ConnectorMappingsClientListByConnectorResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ConnectorMappingsClientListByConnectorResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ConnectorMappingsClientListByConnectorResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ConnectorMappingsClientListByConnectorResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ConnectorMappingsClientListByConnectorResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByConnectorHandleResponse(resp)
	if err != nil {
		return ConnectorMappingsClientListByConnectorResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ConnectorsClientListByHubPager provides operations for iterating over paged responses.
type ConnectorsClientListByHubPager struct {
	client    *ConnectorsClient
	current   ConnectorsClientListByHubResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ConnectorsClientListByHubResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ConnectorsClientListByHubPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ConnectorListResult.NextLink == nil || len(*p.current.ConnectorListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ConnectorsClientListByHubPager) NextPage(ctx context.Context) (ConnectorsClientListByHubResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ConnectorsClientListByHubResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ConnectorsClientListByHubResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ConnectorsClientListByHubResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ConnectorsClientListByHubResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByHubHandleResponse(resp)
	if err != nil {
		return ConnectorsClientListByHubResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// HubsClientListByResourceGroupPager provides operations for iterating over paged responses.
type HubsClientListByResourceGroupPager struct {
	client    *HubsClient
	current   HubsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, HubsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *HubsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.HubListResult.NextLink == nil || len(*p.current.HubListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *HubsClientListByResourceGroupPager) NextPage(ctx context.Context) (HubsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return HubsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return HubsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return HubsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return HubsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return HubsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// HubsClientListPager provides operations for iterating over paged responses.
type HubsClientListPager struct {
	client    *HubsClient
	current   HubsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, HubsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *HubsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.HubListResult.NextLink == nil || len(*p.current.HubListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *HubsClientListPager) NextPage(ctx context.Context) (HubsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return HubsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return HubsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return HubsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return HubsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return HubsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// InteractionsClientListByHubPager provides operations for iterating over paged responses.
type InteractionsClientListByHubPager struct {
	client    *InteractionsClient
	current   InteractionsClientListByHubResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, InteractionsClientListByHubResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *InteractionsClientListByHubPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.InteractionListResult.NextLink == nil || len(*p.current.InteractionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *InteractionsClientListByHubPager) NextPage(ctx context.Context) (InteractionsClientListByHubResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return InteractionsClientListByHubResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return InteractionsClientListByHubResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return InteractionsClientListByHubResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return InteractionsClientListByHubResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByHubHandleResponse(resp)
	if err != nil {
		return InteractionsClientListByHubResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// KpiClientListByHubPager provides operations for iterating over paged responses.
type KpiClientListByHubPager struct {
	client    *KpiClient
	current   KpiClientListByHubResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, KpiClientListByHubResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *KpiClientListByHubPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.KpiListResult.NextLink == nil || len(*p.current.KpiListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *KpiClientListByHubPager) NextPage(ctx context.Context) (KpiClientListByHubResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return KpiClientListByHubResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return KpiClientListByHubResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return KpiClientListByHubResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return KpiClientListByHubResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByHubHandleResponse(resp)
	if err != nil {
		return KpiClientListByHubResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// LinksClientListByHubPager provides operations for iterating over paged responses.
type LinksClientListByHubPager struct {
	client    *LinksClient
	current   LinksClientListByHubResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, LinksClientListByHubResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *LinksClientListByHubPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.LinkListResult.NextLink == nil || len(*p.current.LinkListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *LinksClientListByHubPager) NextPage(ctx context.Context) (LinksClientListByHubResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return LinksClientListByHubResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return LinksClientListByHubResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return LinksClientListByHubResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return LinksClientListByHubResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByHubHandleResponse(resp)
	if err != nil {
		return LinksClientListByHubResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *OperationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationListResult.NextLink == nil || len(*p.current.OperationListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *OperationsClientListPager) NextPage(ctx context.Context) (OperationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return OperationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return OperationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PredictionsClientListByHubPager provides operations for iterating over paged responses.
type PredictionsClientListByHubPager struct {
	client    *PredictionsClient
	current   PredictionsClientListByHubResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PredictionsClientListByHubResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PredictionsClientListByHubPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PredictionListResult.NextLink == nil || len(*p.current.PredictionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PredictionsClientListByHubPager) NextPage(ctx context.Context) (PredictionsClientListByHubResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PredictionsClientListByHubResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PredictionsClientListByHubResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PredictionsClientListByHubResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PredictionsClientListByHubResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByHubHandleResponse(resp)
	if err != nil {
		return PredictionsClientListByHubResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProfilesClientListByHubPager provides operations for iterating over paged responses.
type ProfilesClientListByHubPager struct {
	client    *ProfilesClient
	current   ProfilesClientListByHubResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProfilesClientListByHubResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProfilesClientListByHubPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProfileListResult.NextLink == nil || len(*p.current.ProfileListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProfilesClientListByHubPager) NextPage(ctx context.Context) (ProfilesClientListByHubResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProfilesClientListByHubResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProfilesClientListByHubResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProfilesClientListByHubResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProfilesClientListByHubResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByHubHandleResponse(resp)
	if err != nil {
		return ProfilesClientListByHubResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RelationshipLinksClientListByHubPager provides operations for iterating over paged responses.
type RelationshipLinksClientListByHubPager struct {
	client    *RelationshipLinksClient
	current   RelationshipLinksClientListByHubResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RelationshipLinksClientListByHubResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RelationshipLinksClientListByHubPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RelationshipLinkListResult.NextLink == nil || len(*p.current.RelationshipLinkListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RelationshipLinksClientListByHubPager) NextPage(ctx context.Context) (RelationshipLinksClientListByHubResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RelationshipLinksClientListByHubResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RelationshipLinksClientListByHubResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RelationshipLinksClientListByHubResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RelationshipLinksClientListByHubResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByHubHandleResponse(resp)
	if err != nil {
		return RelationshipLinksClientListByHubResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RelationshipsClientListByHubPager provides operations for iterating over paged responses.
type RelationshipsClientListByHubPager struct {
	client    *RelationshipsClient
	current   RelationshipsClientListByHubResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RelationshipsClientListByHubResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RelationshipsClientListByHubPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RelationshipListResult.NextLink == nil || len(*p.current.RelationshipListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RelationshipsClientListByHubPager) NextPage(ctx context.Context) (RelationshipsClientListByHubResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RelationshipsClientListByHubResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RelationshipsClientListByHubResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RelationshipsClientListByHubResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RelationshipsClientListByHubResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByHubHandleResponse(resp)
	if err != nil {
		return RelationshipsClientListByHubResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RoleAssignmentsClientListByHubPager provides operations for iterating over paged responses.
type RoleAssignmentsClientListByHubPager struct {
	client    *RoleAssignmentsClient
	current   RoleAssignmentsClientListByHubResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoleAssignmentsClientListByHubResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RoleAssignmentsClientListByHubPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleAssignmentListResult.NextLink == nil || len(*p.current.RoleAssignmentListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RoleAssignmentsClientListByHubPager) NextPage(ctx context.Context) (RoleAssignmentsClientListByHubResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RoleAssignmentsClientListByHubResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RoleAssignmentsClientListByHubResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RoleAssignmentsClientListByHubResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RoleAssignmentsClientListByHubResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByHubHandleResponse(resp)
	if err != nil {
		return RoleAssignmentsClientListByHubResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RolesClientListByHubPager provides operations for iterating over paged responses.
type RolesClientListByHubPager struct {
	client    *RolesClient
	current   RolesClientListByHubResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RolesClientListByHubResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RolesClientListByHubPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleListResult.NextLink == nil || len(*p.current.RoleListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RolesClientListByHubPager) NextPage(ctx context.Context) (RolesClientListByHubResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RolesClientListByHubResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RolesClientListByHubResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RolesClientListByHubResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RolesClientListByHubResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByHubHandleResponse(resp)
	if err != nil {
		return RolesClientListByHubResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ViewsClientListByHubPager provides operations for iterating over paged responses.
type ViewsClientListByHubPager struct {
	client    *ViewsClient
	current   ViewsClientListByHubResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ViewsClientListByHubResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ViewsClientListByHubPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ViewListResult.NextLink == nil || len(*p.current.ViewListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ViewsClientListByHubPager) NextPage(ctx context.Context) (ViewsClientListByHubResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ViewsClientListByHubResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ViewsClientListByHubResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ViewsClientListByHubResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ViewsClientListByHubResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByHubHandleResponse(resp)
	if err != nil {
		return ViewsClientListByHubResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WidgetTypesClientListByHubPager provides operations for iterating over paged responses.
type WidgetTypesClientListByHubPager struct {
	client    *WidgetTypesClient
	current   WidgetTypesClientListByHubResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WidgetTypesClientListByHubResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WidgetTypesClientListByHubPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WidgetTypeListResult.NextLink == nil || len(*p.current.WidgetTypeListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WidgetTypesClientListByHubPager) NextPage(ctx context.Context) (WidgetTypesClientListByHubResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WidgetTypesClientListByHubResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WidgetTypesClientListByHubResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WidgetTypesClientListByHubResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WidgetTypesClientListByHubResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByHubHandleResponse(resp)
	if err != nil {
		return WidgetTypesClientListByHubResponse{}, err
	}
	p.current = result
	return p.current, nil
}
