//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armstorsimple8000series

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AccessControlRecordsClientListByManagerPager provides operations for iterating over paged responses.
type AccessControlRecordsClientListByManagerPager struct {
	client    *AccessControlRecordsClient
	current   AccessControlRecordsClientListByManagerResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AccessControlRecordsClientListByManagerPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *AccessControlRecordsClientListByManagerPager) NextPage(ctx context.Context) (AccessControlRecordsClientListByManagerResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return AccessControlRecordsClientListByManagerResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AccessControlRecordsClientListByManagerResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AccessControlRecordsClientListByManagerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AccessControlRecordsClientListByManagerResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByManagerHandleResponse(resp)
	if err != nil {
		return AccessControlRecordsClientListByManagerResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AlertsClientListByManagerPager provides operations for iterating over paged responses.
type AlertsClientListByManagerPager struct {
	client    *AlertsClient
	current   AlertsClientListByManagerResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AlertsClientListByManagerResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AlertsClientListByManagerPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AlertList.NextLink == nil || len(*p.current.AlertList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AlertsClientListByManagerPager) NextPage(ctx context.Context) (AlertsClientListByManagerResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AlertsClientListByManagerResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AlertsClientListByManagerResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AlertsClientListByManagerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AlertsClientListByManagerResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByManagerHandleResponse(resp)
	if err != nil {
		return AlertsClientListByManagerResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BackupPoliciesClientListByDevicePager provides operations for iterating over paged responses.
type BackupPoliciesClientListByDevicePager struct {
	client    *BackupPoliciesClient
	current   BackupPoliciesClientListByDeviceResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BackupPoliciesClientListByDevicePager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *BackupPoliciesClientListByDevicePager) NextPage(ctx context.Context) (BackupPoliciesClientListByDeviceResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return BackupPoliciesClientListByDeviceResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BackupPoliciesClientListByDeviceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BackupPoliciesClientListByDeviceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BackupPoliciesClientListByDeviceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByDeviceHandleResponse(resp)
	if err != nil {
		return BackupPoliciesClientListByDeviceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BackupSchedulesClientListByBackupPolicyPager provides operations for iterating over paged responses.
type BackupSchedulesClientListByBackupPolicyPager struct {
	client    *BackupSchedulesClient
	current   BackupSchedulesClientListByBackupPolicyResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BackupSchedulesClientListByBackupPolicyPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *BackupSchedulesClientListByBackupPolicyPager) NextPage(ctx context.Context) (BackupSchedulesClientListByBackupPolicyResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return BackupSchedulesClientListByBackupPolicyResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BackupSchedulesClientListByBackupPolicyResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BackupSchedulesClientListByBackupPolicyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BackupSchedulesClientListByBackupPolicyResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByBackupPolicyHandleResponse(resp)
	if err != nil {
		return BackupSchedulesClientListByBackupPolicyResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BackupsClientListByDevicePager provides operations for iterating over paged responses.
type BackupsClientListByDevicePager struct {
	client    *BackupsClient
	current   BackupsClientListByDeviceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, BackupsClientListByDeviceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BackupsClientListByDevicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.BackupList.NextLink == nil || len(*p.current.BackupList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *BackupsClientListByDevicePager) NextPage(ctx context.Context) (BackupsClientListByDeviceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return BackupsClientListByDeviceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BackupsClientListByDeviceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BackupsClientListByDeviceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BackupsClientListByDeviceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByDeviceHandleResponse(resp)
	if err != nil {
		return BackupsClientListByDeviceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// BandwidthSettingsClientListByManagerPager provides operations for iterating over paged responses.
type BandwidthSettingsClientListByManagerPager struct {
	client    *BandwidthSettingsClient
	current   BandwidthSettingsClientListByManagerResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *BandwidthSettingsClientListByManagerPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *BandwidthSettingsClientListByManagerPager) NextPage(ctx context.Context) (BandwidthSettingsClientListByManagerResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return BandwidthSettingsClientListByManagerResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return BandwidthSettingsClientListByManagerResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return BandwidthSettingsClientListByManagerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return BandwidthSettingsClientListByManagerResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByManagerHandleResponse(resp)
	if err != nil {
		return BandwidthSettingsClientListByManagerResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CloudAppliancesClientListSupportedConfigurationsPager provides operations for iterating over paged responses.
type CloudAppliancesClientListSupportedConfigurationsPager struct {
	client    *CloudAppliancesClient
	current   CloudAppliancesClientListSupportedConfigurationsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CloudAppliancesClientListSupportedConfigurationsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *CloudAppliancesClientListSupportedConfigurationsPager) NextPage(ctx context.Context) (CloudAppliancesClientListSupportedConfigurationsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return CloudAppliancesClientListSupportedConfigurationsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CloudAppliancesClientListSupportedConfigurationsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CloudAppliancesClientListSupportedConfigurationsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CloudAppliancesClientListSupportedConfigurationsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listSupportedConfigurationsHandleResponse(resp)
	if err != nil {
		return CloudAppliancesClientListSupportedConfigurationsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DevicesClientListByManagerPager provides operations for iterating over paged responses.
type DevicesClientListByManagerPager struct {
	client    *DevicesClient
	current   DevicesClientListByManagerResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DevicesClientListByManagerPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *DevicesClientListByManagerPager) NextPage(ctx context.Context) (DevicesClientListByManagerResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return DevicesClientListByManagerResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DevicesClientListByManagerResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DevicesClientListByManagerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DevicesClientListByManagerResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByManagerHandleResponse(resp)
	if err != nil {
		return DevicesClientListByManagerResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DevicesClientListFailoverSetsPager provides operations for iterating over paged responses.
type DevicesClientListFailoverSetsPager struct {
	client    *DevicesClient
	current   DevicesClientListFailoverSetsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DevicesClientListFailoverSetsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *DevicesClientListFailoverSetsPager) NextPage(ctx context.Context) (DevicesClientListFailoverSetsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return DevicesClientListFailoverSetsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DevicesClientListFailoverSetsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DevicesClientListFailoverSetsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DevicesClientListFailoverSetsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listFailoverSetsHandleResponse(resp)
	if err != nil {
		return DevicesClientListFailoverSetsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DevicesClientListFailoverTargetsPager provides operations for iterating over paged responses.
type DevicesClientListFailoverTargetsPager struct {
	client    *DevicesClient
	current   DevicesClientListFailoverTargetsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DevicesClientListFailoverTargetsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *DevicesClientListFailoverTargetsPager) NextPage(ctx context.Context) (DevicesClientListFailoverTargetsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return DevicesClientListFailoverTargetsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DevicesClientListFailoverTargetsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DevicesClientListFailoverTargetsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DevicesClientListFailoverTargetsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listFailoverTargetsHandleResponse(resp)
	if err != nil {
		return DevicesClientListFailoverTargetsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DevicesClientListMetricDefinitionPager provides operations for iterating over paged responses.
type DevicesClientListMetricDefinitionPager struct {
	client    *DevicesClient
	current   DevicesClientListMetricDefinitionResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DevicesClientListMetricDefinitionPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *DevicesClientListMetricDefinitionPager) NextPage(ctx context.Context) (DevicesClientListMetricDefinitionResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return DevicesClientListMetricDefinitionResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DevicesClientListMetricDefinitionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DevicesClientListMetricDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DevicesClientListMetricDefinitionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricDefinitionHandleResponse(resp)
	if err != nil {
		return DevicesClientListMetricDefinitionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DevicesClientListMetricsPager provides operations for iterating over paged responses.
type DevicesClientListMetricsPager struct {
	client    *DevicesClient
	current   DevicesClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DevicesClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *DevicesClientListMetricsPager) NextPage(ctx context.Context) (DevicesClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return DevicesClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DevicesClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DevicesClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DevicesClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return DevicesClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// HardwareComponentGroupsClientListByDevicePager provides operations for iterating over paged responses.
type HardwareComponentGroupsClientListByDevicePager struct {
	client    *HardwareComponentGroupsClient
	current   HardwareComponentGroupsClientListByDeviceResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *HardwareComponentGroupsClientListByDevicePager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *HardwareComponentGroupsClientListByDevicePager) NextPage(ctx context.Context) (HardwareComponentGroupsClientListByDeviceResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return HardwareComponentGroupsClientListByDeviceResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return HardwareComponentGroupsClientListByDeviceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return HardwareComponentGroupsClientListByDeviceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return HardwareComponentGroupsClientListByDeviceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByDeviceHandleResponse(resp)
	if err != nil {
		return HardwareComponentGroupsClientListByDeviceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// JobsClientListByDevicePager provides operations for iterating over paged responses.
type JobsClientListByDevicePager struct {
	client    *JobsClient
	current   JobsClientListByDeviceResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobsClientListByDeviceResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *JobsClientListByDevicePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobList.NextLink == nil || len(*p.current.JobList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *JobsClientListByDevicePager) NextPage(ctx context.Context) (JobsClientListByDeviceResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return JobsClientListByDeviceResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return JobsClientListByDeviceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return JobsClientListByDeviceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return JobsClientListByDeviceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByDeviceHandleResponse(resp)
	if err != nil {
		return JobsClientListByDeviceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// JobsClientListByManagerPager provides operations for iterating over paged responses.
type JobsClientListByManagerPager struct {
	client    *JobsClient
	current   JobsClientListByManagerResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, JobsClientListByManagerResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *JobsClientListByManagerPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.JobList.NextLink == nil || len(*p.current.JobList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *JobsClientListByManagerPager) NextPage(ctx context.Context) (JobsClientListByManagerResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return JobsClientListByManagerResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return JobsClientListByManagerResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return JobsClientListByManagerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return JobsClientListByManagerResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByManagerHandleResponse(resp)
	if err != nil {
		return JobsClientListByManagerResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ManagersClientListByResourceGroupPager provides operations for iterating over paged responses.
type ManagersClientListByResourceGroupPager struct {
	client    *ManagersClient
	current   ManagersClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ManagersClientListByResourceGroupPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *ManagersClientListByResourceGroupPager) NextPage(ctx context.Context) (ManagersClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return ManagersClientListByResourceGroupResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ManagersClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ManagersClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ManagersClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return ManagersClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ManagersClientListFeatureSupportStatusPager provides operations for iterating over paged responses.
type ManagersClientListFeatureSupportStatusPager struct {
	client    *ManagersClient
	current   ManagersClientListFeatureSupportStatusResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ManagersClientListFeatureSupportStatusPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *ManagersClientListFeatureSupportStatusPager) NextPage(ctx context.Context) (ManagersClientListFeatureSupportStatusResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return ManagersClientListFeatureSupportStatusResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ManagersClientListFeatureSupportStatusResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ManagersClientListFeatureSupportStatusResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ManagersClientListFeatureSupportStatusResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listFeatureSupportStatusHandleResponse(resp)
	if err != nil {
		return ManagersClientListFeatureSupportStatusResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ManagersClientListMetricDefinitionPager provides operations for iterating over paged responses.
type ManagersClientListMetricDefinitionPager struct {
	client    *ManagersClient
	current   ManagersClientListMetricDefinitionResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ManagersClientListMetricDefinitionPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *ManagersClientListMetricDefinitionPager) NextPage(ctx context.Context) (ManagersClientListMetricDefinitionResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return ManagersClientListMetricDefinitionResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ManagersClientListMetricDefinitionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ManagersClientListMetricDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ManagersClientListMetricDefinitionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricDefinitionHandleResponse(resp)
	if err != nil {
		return ManagersClientListMetricDefinitionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ManagersClientListMetricsPager provides operations for iterating over paged responses.
type ManagersClientListMetricsPager struct {
	client    *ManagersClient
	current   ManagersClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ManagersClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *ManagersClientListMetricsPager) NextPage(ctx context.Context) (ManagersClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return ManagersClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ManagersClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ManagersClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ManagersClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return ManagersClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ManagersClientListPager provides operations for iterating over paged responses.
type ManagersClientListPager struct {
	client    *ManagersClient
	current   ManagersClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ManagersClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *ManagersClientListPager) NextPage(ctx context.Context) (ManagersClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return ManagersClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ManagersClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ManagersClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ManagersClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ManagersClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *OperationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailableProviderOperationList.NextLink == nil || len(*p.current.AvailableProviderOperationList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *OperationsClientListPager) NextPage(ctx context.Context) (OperationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return OperationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return OperationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// StorageAccountCredentialsClientListByManagerPager provides operations for iterating over paged responses.
type StorageAccountCredentialsClientListByManagerPager struct {
	client    *StorageAccountCredentialsClient
	current   StorageAccountCredentialsClientListByManagerResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *StorageAccountCredentialsClientListByManagerPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *StorageAccountCredentialsClientListByManagerPager) NextPage(ctx context.Context) (StorageAccountCredentialsClientListByManagerResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return StorageAccountCredentialsClientListByManagerResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return StorageAccountCredentialsClientListByManagerResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return StorageAccountCredentialsClientListByManagerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return StorageAccountCredentialsClientListByManagerResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByManagerHandleResponse(resp)
	if err != nil {
		return StorageAccountCredentialsClientListByManagerResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VolumeContainersClientListByDevicePager provides operations for iterating over paged responses.
type VolumeContainersClientListByDevicePager struct {
	client    *VolumeContainersClient
	current   VolumeContainersClientListByDeviceResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VolumeContainersClientListByDevicePager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *VolumeContainersClientListByDevicePager) NextPage(ctx context.Context) (VolumeContainersClientListByDeviceResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return VolumeContainersClientListByDeviceResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VolumeContainersClientListByDeviceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VolumeContainersClientListByDeviceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VolumeContainersClientListByDeviceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByDeviceHandleResponse(resp)
	if err != nil {
		return VolumeContainersClientListByDeviceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VolumeContainersClientListMetricDefinitionPager provides operations for iterating over paged responses.
type VolumeContainersClientListMetricDefinitionPager struct {
	client    *VolumeContainersClient
	current   VolumeContainersClientListMetricDefinitionResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VolumeContainersClientListMetricDefinitionPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *VolumeContainersClientListMetricDefinitionPager) NextPage(ctx context.Context) (VolumeContainersClientListMetricDefinitionResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return VolumeContainersClientListMetricDefinitionResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VolumeContainersClientListMetricDefinitionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VolumeContainersClientListMetricDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VolumeContainersClientListMetricDefinitionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricDefinitionHandleResponse(resp)
	if err != nil {
		return VolumeContainersClientListMetricDefinitionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VolumeContainersClientListMetricsPager provides operations for iterating over paged responses.
type VolumeContainersClientListMetricsPager struct {
	client    *VolumeContainersClient
	current   VolumeContainersClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VolumeContainersClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *VolumeContainersClientListMetricsPager) NextPage(ctx context.Context) (VolumeContainersClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return VolumeContainersClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VolumeContainersClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VolumeContainersClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VolumeContainersClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return VolumeContainersClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VolumesClientListByDevicePager provides operations for iterating over paged responses.
type VolumesClientListByDevicePager struct {
	client    *VolumesClient
	current   VolumesClientListByDeviceResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VolumesClientListByDevicePager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *VolumesClientListByDevicePager) NextPage(ctx context.Context) (VolumesClientListByDeviceResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return VolumesClientListByDeviceResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VolumesClientListByDeviceResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VolumesClientListByDeviceResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VolumesClientListByDeviceResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByDeviceHandleResponse(resp)
	if err != nil {
		return VolumesClientListByDeviceResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VolumesClientListByVolumeContainerPager provides operations for iterating over paged responses.
type VolumesClientListByVolumeContainerPager struct {
	client    *VolumesClient
	current   VolumesClientListByVolumeContainerResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VolumesClientListByVolumeContainerPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *VolumesClientListByVolumeContainerPager) NextPage(ctx context.Context) (VolumesClientListByVolumeContainerResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return VolumesClientListByVolumeContainerResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VolumesClientListByVolumeContainerResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VolumesClientListByVolumeContainerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VolumesClientListByVolumeContainerResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByVolumeContainerHandleResponse(resp)
	if err != nil {
		return VolumesClientListByVolumeContainerResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VolumesClientListMetricDefinitionPager provides operations for iterating over paged responses.
type VolumesClientListMetricDefinitionPager struct {
	client    *VolumesClient
	current   VolumesClientListMetricDefinitionResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VolumesClientListMetricDefinitionPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *VolumesClientListMetricDefinitionPager) NextPage(ctx context.Context) (VolumesClientListMetricDefinitionResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return VolumesClientListMetricDefinitionResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VolumesClientListMetricDefinitionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VolumesClientListMetricDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VolumesClientListMetricDefinitionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricDefinitionHandleResponse(resp)
	if err != nil {
		return VolumesClientListMetricDefinitionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VolumesClientListMetricsPager provides operations for iterating over paged responses.
type VolumesClientListMetricsPager struct {
	client    *VolumesClient
	current   VolumesClientListMetricsResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VolumesClientListMetricsPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *VolumesClientListMetricsPager) NextPage(ctx context.Context) (VolumesClientListMetricsResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return VolumesClientListMetricsResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VolumesClientListMetricsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VolumesClientListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VolumesClientListMetricsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listMetricsHandleResponse(resp)
	if err != nil {
		return VolumesClientListMetricsResponse{}, err
	}
	p.current = result
	return p.current, nil
}
