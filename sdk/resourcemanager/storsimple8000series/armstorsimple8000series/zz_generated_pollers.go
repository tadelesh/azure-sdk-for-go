//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armstorsimple8000series

import (
	"context"
	"net/http"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
)

// AccessControlRecordsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type AccessControlRecordsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AccessControlRecordsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AccessControlRecordsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AccessControlRecordsCreateOrUpdateResponse will be returned.
func (p *AccessControlRecordsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (AccessControlRecordsCreateOrUpdateResponse, error) {
	respType := AccessControlRecordsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AccessControlRecord)
	if err != nil {
		return AccessControlRecordsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AccessControlRecordsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// AccessControlRecordsDeletePoller provides polling facilities until the operation reaches a terminal state.
type AccessControlRecordsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *AccessControlRecordsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *AccessControlRecordsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final AccessControlRecordsDeleteResponse will be returned.
func (p *AccessControlRecordsDeletePoller) FinalResponse(ctx context.Context) (AccessControlRecordsDeleteResponse, error) {
	respType := AccessControlRecordsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return AccessControlRecordsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *AccessControlRecordsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// BackupPoliciesBackupNowPoller provides polling facilities until the operation reaches a terminal state.
type BackupPoliciesBackupNowPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BackupPoliciesBackupNowPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *BackupPoliciesBackupNowPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final BackupPoliciesBackupNowResponse will be returned.
func (p *BackupPoliciesBackupNowPoller) FinalResponse(ctx context.Context) (BackupPoliciesBackupNowResponse, error) {
	respType := BackupPoliciesBackupNowResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return BackupPoliciesBackupNowResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *BackupPoliciesBackupNowPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// BackupPoliciesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type BackupPoliciesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BackupPoliciesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *BackupPoliciesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final BackupPoliciesCreateOrUpdateResponse will be returned.
func (p *BackupPoliciesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (BackupPoliciesCreateOrUpdateResponse, error) {
	respType := BackupPoliciesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BackupPolicy)
	if err != nil {
		return BackupPoliciesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *BackupPoliciesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// BackupPoliciesDeletePoller provides polling facilities until the operation reaches a terminal state.
type BackupPoliciesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BackupPoliciesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *BackupPoliciesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final BackupPoliciesDeleteResponse will be returned.
func (p *BackupPoliciesDeletePoller) FinalResponse(ctx context.Context) (BackupPoliciesDeleteResponse, error) {
	respType := BackupPoliciesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return BackupPoliciesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *BackupPoliciesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// BackupSchedulesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type BackupSchedulesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BackupSchedulesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *BackupSchedulesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final BackupSchedulesCreateOrUpdateResponse will be returned.
func (p *BackupSchedulesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (BackupSchedulesCreateOrUpdateResponse, error) {
	respType := BackupSchedulesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BackupSchedule)
	if err != nil {
		return BackupSchedulesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *BackupSchedulesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// BackupSchedulesDeletePoller provides polling facilities until the operation reaches a terminal state.
type BackupSchedulesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BackupSchedulesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *BackupSchedulesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final BackupSchedulesDeleteResponse will be returned.
func (p *BackupSchedulesDeletePoller) FinalResponse(ctx context.Context) (BackupSchedulesDeleteResponse, error) {
	respType := BackupSchedulesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return BackupSchedulesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *BackupSchedulesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// BackupsClonePoller provides polling facilities until the operation reaches a terminal state.
type BackupsClonePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BackupsClonePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *BackupsClonePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final BackupsCloneResponse will be returned.
func (p *BackupsClonePoller) FinalResponse(ctx context.Context) (BackupsCloneResponse, error) {
	respType := BackupsCloneResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return BackupsCloneResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *BackupsClonePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// BackupsDeletePoller provides polling facilities until the operation reaches a terminal state.
type BackupsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BackupsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *BackupsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final BackupsDeleteResponse will be returned.
func (p *BackupsDeletePoller) FinalResponse(ctx context.Context) (BackupsDeleteResponse, error) {
	respType := BackupsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return BackupsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *BackupsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// BackupsRestorePoller provides polling facilities until the operation reaches a terminal state.
type BackupsRestorePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BackupsRestorePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *BackupsRestorePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final BackupsRestoreResponse will be returned.
func (p *BackupsRestorePoller) FinalResponse(ctx context.Context) (BackupsRestoreResponse, error) {
	respType := BackupsRestoreResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return BackupsRestoreResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *BackupsRestorePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// BandwidthSettingsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type BandwidthSettingsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BandwidthSettingsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *BandwidthSettingsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final BandwidthSettingsCreateOrUpdateResponse will be returned.
func (p *BandwidthSettingsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (BandwidthSettingsCreateOrUpdateResponse, error) {
	respType := BandwidthSettingsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.BandwidthSetting)
	if err != nil {
		return BandwidthSettingsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *BandwidthSettingsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// BandwidthSettingsDeletePoller provides polling facilities until the operation reaches a terminal state.
type BandwidthSettingsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *BandwidthSettingsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *BandwidthSettingsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final BandwidthSettingsDeleteResponse will be returned.
func (p *BandwidthSettingsDeletePoller) FinalResponse(ctx context.Context) (BandwidthSettingsDeleteResponse, error) {
	respType := BandwidthSettingsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return BandwidthSettingsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *BandwidthSettingsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// CloudAppliancesProvisionPoller provides polling facilities until the operation reaches a terminal state.
type CloudAppliancesProvisionPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *CloudAppliancesProvisionPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *CloudAppliancesProvisionPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final CloudAppliancesProvisionResponse will be returned.
func (p *CloudAppliancesProvisionPoller) FinalResponse(ctx context.Context) (CloudAppliancesProvisionResponse, error) {
	respType := CloudAppliancesProvisionResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return CloudAppliancesProvisionResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *CloudAppliancesProvisionPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeviceSettingsCreateOrUpdateAlertSettingsPoller provides polling facilities until the operation reaches a terminal state.
type DeviceSettingsCreateOrUpdateAlertSettingsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeviceSettingsCreateOrUpdateAlertSettingsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeviceSettingsCreateOrUpdateAlertSettingsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeviceSettingsCreateOrUpdateAlertSettingsResponse will be returned.
func (p *DeviceSettingsCreateOrUpdateAlertSettingsPoller) FinalResponse(ctx context.Context) (DeviceSettingsCreateOrUpdateAlertSettingsResponse, error) {
	respType := DeviceSettingsCreateOrUpdateAlertSettingsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.AlertSettings)
	if err != nil {
		return DeviceSettingsCreateOrUpdateAlertSettingsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeviceSettingsCreateOrUpdateAlertSettingsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeviceSettingsCreateOrUpdateTimeSettingsPoller provides polling facilities until the operation reaches a terminal state.
type DeviceSettingsCreateOrUpdateTimeSettingsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeviceSettingsCreateOrUpdateTimeSettingsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeviceSettingsCreateOrUpdateTimeSettingsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeviceSettingsCreateOrUpdateTimeSettingsResponse will be returned.
func (p *DeviceSettingsCreateOrUpdateTimeSettingsPoller) FinalResponse(ctx context.Context) (DeviceSettingsCreateOrUpdateTimeSettingsResponse, error) {
	respType := DeviceSettingsCreateOrUpdateTimeSettingsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.TimeSettings)
	if err != nil {
		return DeviceSettingsCreateOrUpdateTimeSettingsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeviceSettingsCreateOrUpdateTimeSettingsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeviceSettingsSyncRemotemanagementCertificatePoller provides polling facilities until the operation reaches a terminal state.
type DeviceSettingsSyncRemotemanagementCertificatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeviceSettingsSyncRemotemanagementCertificatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeviceSettingsSyncRemotemanagementCertificatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeviceSettingsSyncRemotemanagementCertificateResponse will be returned.
func (p *DeviceSettingsSyncRemotemanagementCertificatePoller) FinalResponse(ctx context.Context) (DeviceSettingsSyncRemotemanagementCertificateResponse, error) {
	respType := DeviceSettingsSyncRemotemanagementCertificateResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DeviceSettingsSyncRemotemanagementCertificateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeviceSettingsSyncRemotemanagementCertificatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeviceSettingsUpdateNetworkSettingsPoller provides polling facilities until the operation reaches a terminal state.
type DeviceSettingsUpdateNetworkSettingsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeviceSettingsUpdateNetworkSettingsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeviceSettingsUpdateNetworkSettingsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeviceSettingsUpdateNetworkSettingsResponse will be returned.
func (p *DeviceSettingsUpdateNetworkSettingsPoller) FinalResponse(ctx context.Context) (DeviceSettingsUpdateNetworkSettingsResponse, error) {
	respType := DeviceSettingsUpdateNetworkSettingsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.NetworkSettings)
	if err != nil {
		return DeviceSettingsUpdateNetworkSettingsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeviceSettingsUpdateNetworkSettingsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DeviceSettingsUpdateSecuritySettingsPoller provides polling facilities until the operation reaches a terminal state.
type DeviceSettingsUpdateSecuritySettingsPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DeviceSettingsUpdateSecuritySettingsPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DeviceSettingsUpdateSecuritySettingsPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DeviceSettingsUpdateSecuritySettingsResponse will be returned.
func (p *DeviceSettingsUpdateSecuritySettingsPoller) FinalResponse(ctx context.Context) (DeviceSettingsUpdateSecuritySettingsResponse, error) {
	respType := DeviceSettingsUpdateSecuritySettingsResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.SecuritySettings)
	if err != nil {
		return DeviceSettingsUpdateSecuritySettingsResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DeviceSettingsUpdateSecuritySettingsPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DevicesConfigurePoller provides polling facilities until the operation reaches a terminal state.
type DevicesConfigurePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DevicesConfigurePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DevicesConfigurePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DevicesConfigureResponse will be returned.
func (p *DevicesConfigurePoller) FinalResponse(ctx context.Context) (DevicesConfigureResponse, error) {
	respType := DevicesConfigureResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DevicesConfigureResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DevicesConfigurePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DevicesDeactivatePoller provides polling facilities until the operation reaches a terminal state.
type DevicesDeactivatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DevicesDeactivatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DevicesDeactivatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DevicesDeactivateResponse will be returned.
func (p *DevicesDeactivatePoller) FinalResponse(ctx context.Context) (DevicesDeactivateResponse, error) {
	respType := DevicesDeactivateResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DevicesDeactivateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DevicesDeactivatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DevicesDeletePoller provides polling facilities until the operation reaches a terminal state.
type DevicesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DevicesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DevicesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DevicesDeleteResponse will be returned.
func (p *DevicesDeletePoller) FinalResponse(ctx context.Context) (DevicesDeleteResponse, error) {
	respType := DevicesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DevicesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DevicesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DevicesFailoverPoller provides polling facilities until the operation reaches a terminal state.
type DevicesFailoverPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DevicesFailoverPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DevicesFailoverPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DevicesFailoverResponse will be returned.
func (p *DevicesFailoverPoller) FinalResponse(ctx context.Context) (DevicesFailoverResponse, error) {
	respType := DevicesFailoverResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DevicesFailoverResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DevicesFailoverPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DevicesInstallUpdatesPoller provides polling facilities until the operation reaches a terminal state.
type DevicesInstallUpdatesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DevicesInstallUpdatesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DevicesInstallUpdatesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DevicesInstallUpdatesResponse will be returned.
func (p *DevicesInstallUpdatesPoller) FinalResponse(ctx context.Context) (DevicesInstallUpdatesResponse, error) {
	respType := DevicesInstallUpdatesResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DevicesInstallUpdatesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DevicesInstallUpdatesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// DevicesScanForUpdatesPoller provides polling facilities until the operation reaches a terminal state.
type DevicesScanForUpdatesPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *DevicesScanForUpdatesPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *DevicesScanForUpdatesPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final DevicesScanForUpdatesResponse will be returned.
func (p *DevicesScanForUpdatesPoller) FinalResponse(ctx context.Context) (DevicesScanForUpdatesResponse, error) {
	respType := DevicesScanForUpdatesResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return DevicesScanForUpdatesResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *DevicesScanForUpdatesPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// HardwareComponentGroupsChangeControllerPowerStatePoller provides polling facilities until the operation reaches a terminal state.
type HardwareComponentGroupsChangeControllerPowerStatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *HardwareComponentGroupsChangeControllerPowerStatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *HardwareComponentGroupsChangeControllerPowerStatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final HardwareComponentGroupsChangeControllerPowerStateResponse will be returned.
func (p *HardwareComponentGroupsChangeControllerPowerStatePoller) FinalResponse(ctx context.Context) (HardwareComponentGroupsChangeControllerPowerStateResponse, error) {
	respType := HardwareComponentGroupsChangeControllerPowerStateResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return HardwareComponentGroupsChangeControllerPowerStateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *HardwareComponentGroupsChangeControllerPowerStatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// JobsCancelPoller provides polling facilities until the operation reaches a terminal state.
type JobsCancelPoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *JobsCancelPoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *JobsCancelPoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final JobsCancelResponse will be returned.
func (p *JobsCancelPoller) FinalResponse(ctx context.Context) (JobsCancelResponse, error) {
	respType := JobsCancelResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return JobsCancelResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *JobsCancelPoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// StorageAccountCredentialsCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type StorageAccountCredentialsCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *StorageAccountCredentialsCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *StorageAccountCredentialsCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final StorageAccountCredentialsCreateOrUpdateResponse will be returned.
func (p *StorageAccountCredentialsCreateOrUpdatePoller) FinalResponse(ctx context.Context) (StorageAccountCredentialsCreateOrUpdateResponse, error) {
	respType := StorageAccountCredentialsCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.StorageAccountCredential)
	if err != nil {
		return StorageAccountCredentialsCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *StorageAccountCredentialsCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// StorageAccountCredentialsDeletePoller provides polling facilities until the operation reaches a terminal state.
type StorageAccountCredentialsDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *StorageAccountCredentialsDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *StorageAccountCredentialsDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final StorageAccountCredentialsDeleteResponse will be returned.
func (p *StorageAccountCredentialsDeletePoller) FinalResponse(ctx context.Context) (StorageAccountCredentialsDeleteResponse, error) {
	respType := StorageAccountCredentialsDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return StorageAccountCredentialsDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *StorageAccountCredentialsDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VolumeContainersCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VolumeContainersCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VolumeContainersCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VolumeContainersCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VolumeContainersCreateOrUpdateResponse will be returned.
func (p *VolumeContainersCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VolumeContainersCreateOrUpdateResponse, error) {
	respType := VolumeContainersCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.VolumeContainer)
	if err != nil {
		return VolumeContainersCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VolumeContainersCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VolumeContainersDeletePoller provides polling facilities until the operation reaches a terminal state.
type VolumeContainersDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VolumeContainersDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VolumeContainersDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VolumeContainersDeleteResponse will be returned.
func (p *VolumeContainersDeletePoller) FinalResponse(ctx context.Context) (VolumeContainersDeleteResponse, error) {
	respType := VolumeContainersDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VolumeContainersDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VolumeContainersDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VolumesCreateOrUpdatePoller provides polling facilities until the operation reaches a terminal state.
type VolumesCreateOrUpdatePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VolumesCreateOrUpdatePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VolumesCreateOrUpdatePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VolumesCreateOrUpdateResponse will be returned.
func (p *VolumesCreateOrUpdatePoller) FinalResponse(ctx context.Context) (VolumesCreateOrUpdateResponse, error) {
	respType := VolumesCreateOrUpdateResponse{}
	resp, err := p.pt.FinalResponse(ctx, &respType.Volume)
	if err != nil {
		return VolumesCreateOrUpdateResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VolumesCreateOrUpdatePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}

// VolumesDeletePoller provides polling facilities until the operation reaches a terminal state.
type VolumesDeletePoller struct {
	pt *azcore.Poller
}

// Done returns true if the LRO has reached a terminal state.
func (p *VolumesDeletePoller) Done() bool {
	return p.pt.Done()
}

// Poll fetches the latest state of the LRO.  It returns an HTTP response or error.
// If the LRO has completed successfully, the poller's state is updated and the HTTP
// response is returned.
// If the LRO has completed with failure or was cancelled, the poller's state is
// updated and the error is returned.
// If the LRO has not reached a terminal state, the poller's state is updated and
// the latest HTTP response is returned.
// If Poll fails, the poller's state is unmodified and the error is returned.
// Calling Poll on an LRO that has reached a terminal state will return the final
// HTTP response or error.
func (p *VolumesDeletePoller) Poll(ctx context.Context) (*http.Response, error) {
	return p.pt.Poll(ctx)
}

// FinalResponse performs a final GET to the service and returns the final response
// for the polling operation. If there is an error performing the final GET then an error is returned.
// If the final GET succeeded then the final VolumesDeleteResponse will be returned.
func (p *VolumesDeletePoller) FinalResponse(ctx context.Context) (VolumesDeleteResponse, error) {
	respType := VolumesDeleteResponse{}
	resp, err := p.pt.FinalResponse(ctx, nil)
	if err != nil {
		return VolumesDeleteResponse{}, err
	}
	respType.RawResponse = resp
	return respType, nil
}

// ResumeToken returns a value representing the poller that can be used to resume
// the LRO at a later time. ResumeTokens are unique per service operation.
func (p *VolumesDeletePoller) ResumeToken() (string, error) {
	return p.pt.ResumeToken()
}
