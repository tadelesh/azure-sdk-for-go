//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armstorsimple8000series

import (
	"context"
	"errors"
	"net/http"
	"strings"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
)

// ManagersClient contains the methods for the Managers group.
// Don't use this type directly, use NewManagersClient() instead.
type ManagersClient struct {
	ep             string
	pl             runtime.Pipeline
	subscriptionID string
}

// NewManagersClient creates a new instance of ManagersClient with the specified values.
func NewManagersClient(con *arm.Connection, subscriptionID string) *ManagersClient {
	return &ManagersClient{ep: con.Endpoint(), pl: con.NewPipeline(module, version), subscriptionID: subscriptionID}
}

// CreateExtendedInfo - Creates the extended info of the manager.
// If the operation fails it returns a generic error.
func (client *ManagersClient) CreateExtendedInfo(ctx context.Context, resourceGroupName string, managerName string, parameters ManagerExtendedInfo, options *ManagersCreateExtendedInfoOptions) (ManagersCreateExtendedInfoResponse, error) {
	req, err := client.createExtendedInfoCreateRequest(ctx, resourceGroupName, managerName, parameters, options)
	if err != nil {
		return ManagersCreateExtendedInfoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagersCreateExtendedInfoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ManagersCreateExtendedInfoResponse{}, client.createExtendedInfoHandleError(resp)
	}
	return client.createExtendedInfoHandleResponse(resp)
}

// createExtendedInfoCreateRequest creates the CreateExtendedInfo request.
func (client *ManagersClient) createExtendedInfoCreateRequest(ctx context.Context, resourceGroupName string, managerName string, parameters ManagerExtendedInfo, options *ManagersCreateExtendedInfoOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/extendedInformation/vaultExtendedInfo"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// createExtendedInfoHandleResponse handles the CreateExtendedInfo response.
func (client *ManagersClient) createExtendedInfoHandleResponse(resp *http.Response) (ManagersCreateExtendedInfoResponse, error) {
	result := ManagersCreateExtendedInfoResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ManagerExtendedInfo); err != nil {
		return ManagersCreateExtendedInfoResponse{}, err
	}
	return result, nil
}

// createExtendedInfoHandleError handles the CreateExtendedInfo error response.
func (client *ManagersClient) createExtendedInfoHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// CreateOrUpdate - Creates or updates the manager.
// If the operation fails it returns a generic error.
func (client *ManagersClient) CreateOrUpdate(ctx context.Context, resourceGroupName string, managerName string, parameters Manager, options *ManagersCreateOrUpdateOptions) (ManagersCreateOrUpdateResponse, error) {
	req, err := client.createOrUpdateCreateRequest(ctx, resourceGroupName, managerName, parameters, options)
	if err != nil {
		return ManagersCreateOrUpdateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagersCreateOrUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusCreated) {
		return ManagersCreateOrUpdateResponse{}, client.createOrUpdateHandleError(resp)
	}
	return client.createOrUpdateHandleResponse(resp)
}

// createOrUpdateCreateRequest creates the CreateOrUpdate request.
func (client *ManagersClient) createOrUpdateCreateRequest(ctx context.Context, resourceGroupName string, managerName string, parameters Manager, options *ManagersCreateOrUpdateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPut, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// createOrUpdateHandleResponse handles the CreateOrUpdate response.
func (client *ManagersClient) createOrUpdateHandleResponse(resp *http.Response) (ManagersCreateOrUpdateResponse, error) {
	result := ManagersCreateOrUpdateResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Manager); err != nil {
		return ManagersCreateOrUpdateResponse{}, err
	}
	return result, nil
}

// createOrUpdateHandleError handles the CreateOrUpdate error response.
func (client *ManagersClient) createOrUpdateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// Delete - Deletes the manager.
// If the operation fails it returns a generic error.
func (client *ManagersClient) Delete(ctx context.Context, resourceGroupName string, managerName string, options *ManagersDeleteOptions) (ManagersDeleteResponse, error) {
	req, err := client.deleteCreateRequest(ctx, resourceGroupName, managerName, options)
	if err != nil {
		return ManagersDeleteResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagersDeleteResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK, http.StatusNoContent) {
		return ManagersDeleteResponse{}, client.deleteHandleError(resp)
	}
	return ManagersDeleteResponse{RawResponse: resp}, nil
}

// deleteCreateRequest creates the Delete request.
func (client *ManagersClient) deleteCreateRequest(ctx context.Context, resourceGroupName string, managerName string, options *ManagersDeleteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// deleteHandleError handles the Delete error response.
func (client *ManagersClient) deleteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// DeleteExtendedInfo - Deletes the extended info of the manager.
// If the operation fails it returns a generic error.
func (client *ManagersClient) DeleteExtendedInfo(ctx context.Context, resourceGroupName string, managerName string, options *ManagersDeleteExtendedInfoOptions) (ManagersDeleteExtendedInfoResponse, error) {
	req, err := client.deleteExtendedInfoCreateRequest(ctx, resourceGroupName, managerName, options)
	if err != nil {
		return ManagersDeleteExtendedInfoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagersDeleteExtendedInfoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return ManagersDeleteExtendedInfoResponse{}, client.deleteExtendedInfoHandleError(resp)
	}
	return ManagersDeleteExtendedInfoResponse{RawResponse: resp}, nil
}

// deleteExtendedInfoCreateRequest creates the DeleteExtendedInfo request.
func (client *ManagersClient) deleteExtendedInfoCreateRequest(ctx context.Context, resourceGroupName string, managerName string, options *ManagersDeleteExtendedInfoOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/extendedInformation/vaultExtendedInfo"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// deleteExtendedInfoHandleError handles the DeleteExtendedInfo error response.
func (client *ManagersClient) deleteExtendedInfoHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// Get - Returns the properties of the specified manager name.
// If the operation fails it returns a generic error.
func (client *ManagersClient) Get(ctx context.Context, resourceGroupName string, managerName string, options *ManagersGetOptions) (ManagersGetResponse, error) {
	req, err := client.getCreateRequest(ctx, resourceGroupName, managerName, options)
	if err != nil {
		return ManagersGetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagersGetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ManagersGetResponse{}, client.getHandleError(resp)
	}
	return client.getHandleResponse(resp)
}

// getCreateRequest creates the Get request.
func (client *ManagersClient) getCreateRequest(ctx context.Context, resourceGroupName string, managerName string, options *ManagersGetOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *ManagersClient) getHandleResponse(resp *http.Response) (ManagersGetResponse, error) {
	result := ManagersGetResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Manager); err != nil {
		return ManagersGetResponse{}, err
	}
	return result, nil
}

// getHandleError handles the Get error response.
func (client *ManagersClient) getHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// GetActivationKey - Returns the activation key of the manager.
// If the operation fails it returns a generic error.
func (client *ManagersClient) GetActivationKey(ctx context.Context, resourceGroupName string, managerName string, options *ManagersGetActivationKeyOptions) (ManagersGetActivationKeyResponse, error) {
	req, err := client.getActivationKeyCreateRequest(ctx, resourceGroupName, managerName, options)
	if err != nil {
		return ManagersGetActivationKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagersGetActivationKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ManagersGetActivationKeyResponse{}, client.getActivationKeyHandleError(resp)
	}
	return client.getActivationKeyHandleResponse(resp)
}

// getActivationKeyCreateRequest creates the GetActivationKey request.
func (client *ManagersClient) getActivationKeyCreateRequest(ctx context.Context, resourceGroupName string, managerName string, options *ManagersGetActivationKeyOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/listActivationKey"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getActivationKeyHandleResponse handles the GetActivationKey response.
func (client *ManagersClient) getActivationKeyHandleResponse(resp *http.Response) (ManagersGetActivationKeyResponse, error) {
	result := ManagersGetActivationKeyResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Key); err != nil {
		return ManagersGetActivationKeyResponse{}, err
	}
	return result, nil
}

// getActivationKeyHandleError handles the GetActivationKey error response.
func (client *ManagersClient) getActivationKeyHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// GetDevicePublicEncryptionKey - Returns the public encryption key of the device.
// If the operation fails it returns a generic error.
func (client *ManagersClient) GetDevicePublicEncryptionKey(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *ManagersGetDevicePublicEncryptionKeyOptions) (ManagersGetDevicePublicEncryptionKeyResponse, error) {
	req, err := client.getDevicePublicEncryptionKeyCreateRequest(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return ManagersGetDevicePublicEncryptionKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagersGetDevicePublicEncryptionKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ManagersGetDevicePublicEncryptionKeyResponse{}, client.getDevicePublicEncryptionKeyHandleError(resp)
	}
	return client.getDevicePublicEncryptionKeyHandleResponse(resp)
}

// getDevicePublicEncryptionKeyCreateRequest creates the GetDevicePublicEncryptionKey request.
func (client *ManagersClient) getDevicePublicEncryptionKeyCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *ManagersGetDevicePublicEncryptionKeyOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}/publicEncryptionKey"
	if deviceName == "" {
		return nil, errors.New("parameter deviceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getDevicePublicEncryptionKeyHandleResponse handles the GetDevicePublicEncryptionKey response.
func (client *ManagersClient) getDevicePublicEncryptionKeyHandleResponse(resp *http.Response) (ManagersGetDevicePublicEncryptionKeyResponse, error) {
	result := ManagersGetDevicePublicEncryptionKeyResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.PublicKey); err != nil {
		return ManagersGetDevicePublicEncryptionKeyResponse{}, err
	}
	return result, nil
}

// getDevicePublicEncryptionKeyHandleError handles the GetDevicePublicEncryptionKey error response.
func (client *ManagersClient) getDevicePublicEncryptionKeyHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// GetEncryptionSettings - Returns the encryption settings of the manager.
// If the operation fails it returns a generic error.
func (client *ManagersClient) GetEncryptionSettings(ctx context.Context, resourceGroupName string, managerName string, options *ManagersGetEncryptionSettingsOptions) (ManagersGetEncryptionSettingsResponse, error) {
	req, err := client.getEncryptionSettingsCreateRequest(ctx, resourceGroupName, managerName, options)
	if err != nil {
		return ManagersGetEncryptionSettingsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagersGetEncryptionSettingsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ManagersGetEncryptionSettingsResponse{}, client.getEncryptionSettingsHandleError(resp)
	}
	return client.getEncryptionSettingsHandleResponse(resp)
}

// getEncryptionSettingsCreateRequest creates the GetEncryptionSettings request.
func (client *ManagersClient) getEncryptionSettingsCreateRequest(ctx context.Context, resourceGroupName string, managerName string, options *ManagersGetEncryptionSettingsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/encryptionSettings/default"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getEncryptionSettingsHandleResponse handles the GetEncryptionSettings response.
func (client *ManagersClient) getEncryptionSettingsHandleResponse(resp *http.Response) (ManagersGetEncryptionSettingsResponse, error) {
	result := ManagersGetEncryptionSettingsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.EncryptionSettings); err != nil {
		return ManagersGetEncryptionSettingsResponse{}, err
	}
	return result, nil
}

// getEncryptionSettingsHandleError handles the GetEncryptionSettings error response.
func (client *ManagersClient) getEncryptionSettingsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// GetExtendedInfo - Returns the extended information of the specified manager name.
// If the operation fails it returns a generic error.
func (client *ManagersClient) GetExtendedInfo(ctx context.Context, resourceGroupName string, managerName string, options *ManagersGetExtendedInfoOptions) (ManagersGetExtendedInfoResponse, error) {
	req, err := client.getExtendedInfoCreateRequest(ctx, resourceGroupName, managerName, options)
	if err != nil {
		return ManagersGetExtendedInfoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagersGetExtendedInfoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ManagersGetExtendedInfoResponse{}, client.getExtendedInfoHandleError(resp)
	}
	return client.getExtendedInfoHandleResponse(resp)
}

// getExtendedInfoCreateRequest creates the GetExtendedInfo request.
func (client *ManagersClient) getExtendedInfoCreateRequest(ctx context.Context, resourceGroupName string, managerName string, options *ManagersGetExtendedInfoOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/extendedInformation/vaultExtendedInfo"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getExtendedInfoHandleResponse handles the GetExtendedInfo response.
func (client *ManagersClient) getExtendedInfoHandleResponse(resp *http.Response) (ManagersGetExtendedInfoResponse, error) {
	result := ManagersGetExtendedInfoResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ManagerExtendedInfo); err != nil {
		return ManagersGetExtendedInfoResponse{}, err
	}
	return result, nil
}

// getExtendedInfoHandleError handles the GetExtendedInfo error response.
func (client *ManagersClient) getExtendedInfoHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// GetPublicEncryptionKey - Returns the symmetric encrypted public encryption key of the manager.
// If the operation fails it returns a generic error.
func (client *ManagersClient) GetPublicEncryptionKey(ctx context.Context, resourceGroupName string, managerName string, options *ManagersGetPublicEncryptionKeyOptions) (ManagersGetPublicEncryptionKeyResponse, error) {
	req, err := client.getPublicEncryptionKeyCreateRequest(ctx, resourceGroupName, managerName, options)
	if err != nil {
		return ManagersGetPublicEncryptionKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagersGetPublicEncryptionKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ManagersGetPublicEncryptionKeyResponse{}, client.getPublicEncryptionKeyHandleError(resp)
	}
	return client.getPublicEncryptionKeyHandleResponse(resp)
}

// getPublicEncryptionKeyCreateRequest creates the GetPublicEncryptionKey request.
func (client *ManagersClient) getPublicEncryptionKeyCreateRequest(ctx context.Context, resourceGroupName string, managerName string, options *ManagersGetPublicEncryptionKeyOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/listPublicEncryptionKey"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getPublicEncryptionKeyHandleResponse handles the GetPublicEncryptionKey response.
func (client *ManagersClient) getPublicEncryptionKeyHandleResponse(resp *http.Response) (ManagersGetPublicEncryptionKeyResponse, error) {
	result := ManagersGetPublicEncryptionKeyResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.SymmetricEncryptedSecret); err != nil {
		return ManagersGetPublicEncryptionKeyResponse{}, err
	}
	return result, nil
}

// getPublicEncryptionKeyHandleError handles the GetPublicEncryptionKey error response.
func (client *ManagersClient) getPublicEncryptionKeyHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// List - Retrieves all the managers in a subscription.
// If the operation fails it returns a generic error.
func (client *ManagersClient) List(ctx context.Context, options *ManagersListOptions) (ManagersListResponse, error) {
	req, err := client.listCreateRequest(ctx, options)
	if err != nil {
		return ManagersListResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagersListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ManagersListResponse{}, client.listHandleError(resp)
	}
	return client.listHandleResponse(resp)
}

// listCreateRequest creates the List request.
func (client *ManagersClient) listCreateRequest(ctx context.Context, options *ManagersListOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/providers/Microsoft.StorSimple/managers"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listHandleResponse handles the List response.
func (client *ManagersClient) listHandleResponse(resp *http.Response) (ManagersListResponse, error) {
	result := ManagersListResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ManagerList); err != nil {
		return ManagersListResponse{}, err
	}
	return result, nil
}

// listHandleError handles the List error response.
func (client *ManagersClient) listHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// ListByResourceGroup - Retrieves all the managers in a resource group.
// If the operation fails it returns a generic error.
func (client *ManagersClient) ListByResourceGroup(ctx context.Context, resourceGroupName string, options *ManagersListByResourceGroupOptions) (ManagersListByResourceGroupResponse, error) {
	req, err := client.listByResourceGroupCreateRequest(ctx, resourceGroupName, options)
	if err != nil {
		return ManagersListByResourceGroupResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagersListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ManagersListByResourceGroupResponse{}, client.listByResourceGroupHandleError(resp)
	}
	return client.listByResourceGroupHandleResponse(resp)
}

// listByResourceGroupCreateRequest creates the ListByResourceGroup request.
func (client *ManagersClient) listByResourceGroupCreateRequest(ctx context.Context, resourceGroupName string, options *ManagersListByResourceGroupOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listByResourceGroupHandleResponse handles the ListByResourceGroup response.
func (client *ManagersClient) listByResourceGroupHandleResponse(resp *http.Response) (ManagersListByResourceGroupResponse, error) {
	result := ManagersListByResourceGroupResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ManagerList); err != nil {
		return ManagersListByResourceGroupResponse{}, err
	}
	return result, nil
}

// listByResourceGroupHandleError handles the ListByResourceGroup error response.
func (client *ManagersClient) listByResourceGroupHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// ListFeatureSupportStatus - Lists the features and their support status
// If the operation fails it returns a generic error.
func (client *ManagersClient) ListFeatureSupportStatus(ctx context.Context, resourceGroupName string, managerName string, options *ManagersListFeatureSupportStatusOptions) (ManagersListFeatureSupportStatusResponse, error) {
	req, err := client.listFeatureSupportStatusCreateRequest(ctx, resourceGroupName, managerName, options)
	if err != nil {
		return ManagersListFeatureSupportStatusResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagersListFeatureSupportStatusResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ManagersListFeatureSupportStatusResponse{}, client.listFeatureSupportStatusHandleError(resp)
	}
	return client.listFeatureSupportStatusHandleResponse(resp)
}

// listFeatureSupportStatusCreateRequest creates the ListFeatureSupportStatus request.
func (client *ManagersClient) listFeatureSupportStatusCreateRequest(ctx context.Context, resourceGroupName string, managerName string, options *ManagersListFeatureSupportStatusOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/features"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	if options != nil && options.Filter != nil {
		reqQP.Set("$filter", *options.Filter)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listFeatureSupportStatusHandleResponse handles the ListFeatureSupportStatus response.
func (client *ManagersClient) listFeatureSupportStatusHandleResponse(resp *http.Response) (ManagersListFeatureSupportStatusResponse, error) {
	result := ManagersListFeatureSupportStatusResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.FeatureList); err != nil {
		return ManagersListFeatureSupportStatusResponse{}, err
	}
	return result, nil
}

// listFeatureSupportStatusHandleError handles the ListFeatureSupportStatus error response.
func (client *ManagersClient) listFeatureSupportStatusHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// ListMetricDefinition - Gets the metric definitions for the specified manager.
// If the operation fails it returns a generic error.
func (client *ManagersClient) ListMetricDefinition(ctx context.Context, resourceGroupName string, managerName string, options *ManagersListMetricDefinitionOptions) (ManagersListMetricDefinitionResponse, error) {
	req, err := client.listMetricDefinitionCreateRequest(ctx, resourceGroupName, managerName, options)
	if err != nil {
		return ManagersListMetricDefinitionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagersListMetricDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ManagersListMetricDefinitionResponse{}, client.listMetricDefinitionHandleError(resp)
	}
	return client.listMetricDefinitionHandleResponse(resp)
}

// listMetricDefinitionCreateRequest creates the ListMetricDefinition request.
func (client *ManagersClient) listMetricDefinitionCreateRequest(ctx context.Context, resourceGroupName string, managerName string, options *ManagersListMetricDefinitionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/metricsDefinitions"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listMetricDefinitionHandleResponse handles the ListMetricDefinition response.
func (client *ManagersClient) listMetricDefinitionHandleResponse(resp *http.Response) (ManagersListMetricDefinitionResponse, error) {
	result := ManagersListMetricDefinitionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.MetricDefinitionList); err != nil {
		return ManagersListMetricDefinitionResponse{}, err
	}
	return result, nil
}

// listMetricDefinitionHandleError handles the ListMetricDefinition error response.
func (client *ManagersClient) listMetricDefinitionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// ListMetrics - Gets the metrics for the specified manager.
// If the operation fails it returns a generic error.
func (client *ManagersClient) ListMetrics(ctx context.Context, resourceGroupName string, managerName string, filter string, options *ManagersListMetricsOptions) (ManagersListMetricsResponse, error) {
	req, err := client.listMetricsCreateRequest(ctx, resourceGroupName, managerName, filter, options)
	if err != nil {
		return ManagersListMetricsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagersListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ManagersListMetricsResponse{}, client.listMetricsHandleError(resp)
	}
	return client.listMetricsHandleResponse(resp)
}

// listMetricsCreateRequest creates the ListMetrics request.
func (client *ManagersClient) listMetricsCreateRequest(ctx context.Context, resourceGroupName string, managerName string, filter string, options *ManagersListMetricsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/metrics"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	reqQP.Set("$filter", filter)
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listMetricsHandleResponse handles the ListMetrics response.
func (client *ManagersClient) listMetricsHandleResponse(resp *http.Response) (ManagersListMetricsResponse, error) {
	result := ManagersListMetricsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.MetricList); err != nil {
		return ManagersListMetricsResponse{}, err
	}
	return result, nil
}

// listMetricsHandleError handles the ListMetrics error response.
func (client *ManagersClient) listMetricsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// RegenerateActivationKey - Re-generates and returns the activation key of the manager.
// If the operation fails it returns a generic error.
func (client *ManagersClient) RegenerateActivationKey(ctx context.Context, resourceGroupName string, managerName string, options *ManagersRegenerateActivationKeyOptions) (ManagersRegenerateActivationKeyResponse, error) {
	req, err := client.regenerateActivationKeyCreateRequest(ctx, resourceGroupName, managerName, options)
	if err != nil {
		return ManagersRegenerateActivationKeyResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagersRegenerateActivationKeyResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ManagersRegenerateActivationKeyResponse{}, client.regenerateActivationKeyHandleError(resp)
	}
	return client.regenerateActivationKeyHandleResponse(resp)
}

// regenerateActivationKeyCreateRequest creates the RegenerateActivationKey request.
func (client *ManagersClient) regenerateActivationKeyCreateRequest(ctx context.Context, resourceGroupName string, managerName string, options *ManagersRegenerateActivationKeyOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/regenerateActivationKey"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// regenerateActivationKeyHandleResponse handles the RegenerateActivationKey response.
func (client *ManagersClient) regenerateActivationKeyHandleResponse(resp *http.Response) (ManagersRegenerateActivationKeyResponse, error) {
	result := ManagersRegenerateActivationKeyResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Key); err != nil {
		return ManagersRegenerateActivationKeyResponse{}, err
	}
	return result, nil
}

// regenerateActivationKeyHandleError handles the RegenerateActivationKey error response.
func (client *ManagersClient) regenerateActivationKeyHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// Update - Updates the StorSimple Manager.
// If the operation fails it returns a generic error.
func (client *ManagersClient) Update(ctx context.Context, resourceGroupName string, managerName string, parameters ManagerPatch, options *ManagersUpdateOptions) (ManagersUpdateResponse, error) {
	req, err := client.updateCreateRequest(ctx, resourceGroupName, managerName, parameters, options)
	if err != nil {
		return ManagersUpdateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagersUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ManagersUpdateResponse{}, client.updateHandleError(resp)
	}
	return client.updateHandleResponse(resp)
}

// updateCreateRequest creates the Update request.
func (client *ManagersClient) updateCreateRequest(ctx context.Context, resourceGroupName string, managerName string, parameters ManagerPatch, options *ManagersUpdateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// updateHandleResponse handles the Update response.
func (client *ManagersClient) updateHandleResponse(resp *http.Response) (ManagersUpdateResponse, error) {
	result := ManagersUpdateResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Manager); err != nil {
		return ManagersUpdateResponse{}, err
	}
	return result, nil
}

// updateHandleError handles the Update error response.
func (client *ManagersClient) updateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// UpdateExtendedInfo - Updates the extended info of the manager.
// If the operation fails it returns a generic error.
func (client *ManagersClient) UpdateExtendedInfo(ctx context.Context, resourceGroupName string, managerName string, ifMatch string, parameters ManagerExtendedInfo, options *ManagersUpdateExtendedInfoOptions) (ManagersUpdateExtendedInfoResponse, error) {
	req, err := client.updateExtendedInfoCreateRequest(ctx, resourceGroupName, managerName, ifMatch, parameters, options)
	if err != nil {
		return ManagersUpdateExtendedInfoResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return ManagersUpdateExtendedInfoResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return ManagersUpdateExtendedInfoResponse{}, client.updateExtendedInfoHandleError(resp)
	}
	return client.updateExtendedInfoHandleResponse(resp)
}

// updateExtendedInfoCreateRequest creates the UpdateExtendedInfo request.
func (client *ManagersClient) updateExtendedInfoCreateRequest(ctx context.Context, resourceGroupName string, managerName string, ifMatch string, parameters ManagerExtendedInfo, options *ManagersUpdateExtendedInfoOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/extendedInformation/vaultExtendedInfo"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("If-Match", ifMatch)
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// updateExtendedInfoHandleResponse handles the UpdateExtendedInfo response.
func (client *ManagersClient) updateExtendedInfoHandleResponse(resp *http.Response) (ManagersUpdateExtendedInfoResponse, error) {
	result := ManagersUpdateExtendedInfoResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.ManagerExtendedInfo); err != nil {
		return ManagersUpdateExtendedInfoResponse{}, err
	}
	return result, nil
}

// updateExtendedInfoHandleError handles the UpdateExtendedInfo error response.
func (client *ManagersClient) updateExtendedInfoHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}
