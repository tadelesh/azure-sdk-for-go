//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armstorsimple8000series

import (
	"encoding/json"
	"reflect"
	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
)

// AccessControlRecord - The access control record.
type AccessControlRecord struct {
	BaseModel
	// REQUIRED; The properties of access control record.
	Properties *AccessControlRecordProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AccessControlRecord.
func (a AccessControlRecord) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AccessControlRecord.
func (a *AccessControlRecord) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AccessControlRecordList - The collection of access control records.
type AccessControlRecordList struct {
	// REQUIRED; The value.
	Value []*AccessControlRecord `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AccessControlRecordList.
func (a AccessControlRecordList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AccessControlRecordProperties - The properties of access control record.
type AccessControlRecordProperties struct {
	// REQUIRED; The iSCSI initiator name (IQN).
	InitiatorName *string `json:"initiatorName,omitempty"`

	// READ-ONLY; The number of volumes using the access control record.
	VolumeCount *int32 `json:"volumeCount,omitempty" azure:"ro"`
}

// AccessControlRecordsBeginCreateOrUpdateOptions contains the optional parameters for the AccessControlRecords.BeginCreateOrUpdate method.
type AccessControlRecordsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// AccessControlRecordsBeginDeleteOptions contains the optional parameters for the AccessControlRecords.BeginDelete method.
type AccessControlRecordsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// AccessControlRecordsGetOptions contains the optional parameters for the AccessControlRecords.Get method.
type AccessControlRecordsGetOptions struct {
	// placeholder for future optional parameters
}

// AccessControlRecordsListByManagerOptions contains the optional parameters for the AccessControlRecords.ListByManager method.
type AccessControlRecordsListByManagerOptions struct {
	// placeholder for future optional parameters
}

// AcsConfiguration - The ACS configuration.
type AcsConfiguration struct {
	// REQUIRED; The namespace.
	Namespace *string `json:"namespace,omitempty"`

	// REQUIRED; The realm.
	Realm *string `json:"realm,omitempty"`

	// REQUIRED; The service URL.
	ServiceURL *string `json:"serviceUrl,omitempty"`
}

// Alert - The alert.
type Alert struct {
	BaseModel
	// REQUIRED; The properties of the alert.
	Properties *AlertProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Alert.
func (a Alert) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Alert.
func (a *Alert) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AlertErrorDetails - The details of the error for which the alert was raised
type AlertErrorDetails struct {
	// The error code
	ErrorCode *string `json:"errorCode,omitempty"`

	// The error message
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// The number of occurrences
	Occurences *int32 `json:"occurences,omitempty"`
}

// AlertFilter - The OData filters to be used for Alert
type AlertFilter struct {
	// Specifies the appeared time (in UTC) of the alerts to be filtered. Only 'Greater-Than' and 'Lesser-Than' operators are supported for this property.
	AppearedOnTime *time.Time `json:"appearedOnTime,omitempty"`

	// Specifies the severity of the alerts to be filtered. Only 'Equality' operator is supported for this property.
	Severity *AlertSeverity `json:"severity,omitempty"`

	// Specifies the source name of the alerts to be filtered. Only 'Equality' operator is supported for this property.
	SourceName *string `json:"sourceName,omitempty"`

	// Specifies the source type of the alerts to be filtered. Only 'Equality' operator is supported for this property.
	SourceType *AlertSourceType `json:"sourceType,omitempty"`

	// Specifies the status of the alerts to be filtered. Only 'Equality' operator is supported for this property.
	Status *AlertStatus `json:"status,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AlertFilter.
func (a AlertFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "appearedOnTime", (*timeRFC3339)(a.AppearedOnTime))
	populate(objectMap, "severity", a.Severity)
	populate(objectMap, "sourceName", a.SourceName)
	populate(objectMap, "sourceType", a.SourceType)
	populate(objectMap, "status", a.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AlertFilter.
func (a *AlertFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "appearedOnTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			a.AppearedOnTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &a.Severity)
			delete(rawMsg, key)
		case "sourceName":
			err = unpopulate(val, &a.SourceName)
			delete(rawMsg, key)
		case "sourceType":
			err = unpopulate(val, &a.SourceType)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &a.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AlertList - The collection of alerts.
type AlertList struct {
	// REQUIRED; The value.
	Value []*Alert `json:"value,omitempty"`

	// The URI of the next page of alerts.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AlertList.
func (a AlertList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// AlertNotificationProperties - The properties of the alert notification settings.
type AlertNotificationProperties struct {
	// REQUIRED; Indicates whether email notification enabled or not.
	EmailNotification *AlertEmailNotificationStatus `json:"emailNotification,omitempty"`

	// The alert notification email list.
	AdditionalRecipientEmailList []*string `json:"additionalRecipientEmailList,omitempty"`

	// The alert notification culture.
	AlertNotificationCulture *string `json:"alertNotificationCulture,omitempty"`

	// The value indicating whether alert notification enabled for admin or not.
	NotificationToServiceOwners *AlertEmailNotificationStatus `json:"notificationToServiceOwners,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AlertNotificationProperties.
func (a AlertNotificationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "additionalRecipientEmailList", a.AdditionalRecipientEmailList)
	populate(objectMap, "alertNotificationCulture", a.AlertNotificationCulture)
	populate(objectMap, "emailNotification", a.EmailNotification)
	populate(objectMap, "notificationToServiceOwners", a.NotificationToServiceOwners)
	return json.Marshal(objectMap)
}

// AlertProperties - The properties of alert
type AlertProperties struct {
	// REQUIRED; The type of the alert
	AlertType *string `json:"alertType,omitempty"`

	// REQUIRED; The source time at which the alert was raised
	AppearedAtSourceTime *time.Time `json:"appearedAtSourceTime,omitempty"`

	// REQUIRED; The UTC time at which the alert was raised
	AppearedAtTime *time.Time `json:"appearedAtTime,omitempty"`

	// REQUIRED; The scope of the alert
	Scope *AlertScope `json:"scope,omitempty"`

	// REQUIRED; The severity of the alert
	Severity *AlertSeverity `json:"severity,omitempty"`

	// REQUIRED; The source at which the alert was raised
	Source *AlertSource `json:"source,omitempty"`

	// REQUIRED; The current status of the alert
	Status *AlertStatus `json:"status,omitempty"`

	// REQUIRED; The title of the alert
	Title *string `json:"title,omitempty"`

	// The source time at which the alert was cleared
	ClearedAtSourceTime *time.Time `json:"clearedAtSourceTime,omitempty"`

	// The UTC time at which the alert was cleared
	ClearedAtTime *time.Time `json:"clearedAtTime,omitempty"`

	// More details about the alert
	DetailedInformation map[string]*string `json:"detailedInformation,omitempty"`

	// The details of the error for which the alert was raised
	ErrorDetails *AlertErrorDetails `json:"errorDetails,omitempty"`

	// The recommended action for the issue raised in the alert
	Recommendation *string `json:"recommendation,omitempty"`

	// The reason for resolving the alert
	ResolutionReason *string `json:"resolutionReason,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AlertProperties.
func (a AlertProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alertType", a.AlertType)
	populate(objectMap, "appearedAtSourceTime", (*timeRFC3339)(a.AppearedAtSourceTime))
	populate(objectMap, "appearedAtTime", (*timeRFC3339)(a.AppearedAtTime))
	populate(objectMap, "clearedAtSourceTime", (*timeRFC3339)(a.ClearedAtSourceTime))
	populate(objectMap, "clearedAtTime", (*timeRFC3339)(a.ClearedAtTime))
	populate(objectMap, "detailedInformation", a.DetailedInformation)
	populate(objectMap, "errorDetails", a.ErrorDetails)
	populate(objectMap, "recommendation", a.Recommendation)
	populate(objectMap, "resolutionReason", a.ResolutionReason)
	populate(objectMap, "scope", a.Scope)
	populate(objectMap, "severity", a.Severity)
	populate(objectMap, "source", a.Source)
	populate(objectMap, "status", a.Status)
	populate(objectMap, "title", a.Title)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AlertProperties.
func (a *AlertProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "alertType":
			err = unpopulate(val, &a.AlertType)
			delete(rawMsg, key)
		case "appearedAtSourceTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			a.AppearedAtSourceTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "appearedAtTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			a.AppearedAtTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "clearedAtSourceTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			a.ClearedAtSourceTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "clearedAtTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			a.ClearedAtTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "detailedInformation":
			err = unpopulate(val, &a.DetailedInformation)
			delete(rawMsg, key)
		case "errorDetails":
			err = unpopulate(val, &a.ErrorDetails)
			delete(rawMsg, key)
		case "recommendation":
			err = unpopulate(val, &a.Recommendation)
			delete(rawMsg, key)
		case "resolutionReason":
			err = unpopulate(val, &a.ResolutionReason)
			delete(rawMsg, key)
		case "scope":
			err = unpopulate(val, &a.Scope)
			delete(rawMsg, key)
		case "severity":
			err = unpopulate(val, &a.Severity)
			delete(rawMsg, key)
		case "source":
			err = unpopulate(val, &a.Source)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &a.Status)
			delete(rawMsg, key)
		case "title":
			err = unpopulate(val, &a.Title)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// AlertSettings - The alert settings.
type AlertSettings struct {
	BaseModel
	// REQUIRED; The properties of the alert notification settings.
	Properties *AlertNotificationProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AlertSettings.
func (a AlertSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	a.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", a.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type AlertSettings.
func (a *AlertSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &a.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := a.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// AlertSource - The source details at which the alert was raised
type AlertSource struct {
	// The source type of the alert
	AlertSourceType *AlertSourceType `json:"alertSourceType,omitempty"`

	// The name of the source
	Name *string `json:"name,omitempty"`

	// The time zone of the source
	TimeZone *string `json:"timeZone,omitempty"`
}

// AlertsClearOptions contains the optional parameters for the Alerts.Clear method.
type AlertsClearOptions struct {
	// placeholder for future optional parameters
}

// AlertsListByManagerOptions contains the optional parameters for the Alerts.ListByManager method.
type AlertsListByManagerOptions struct {
	// OData Filter options
	Filter *string
}

// AlertsSendTestEmailOptions contains the optional parameters for the Alerts.SendTestEmail method.
type AlertsSendTestEmailOptions struct {
	// placeholder for future optional parameters
}

// AsymmetricEncryptedSecret - Represent the secrets intended for encryption with asymmetric key pair.
type AsymmetricEncryptedSecret struct {
	// REQUIRED; The algorithm used to encrypt "Value".
	EncryptionAlgorithm *EncryptionAlgorithm `json:"encryptionAlgorithm,omitempty"`

	// REQUIRED; The value of the secret.
	Value *string `json:"value,omitempty"`

	// Thumbprint certificate that was used to encrypt "Value". If the value in unencrypted, it will be null.
	EncryptionCertThumbprint *string `json:"encryptionCertThumbprint,omitempty"`
}

// AvailableProviderOperation - Represents available provider operation.
type AvailableProviderOperation struct {
	// Contains the localized display information for this particular operation/action.
	Display *AvailableProviderOperationDisplay `json:"display,omitempty"`

	// The name of the operation being performed on a particular object. Name format: "{resourceProviderNamespace}/{resourceType}/{read|write|delete|action}".
	// Eg.
	// Microsoft.StorSimple/managers/devices/volumeContainers/read, Microsoft.StorSimple/managers/devices/alerts/clearAlerts/action
	Name *string `json:"name,omitempty"`

	// The intended executor of the operation; governs the display of the operation in the RBAC UX and the audit logs UX. Default value is "user,system"
	Origin *string `json:"origin,omitempty"`

	// Reserved for future use.
	Properties map[string]interface{} `json:"properties,omitempty"`
}

// AvailableProviderOperationDisplay - Contains the localized display information for this particular operation/action. These value will be used by several
// clients for (a) custom role definitions for RBAC, (b) complex query filters for the
// event service and (c) audit history/records for management operations.
type AvailableProviderOperationDisplay struct {
	// The localized friendly description for the operation, as it should be shown to the user. It should be thorough, yet concise - it will be used in tool
	// tips and detailed views.
	Description *string `json:"description,omitempty"`

	// The localized friendly name for the operation, as it should be shown to the user. It should be concise (to fit in drop downs) but clear (i.e. self-documenting).
	// It should use Title Casing and include
	// the entity/resource to which it applies.
	Operation *string `json:"operation,omitempty"`

	// The localized friendly form of the resource provider name - it is expected to also include the publisher/company responsible. It should use Title Casing
	// and begin with 'Microsoft' for 1st party
	// services.
	Provider *string `json:"provider,omitempty"`

	// The localized friendly form of the resource type related to this action/operation - it should match the public documentation for the resource provider.
	// It should use Title Casing - for examples,
	// please refer to the 'name' section.
	Resource *string `json:"resource,omitempty"`
}

// AvailableProviderOperationList - List of available provider operations.
type AvailableProviderOperationList struct {
	// REQUIRED; The value.
	Value []*AvailableProviderOperation `json:"value,omitempty"`

	// The NextLink.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type AvailableProviderOperationList.
func (a AvailableProviderOperationList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", a.NextLink)
	populate(objectMap, "value", a.Value)
	return json.Marshal(objectMap)
}

// Backup - The backup.
type Backup struct {
	BaseModel
	// REQUIRED; The properties of the backup.
	Properties *BackupProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Backup.
func (b Backup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	b.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", b.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Backup.
func (b *Backup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &b.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := b.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// BackupElement - The backup element.
type BackupElement struct {
	// REQUIRED; The path ID that uniquely identifies the backup element.
	ElementID *string `json:"elementId,omitempty"`

	// REQUIRED; The name of the backup element.
	ElementName *string `json:"elementName,omitempty"`

	// REQUIRED; The hierarchical type of the backup element.
	ElementType *string `json:"elementType,omitempty"`

	// REQUIRED; The size in bytes.
	SizeInBytes *int64 `json:"sizeInBytes,omitempty"`

	// REQUIRED; The path ID of the volume container.
	VolumeContainerID *string `json:"volumeContainerId,omitempty"`

	// REQUIRED; The name of the volume.
	VolumeName *string `json:"volumeName,omitempty"`

	// The volume type.
	VolumeType *VolumeType `json:"volumeType,omitempty"`
}

// BackupFilter - The OData filters to be used for backups.
type BackupFilter struct {
	// Specifies the backupPolicyId of the backups to be filtered. Only 'Equality' operator is supported for this property.
	BackupPolicyID *string `json:"backupPolicyId,omitempty"`

	// Specifies the creation time of the backups to be filtered. Only 'Greater Than or Equal To' and 'Lesser Than or Equal To' operators are supported for
	// this property.
	CreatedTime *time.Time `json:"createdTime,omitempty"`

	// Specifies the volumeId of the backups to be filtered. Only 'Equality' operator is supported for this property.
	VolumeID *string `json:"volumeId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BackupFilter.
func (b BackupFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupPolicyId", b.BackupPolicyID)
	populate(objectMap, "createdTime", (*timeRFC3339)(b.CreatedTime))
	populate(objectMap, "volumeId", b.VolumeID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupFilter.
func (b *BackupFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupPolicyId":
			err = unpopulate(val, &b.BackupPolicyID)
			delete(rawMsg, key)
		case "createdTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			b.CreatedTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "volumeId":
			err = unpopulate(val, &b.VolumeID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BackupList - The collection of backups.
type BackupList struct {
	// REQUIRED; The value.
	Value []*Backup `json:"value,omitempty"`

	// The NextLink.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BackupList.
func (b BackupList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", b.NextLink)
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// BackupPoliciesBeginBackupNowOptions contains the optional parameters for the BackupPolicies.BeginBackupNow method.
type BackupPoliciesBeginBackupNowOptions struct {
	// placeholder for future optional parameters
}

// BackupPoliciesBeginCreateOrUpdateOptions contains the optional parameters for the BackupPolicies.BeginCreateOrUpdate method.
type BackupPoliciesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// BackupPoliciesBeginDeleteOptions contains the optional parameters for the BackupPolicies.BeginDelete method.
type BackupPoliciesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// BackupPoliciesGetOptions contains the optional parameters for the BackupPolicies.Get method.
type BackupPoliciesGetOptions struct {
	// placeholder for future optional parameters
}

// BackupPoliciesListByDeviceOptions contains the optional parameters for the BackupPolicies.ListByDevice method.
type BackupPoliciesListByDeviceOptions struct {
	// placeholder for future optional parameters
}

// BackupPolicy - The backup policy.
type BackupPolicy struct {
	BaseModel
	// REQUIRED; The properties of the backup policy.
	Properties *BackupPolicyProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BackupPolicy.
func (b BackupPolicy) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	b.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", b.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupPolicy.
func (b *BackupPolicy) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &b.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := b.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// BackupPolicyList - The collection of backup policies.
type BackupPolicyList struct {
	// REQUIRED; The value.
	Value []*BackupPolicy `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BackupPolicyList.
func (b BackupPolicyList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// BackupPolicyProperties - The properties of the backup policy.
type BackupPolicyProperties struct {
	// REQUIRED; The path IDs of the volumes which are part of the backup policy.
	VolumeIDs []*string `json:"volumeIds,omitempty"`

	// READ-ONLY; The backup policy creation type. Indicates whether this was created through SaaS or through StorSimple Snapshot Manager.
	BackupPolicyCreationType *BackupPolicyCreationType `json:"backupPolicyCreationType,omitempty" azure:"ro"`

	// READ-ONLY; The time of the last backup for the backup policy.
	LastBackupTime *time.Time `json:"lastBackupTime,omitempty" azure:"ro"`

	// READ-ONLY; The time of the next backup for the backup policy.
	NextBackupTime *time.Time `json:"nextBackupTime,omitempty" azure:"ro"`

	// READ-ONLY; Indicates whether at least one of the schedules in the backup policy is active or not.
	ScheduledBackupStatus *ScheduledBackupStatus `json:"scheduledBackupStatus,omitempty" azure:"ro"`

	// READ-ONLY; The count of schedules the backup policy contains.
	SchedulesCount *int64 `json:"schedulesCount,omitempty" azure:"ro"`

	// READ-ONLY; If the backup policy was created by StorSimple Snapshot Manager, then this field indicates the hostname of the StorSimple Snapshot Manager.
	SsmHostName *string `json:"ssmHostName,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type BackupPolicyProperties.
func (b BackupPolicyProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupPolicyCreationType", b.BackupPolicyCreationType)
	populate(objectMap, "lastBackupTime", (*timeRFC3339)(b.LastBackupTime))
	populate(objectMap, "nextBackupTime", (*timeRFC3339)(b.NextBackupTime))
	populate(objectMap, "scheduledBackupStatus", b.ScheduledBackupStatus)
	populate(objectMap, "schedulesCount", b.SchedulesCount)
	populate(objectMap, "ssmHostName", b.SsmHostName)
	populate(objectMap, "volumeIds", b.VolumeIDs)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupPolicyProperties.
func (b *BackupPolicyProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupPolicyCreationType":
			err = unpopulate(val, &b.BackupPolicyCreationType)
			delete(rawMsg, key)
		case "lastBackupTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			b.LastBackupTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "nextBackupTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			b.NextBackupTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "scheduledBackupStatus":
			err = unpopulate(val, &b.ScheduledBackupStatus)
			delete(rawMsg, key)
		case "schedulesCount":
			err = unpopulate(val, &b.SchedulesCount)
			delete(rawMsg, key)
		case "ssmHostName":
			err = unpopulate(val, &b.SsmHostName)
			delete(rawMsg, key)
		case "volumeIds":
			err = unpopulate(val, &b.VolumeIDs)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BackupProperties - The properties of the backup.
type BackupProperties struct {
	// REQUIRED; The time when the backup was created.
	CreatedOn *time.Time `json:"createdOn,omitempty"`

	// REQUIRED; The backup elements.
	Elements []*BackupElement `json:"elements,omitempty"`

	// REQUIRED; The backup size in bytes.
	SizeInBytes *int64 `json:"sizeInBytes,omitempty"`

	// The backup job creation type.
	BackupJobCreationType *BackupJobCreationType `json:"backupJobCreationType,omitempty"`

	// The path ID of the backup policy.
	BackupPolicyID *string `json:"backupPolicyId,omitempty"`

	// The type of the backup.
	BackupType *BackupType `json:"backupType,omitempty"`

	// The StorSimple Snapshot Manager host name.
	SsmHostName *string `json:"ssmHostName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BackupProperties.
func (b BackupProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupJobCreationType", b.BackupJobCreationType)
	populate(objectMap, "backupPolicyId", b.BackupPolicyID)
	populate(objectMap, "backupType", b.BackupType)
	populate(objectMap, "createdOn", (*timeRFC3339)(b.CreatedOn))
	populate(objectMap, "elements", b.Elements)
	populate(objectMap, "sizeInBytes", b.SizeInBytes)
	populate(objectMap, "ssmHostName", b.SsmHostName)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupProperties.
func (b *BackupProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupJobCreationType":
			err = unpopulate(val, &b.BackupJobCreationType)
			delete(rawMsg, key)
		case "backupPolicyId":
			err = unpopulate(val, &b.BackupPolicyID)
			delete(rawMsg, key)
		case "backupType":
			err = unpopulate(val, &b.BackupType)
			delete(rawMsg, key)
		case "createdOn":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			b.CreatedOn = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "elements":
			err = unpopulate(val, &b.Elements)
			delete(rawMsg, key)
		case "sizeInBytes":
			err = unpopulate(val, &b.SizeInBytes)
			delete(rawMsg, key)
		case "ssmHostName":
			err = unpopulate(val, &b.SsmHostName)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BackupSchedule - The backup schedule.
type BackupSchedule struct {
	BaseModel
	// REQUIRED; The properties of the backup schedule.
	Properties *BackupScheduleProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BackupSchedule.
func (b BackupSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	b.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", b.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupSchedule.
func (b *BackupSchedule) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &b.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := b.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// BackupScheduleList - The backup schedule list.
type BackupScheduleList struct {
	// REQUIRED; The value.
	Value []*BackupSchedule `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BackupScheduleList.
func (b BackupScheduleList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// BackupScheduleProperties - The properties of the backup schedule.
type BackupScheduleProperties struct {
	// REQUIRED; The type of backup which needs to be taken.
	BackupType *BackupType `json:"backupType,omitempty"`

	// REQUIRED; The number of backups to be retained.
	RetentionCount *int64 `json:"retentionCount,omitempty"`

	// REQUIRED; The schedule recurrence.
	ScheduleRecurrence *ScheduleRecurrence `json:"scheduleRecurrence,omitempty"`

	// REQUIRED; The schedule status.
	ScheduleStatus *ScheduleStatus `json:"scheduleStatus,omitempty"`

	// REQUIRED; The start time of the schedule.
	StartTime *time.Time `json:"startTime,omitempty"`

	// READ-ONLY; The last successful backup run which was triggered for the schedule.
	LastSuccessfulRun *time.Time `json:"lastSuccessfulRun,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type BackupScheduleProperties.
func (b BackupScheduleProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupType", b.BackupType)
	populate(objectMap, "lastSuccessfulRun", (*timeRFC3339)(b.LastSuccessfulRun))
	populate(objectMap, "retentionCount", b.RetentionCount)
	populate(objectMap, "scheduleRecurrence", b.ScheduleRecurrence)
	populate(objectMap, "scheduleStatus", b.ScheduleStatus)
	populate(objectMap, "startTime", (*timeRFC3339)(b.StartTime))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BackupScheduleProperties.
func (b *BackupScheduleProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupType":
			err = unpopulate(val, &b.BackupType)
			delete(rawMsg, key)
		case "lastSuccessfulRun":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			b.LastSuccessfulRun = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "retentionCount":
			err = unpopulate(val, &b.RetentionCount)
			delete(rawMsg, key)
		case "scheduleRecurrence":
			err = unpopulate(val, &b.ScheduleRecurrence)
			delete(rawMsg, key)
		case "scheduleStatus":
			err = unpopulate(val, &b.ScheduleStatus)
			delete(rawMsg, key)
		case "startTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			b.StartTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// BackupSchedulesBeginCreateOrUpdateOptions contains the optional parameters for the BackupSchedules.BeginCreateOrUpdate method.
type BackupSchedulesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// BackupSchedulesBeginDeleteOptions contains the optional parameters for the BackupSchedules.BeginDelete method.
type BackupSchedulesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// BackupSchedulesGetOptions contains the optional parameters for the BackupSchedules.Get method.
type BackupSchedulesGetOptions struct {
	// placeholder for future optional parameters
}

// BackupSchedulesListByBackupPolicyOptions contains the optional parameters for the BackupSchedules.ListByBackupPolicy method.
type BackupSchedulesListByBackupPolicyOptions struct {
	// placeholder for future optional parameters
}

// BackupsBeginCloneOptions contains the optional parameters for the Backups.BeginClone method.
type BackupsBeginCloneOptions struct {
	// placeholder for future optional parameters
}

// BackupsBeginDeleteOptions contains the optional parameters for the Backups.BeginDelete method.
type BackupsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// BackupsBeginRestoreOptions contains the optional parameters for the Backups.BeginRestore method.
type BackupsBeginRestoreOptions struct {
	// placeholder for future optional parameters
}

// BackupsListByDeviceOptions contains the optional parameters for the Backups.ListByDevice method.
type BackupsListByDeviceOptions struct {
	// OData Filter options
	Filter *string
}

// BandwidthRateSettingProperties - The properties of the bandwidth setting.
type BandwidthRateSettingProperties struct {
	// REQUIRED; The schedules.
	Schedules []*BandwidthSchedule `json:"schedules,omitempty"`

	// READ-ONLY; The number of volumes that uses the bandwidth setting.
	VolumeCount *int32 `json:"volumeCount,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type BandwidthRateSettingProperties.
func (b BandwidthRateSettingProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "schedules", b.Schedules)
	populate(objectMap, "volumeCount", b.VolumeCount)
	return json.Marshal(objectMap)
}

// BandwidthSchedule - The schedule for bandwidth setting.
type BandwidthSchedule struct {
	// REQUIRED; The days of the week when this schedule is applicable.
	Days []*DayOfWeek `json:"days,omitempty"`

	// REQUIRED; The rate in Mbps.
	RateInMbps *int32 `json:"rateInMbps,omitempty"`

	// REQUIRED; The start time of the schedule.
	Start *Time `json:"start,omitempty"`

	// REQUIRED; The stop time of the schedule.
	Stop *Time `json:"stop,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BandwidthSchedule.
func (b BandwidthSchedule) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "days", b.Days)
	populate(objectMap, "rateInMbps", b.RateInMbps)
	populate(objectMap, "start", b.Start)
	populate(objectMap, "stop", b.Stop)
	return json.Marshal(objectMap)
}

// BandwidthSetting - The bandwidth setting.
type BandwidthSetting struct {
	BaseModel
	// REQUIRED; The properties of the bandwidth setting.
	Properties *BandwidthRateSettingProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BandwidthSetting.
func (b BandwidthSetting) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	b.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", b.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BandwidthSetting.
func (b *BandwidthSetting) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &b.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := b.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// BandwidthSettingList - The collection of bandwidth setting entities.
type BandwidthSettingList struct {
	// REQUIRED; The value.
	Value []*BandwidthSetting `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type BandwidthSettingList.
func (b BandwidthSettingList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", b.Value)
	return json.Marshal(objectMap)
}

// BandwidthSettingsBeginCreateOrUpdateOptions contains the optional parameters for the BandwidthSettings.BeginCreateOrUpdate method.
type BandwidthSettingsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// BandwidthSettingsBeginDeleteOptions contains the optional parameters for the BandwidthSettings.BeginDelete method.
type BandwidthSettingsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// BandwidthSettingsGetOptions contains the optional parameters for the BandwidthSettings.Get method.
type BandwidthSettingsGetOptions struct {
	// placeholder for future optional parameters
}

// BandwidthSettingsListByManagerOptions contains the optional parameters for the BandwidthSettings.ListByManager method.
type BandwidthSettingsListByManagerOptions struct {
	// placeholder for future optional parameters
}

// BaseModel - Represents the base class for all other ARM object models
type BaseModel struct {
	// The Kind of the object. Currently only Series8000 is supported
	Kind *string `json:"kind,omitempty"`

	// READ-ONLY; The path ID that uniquely identifies the object.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The name of the object.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The hierarchical type of the object.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type BaseModel.
func (b BaseModel) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	b.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type BaseModel.
func (b *BaseModel) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	return b.unmarshalInternal(rawMsg)
}

func (b BaseModel) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "id", b.ID)
	populate(objectMap, "kind", b.Kind)
	populate(objectMap, "name", b.Name)
	populate(objectMap, "type", b.Type)
}

func (b *BaseModel) unmarshalInternal(rawMsg map[string]json.RawMessage) error {
	for key, val := range rawMsg {
		var err error
		switch key {
		case "id":
			err = unpopulate(val, &b.ID)
			delete(rawMsg, key)
		case "kind":
			err = unpopulate(val, &b.Kind)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &b.Name)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &b.Type)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// ChapSettings - The Challenge-Handshake Authentication Protocol (CHAP) settings.
type ChapSettings struct {
	// The CHAP initiator secret.
	InitiatorSecret *AsymmetricEncryptedSecret `json:"initiatorSecret,omitempty"`

	// The CHAP initiator user.
	InitiatorUser *string `json:"initiatorUser,omitempty"`

	// The target secret.
	TargetSecret *AsymmetricEncryptedSecret `json:"targetSecret,omitempty"`

	// The CHAP target user.
	TargetUser *string `json:"targetUser,omitempty"`
}

// ClearAlertRequest - The request for clearing the alert
type ClearAlertRequest struct {
	// REQUIRED; The list of alert IDs to be cleared
	Alerts []*string `json:"alerts,omitempty"`

	// The resolution message while clearing the alert
	ResolutionMessage *string `json:"resolutionMessage,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ClearAlertRequest.
func (c ClearAlertRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "alerts", c.Alerts)
	populate(objectMap, "resolutionMessage", c.ResolutionMessage)
	return json.Marshal(objectMap)
}

// CloneRequest - The clone job request.
type CloneRequest struct {
	// REQUIRED; The backup element that is cloned.
	BackupElement *BackupElement `json:"backupElement,omitempty"`

	// REQUIRED; The list of path IDs of the access control records to be associated to the new cloned volume.
	TargetAccessControlRecordIDs []*string `json:"targetAccessControlRecordIds,omitempty"`

	// REQUIRED; The path ID of the device which will act as the clone target.
	TargetDeviceID *string `json:"targetDeviceId,omitempty"`

	// REQUIRED; The name of the new volume which will be created and the backup will be cloned into.
	TargetVolumeName *string `json:"targetVolumeName,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CloneRequest.
func (c CloneRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupElement", c.BackupElement)
	populate(objectMap, "targetAccessControlRecordIds", c.TargetAccessControlRecordIDs)
	populate(objectMap, "targetDeviceId", c.TargetDeviceID)
	populate(objectMap, "targetVolumeName", c.TargetVolumeName)
	return json.Marshal(objectMap)
}

// CloudAppliance - The cloud appliance.
type CloudAppliance struct {
	// REQUIRED; The name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The virtual network region.
	VnetRegion *string `json:"vnetRegion,omitempty"`

	// Indicates whether virtual network used is configured with DNS or not.
	IsVnetDNSConfigured *bool `json:"isVnetDnsConfigured,omitempty"`

	// Indicates whether virtual network used is configured with express route or not.
	IsVnetExpressConfigured *bool `json:"isVnetExpressConfigured,omitempty"`

	// The model number.
	ModelNumber *string `json:"modelNumber,omitempty"`

	// The name of the storage account.
	StorageAccountName *string `json:"storageAccountName,omitempty"`

	// The type of the storage account.
	StorageAccountType *string `json:"storageAccountType,omitempty"`

	// The name of the subnet.
	SubnetName *string `json:"subnetName,omitempty"`

	// The name of the virtual machine image.
	VMImageName *string `json:"vmImageName,omitempty"`

	// The type of the virtual machine.
	VMType *string `json:"vmType,omitempty"`

	// The name of the virtual network.
	VnetName *string `json:"vnetName,omitempty"`
}

// CloudApplianceConfiguration - The cloud appliance configuration
type CloudApplianceConfiguration struct {
	BaseModel
	// REQUIRED; The properties.
	Properties *CloudApplianceConfigurationProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CloudApplianceConfiguration.
func (c CloudApplianceConfiguration) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type CloudApplianceConfiguration.
func (c *CloudApplianceConfiguration) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &c.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// CloudApplianceConfigurationList - The cloud appliance configuration list
type CloudApplianceConfigurationList struct {
	// REQUIRED; The value.
	Value []*CloudApplianceConfiguration `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CloudApplianceConfigurationList.
func (c CloudApplianceConfigurationList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", c.Value)
	return json.Marshal(objectMap)
}

// CloudApplianceConfigurationProperties - The properties of cloud appliance configuration.
type CloudApplianceConfigurationProperties struct {
	// REQUIRED; The ACS configuration.
	AcsConfiguration *AcsConfiguration `json:"acsConfiguration,omitempty"`

	// REQUIRED; The cloud platform.
	CloudPlatform *string `json:"cloudPlatform,omitempty"`

	// REQUIRED; The model number.
	ModelNumber *string `json:"modelNumber,omitempty"`

	// REQUIRED; The supported regions.
	SupportedRegions []*string `json:"supportedRegions,omitempty"`

	// REQUIRED; The supported storage account types.
	SupportedStorageAccountTypes []*string `json:"supportedStorageAccountTypes,omitempty"`

	// REQUIRED; The supported virtual machine images.
	SupportedVMImages []*VMImage `json:"supportedVmImages,omitempty"`

	// REQUIRED; The supported virtual machine types.
	SupportedVMTypes []*string `json:"supportedVmTypes,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type CloudApplianceConfigurationProperties.
func (c CloudApplianceConfigurationProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "acsConfiguration", c.AcsConfiguration)
	populate(objectMap, "cloudPlatform", c.CloudPlatform)
	populate(objectMap, "modelNumber", c.ModelNumber)
	populate(objectMap, "supportedRegions", c.SupportedRegions)
	populate(objectMap, "supportedStorageAccountTypes", c.SupportedStorageAccountTypes)
	populate(objectMap, "supportedVmImages", c.SupportedVMImages)
	populate(objectMap, "supportedVmTypes", c.SupportedVMTypes)
	return json.Marshal(objectMap)
}

// CloudApplianceSettings - The cloud appliance settings.
type CloudApplianceSettings struct {
	// The channel integrity key (encrypted with DAK).
	ChannelIntegrityKey *AsymmetricEncryptedSecret `json:"channelIntegrityKey,omitempty"`

	// The service data encryption key (encrypted with DAK).
	ServiceDataEncryptionKey *AsymmetricEncryptedSecret `json:"serviceDataEncryptionKey,omitempty"`
}

// CloudAppliancesBeginProvisionOptions contains the optional parameters for the CloudAppliances.BeginProvision method.
type CloudAppliancesBeginProvisionOptions struct {
	// placeholder for future optional parameters
}

// CloudAppliancesListSupportedConfigurationsOptions contains the optional parameters for the CloudAppliances.ListSupportedConfigurations method.
type CloudAppliancesListSupportedConfigurationsOptions struct {
	// placeholder for future optional parameters
}

// ConfigureDeviceRequest - The mandatory device configuration request.
type ConfigureDeviceRequest struct {
	BaseModel
	// REQUIRED; The properties of the configure device request.
	Properties *ConfigureDeviceRequestProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ConfigureDeviceRequest.
func (c ConfigureDeviceRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ConfigureDeviceRequest.
func (c *ConfigureDeviceRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &c.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ConfigureDeviceRequestProperties - The properties of the configure device request.
type ConfigureDeviceRequestProperties struct {
	// REQUIRED; The current name of the device.
	CurrentDeviceName *string `json:"currentDeviceName,omitempty"`

	// REQUIRED; The friendly name for the device.
	FriendlyName *string `json:"friendlyName,omitempty"`

	// REQUIRED; The device time zone. For eg: "Pacific Standard Time"
	TimeZone *string `json:"timeZone,omitempty"`

	// The secondary DNS Settings of the device.
	DNSSettings *SecondaryDNSSettings `json:"dnsSettings,omitempty"`

	// The 'Data 0' network interface card settings.
	NetworkInterfaceData0Settings *NetworkInterfaceData0Settings `json:"networkInterfaceData0Settings,omitempty"`
}

// ControllerPowerStateChangeRequest - The controller power state change request.
type ControllerPowerStateChangeRequest struct {
	BaseModel
	// REQUIRED; The properties of the controller power state change request.
	Properties *ControllerPowerStateChangeRequestProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ControllerPowerStateChangeRequest.
func (c ControllerPowerStateChangeRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	c.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", c.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ControllerPowerStateChangeRequest.
func (c *ControllerPowerStateChangeRequest) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &c.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := c.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ControllerPowerStateChangeRequestProperties - The properties of the controller power state change request.
type ControllerPowerStateChangeRequestProperties struct {
	// REQUIRED; The power state that the request is expecting for the controller of the device.
	Action *ControllerPowerStateAction `json:"action,omitempty"`

	// REQUIRED; The active controller that the request is expecting on the device.
	ActiveController *ControllerID `json:"activeController,omitempty"`

	// REQUIRED; The controller 0's status that the request is expecting on the device.
	Controller0State *ControllerStatus `json:"controller0State,omitempty"`

	// REQUIRED; The controller 1's status that the request is expecting on the device.
	Controller1State *ControllerStatus `json:"controller1State,omitempty"`
}

// DNSSettings - The DNS(Domain Name Server) settings of a device.
type DNSSettings struct {
	// The primary IPv4 DNS server for the device
	PrimaryDNSServer *string `json:"primaryDnsServer,omitempty"`

	// The primary IPv6 DNS server for the device
	PrimaryIPv6DNSServer *string `json:"primaryIpv6DnsServer,omitempty"`

	// The secondary IPv4 DNS server for the device
	SecondaryDNSServers []*string `json:"secondaryDnsServers,omitempty"`

	// The secondary IPv6 DNS server for the device
	SecondaryIPv6DNSServers []*string `json:"secondaryIpv6DnsServers,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DNSSettings.
func (d DNSSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "primaryDnsServer", d.PrimaryDNSServer)
	populate(objectMap, "primaryIpv6DnsServer", d.PrimaryIPv6DNSServer)
	populate(objectMap, "secondaryDnsServers", d.SecondaryDNSServers)
	populate(objectMap, "secondaryIpv6DnsServers", d.SecondaryIPv6DNSServers)
	return json.Marshal(objectMap)
}

// DataStatistics - The additional details related to the data related statistics of a job. Currently applicable only for Backup, Clone and Restore jobs.
type DataStatistics struct {
	// The number of bytes of data written to cloud, as part of the job.
	CloudData *int64 `json:"cloudData,omitempty"`

	// The number of bytes of data processed till now, as part of the job.
	ProcessedData *int64 `json:"processedData,omitempty"`

	// The average throughput of data processed(bytes/sec), as part of the job.
	Throughput *int64 `json:"throughput,omitempty"`

	// The total bytes of data to be processed, as part of the job.
	TotalData *int64 `json:"totalData,omitempty"`
}

// Device - The StorSimple device.
type Device struct {
	BaseModel
	// REQUIRED; The properties of the StorSimple device.
	Properties *DeviceProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Device.
func (d Device) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	d.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Device.
func (d *Device) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &d.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := d.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// DeviceDetails - The additional device details regarding the end point count and volume container count.
type DeviceDetails struct {
	// The total number of endpoints that are currently on the device ( i.e. number of volumes).
	EndpointCount *int32 `json:"endpointCount,omitempty"`

	// The total number of volume containers on the device.
	VolumeContainerCount *int32 `json:"volumeContainerCount,omitempty"`
}

// DeviceList - The collection of devices.
type DeviceList struct {
	// REQUIRED; The value.
	Value []*Device `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DeviceList.
func (d DeviceList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", d.Value)
	return json.Marshal(objectMap)
}

// DevicePatch - The device patch.
type DevicePatch struct {
	// REQUIRED; The properties of the device patch.
	Properties *DevicePatchProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type DevicePatch.
func (d DevicePatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", d.Properties)
	return json.Marshal(objectMap)
}

// DevicePatchProperties - The properties of the device patch.
type DevicePatchProperties struct {
	// Short description given for the device
	DeviceDescription *string `json:"deviceDescription,omitempty"`
}

// DeviceProperties - The properties of the StorSimple device.
type DeviceProperties struct {
	// REQUIRED; The UTC time at which the device was activated
	ActivationTime *time.Time `json:"activationTime,omitempty"`

	// REQUIRED; The identifier of the active controller of the device.
	ActiveController *ControllerID `json:"activeController,omitempty"`

	// REQUIRED; The language culture setting on the device. For eg: "en-US"
	Culture *string `json:"culture,omitempty"`

	// REQUIRED; The current configuration status of the device.
	DeviceConfigurationStatus *DeviceConfigurationStatus `json:"deviceConfigurationStatus,omitempty"`

	// REQUIRED; The device description.
	DeviceDescription *string `json:"deviceDescription,omitempty"`

	// REQUIRED; The version number of the software running on the device.
	DeviceSoftwareVersion *string `json:"deviceSoftwareVersion,omitempty"`

	// REQUIRED; The type of the device.
	DeviceType *DeviceType `json:"deviceType,omitempty"`

	// REQUIRED; The friendly name of the device.
	FriendlyName *string `json:"friendlyName,omitempty"`

	// REQUIRED; The device friendly software version.
	FriendlySoftwareVersion *string `json:"friendlySoftwareVersion,omitempty"`

	// REQUIRED; The device model.
	ModelDescription *string `json:"modelDescription,omitempty"`

	// REQUIRED; The serial number.
	SerialNumber *string `json:"serialNumber,omitempty"`

	// REQUIRED; The current status of the device.
	Status *DeviceStatus `json:"status,omitempty"`

	// REQUIRED; The target IQN.
	TargetIqn *string `json:"targetIqn,omitempty"`

	// The device agent group version.
	AgentGroupVersion *int32 `json:"agentGroupVersion,omitempty"`

	// The storage in bytes that is available locally on the device.
	AvailableLocalStorageInBytes *int64 `json:"availableLocalStorageInBytes,omitempty"`

	// The storage in bytes that is available on the device for tiered volumes.
	AvailableTieredStorageInBytes *int64 `json:"availableTieredStorageInBytes,omitempty"`

	// The additional device details regarding the end point count and volume container count.
	Details *DeviceDetails `json:"details,omitempty"`

	// The location of the virtual appliance.
	DeviceLocation *string `json:"deviceLocation,omitempty"`

	// The friendly name of the software running on the device.
	FriendlySoftwareName *string `json:"friendlySoftwareName,omitempty"`

	// The number of network interface cards
	NetworkInterfaceCardCount *int32 `json:"networkInterfaceCardCount,omitempty"`

	// The storage in bytes used for locally pinned volumes on the device (including additional local reservation).
	ProvisionedLocalStorageInBytes *int64 `json:"provisionedLocalStorageInBytes,omitempty"`

	// The storage in bytes that has been provisioned on the device for tiered volumes.
	ProvisionedTieredStorageInBytes *int64 `json:"provisionedTieredStorageInBytes,omitempty"`

	// Total capacity in bytes of tiered and locally pinned volumes on the device
	ProvisionedVolumeSizeInBytes *int64 `json:"provisionedVolumeSizeInBytes,omitempty"`

	// The additional device details for the service data encryption key rollover.
	RolloverDetails *DeviceRolloverDetails `json:"rolloverDetails,omitempty"`

	// The total tiered storage available on the device in bytes.
	TotalTieredStorageInBytes *int64 `json:"totalTieredStorageInBytes,omitempty"`

	// The storage in bytes that is currently being used on the device, including both local and cloud.
	UsingStorageInBytes *int64 `json:"usingStorageInBytes,omitempty"`

	// READ-ONLY; The virtual machine API type.
	VirtualMachineAPIType *VirtualMachineAPIType `json:"virtualMachineApiType,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type DeviceProperties.
func (d DeviceProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "activationTime", (*timeRFC3339)(d.ActivationTime))
	populate(objectMap, "activeController", d.ActiveController)
	populate(objectMap, "agentGroupVersion", d.AgentGroupVersion)
	populate(objectMap, "availableLocalStorageInBytes", d.AvailableLocalStorageInBytes)
	populate(objectMap, "availableTieredStorageInBytes", d.AvailableTieredStorageInBytes)
	populate(objectMap, "culture", d.Culture)
	populate(objectMap, "details", d.Details)
	populate(objectMap, "deviceConfigurationStatus", d.DeviceConfigurationStatus)
	populate(objectMap, "deviceDescription", d.DeviceDescription)
	populate(objectMap, "deviceLocation", d.DeviceLocation)
	populate(objectMap, "deviceSoftwareVersion", d.DeviceSoftwareVersion)
	populate(objectMap, "deviceType", d.DeviceType)
	populate(objectMap, "friendlyName", d.FriendlyName)
	populate(objectMap, "friendlySoftwareName", d.FriendlySoftwareName)
	populate(objectMap, "friendlySoftwareVersion", d.FriendlySoftwareVersion)
	populate(objectMap, "modelDescription", d.ModelDescription)
	populate(objectMap, "networkInterfaceCardCount", d.NetworkInterfaceCardCount)
	populate(objectMap, "provisionedLocalStorageInBytes", d.ProvisionedLocalStorageInBytes)
	populate(objectMap, "provisionedTieredStorageInBytes", d.ProvisionedTieredStorageInBytes)
	populate(objectMap, "provisionedVolumeSizeInBytes", d.ProvisionedVolumeSizeInBytes)
	populate(objectMap, "rolloverDetails", d.RolloverDetails)
	populate(objectMap, "serialNumber", d.SerialNumber)
	populate(objectMap, "status", d.Status)
	populate(objectMap, "targetIqn", d.TargetIqn)
	populate(objectMap, "totalTieredStorageInBytes", d.TotalTieredStorageInBytes)
	populate(objectMap, "usingStorageInBytes", d.UsingStorageInBytes)
	populate(objectMap, "virtualMachineApiType", d.VirtualMachineAPIType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type DeviceProperties.
func (d *DeviceProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "activationTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			d.ActivationTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "activeController":
			err = unpopulate(val, &d.ActiveController)
			delete(rawMsg, key)
		case "agentGroupVersion":
			err = unpopulate(val, &d.AgentGroupVersion)
			delete(rawMsg, key)
		case "availableLocalStorageInBytes":
			err = unpopulate(val, &d.AvailableLocalStorageInBytes)
			delete(rawMsg, key)
		case "availableTieredStorageInBytes":
			err = unpopulate(val, &d.AvailableTieredStorageInBytes)
			delete(rawMsg, key)
		case "culture":
			err = unpopulate(val, &d.Culture)
			delete(rawMsg, key)
		case "details":
			err = unpopulate(val, &d.Details)
			delete(rawMsg, key)
		case "deviceConfigurationStatus":
			err = unpopulate(val, &d.DeviceConfigurationStatus)
			delete(rawMsg, key)
		case "deviceDescription":
			err = unpopulate(val, &d.DeviceDescription)
			delete(rawMsg, key)
		case "deviceLocation":
			err = unpopulate(val, &d.DeviceLocation)
			delete(rawMsg, key)
		case "deviceSoftwareVersion":
			err = unpopulate(val, &d.DeviceSoftwareVersion)
			delete(rawMsg, key)
		case "deviceType":
			err = unpopulate(val, &d.DeviceType)
			delete(rawMsg, key)
		case "friendlyName":
			err = unpopulate(val, &d.FriendlyName)
			delete(rawMsg, key)
		case "friendlySoftwareName":
			err = unpopulate(val, &d.FriendlySoftwareName)
			delete(rawMsg, key)
		case "friendlySoftwareVersion":
			err = unpopulate(val, &d.FriendlySoftwareVersion)
			delete(rawMsg, key)
		case "modelDescription":
			err = unpopulate(val, &d.ModelDescription)
			delete(rawMsg, key)
		case "networkInterfaceCardCount":
			err = unpopulate(val, &d.NetworkInterfaceCardCount)
			delete(rawMsg, key)
		case "provisionedLocalStorageInBytes":
			err = unpopulate(val, &d.ProvisionedLocalStorageInBytes)
			delete(rawMsg, key)
		case "provisionedTieredStorageInBytes":
			err = unpopulate(val, &d.ProvisionedTieredStorageInBytes)
			delete(rawMsg, key)
		case "provisionedVolumeSizeInBytes":
			err = unpopulate(val, &d.ProvisionedVolumeSizeInBytes)
			delete(rawMsg, key)
		case "rolloverDetails":
			err = unpopulate(val, &d.RolloverDetails)
			delete(rawMsg, key)
		case "serialNumber":
			err = unpopulate(val, &d.SerialNumber)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &d.Status)
			delete(rawMsg, key)
		case "targetIqn":
			err = unpopulate(val, &d.TargetIqn)
			delete(rawMsg, key)
		case "totalTieredStorageInBytes":
			err = unpopulate(val, &d.TotalTieredStorageInBytes)
			delete(rawMsg, key)
		case "usingStorageInBytes":
			err = unpopulate(val, &d.UsingStorageInBytes)
			delete(rawMsg, key)
		case "virtualMachineApiType":
			err = unpopulate(val, &d.VirtualMachineAPIType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// DeviceRolloverDetails - The additional device details for the service data encryption key rollover.
type DeviceRolloverDetails struct {
	// The eligibility status of device for service data encryption key rollover.
	AuthorizationEligibility *AuthorizationEligibility `json:"authorizationEligibility,omitempty"`

	// The authorization status of the device for service data encryption key rollover.
	AuthorizationStatus *AuthorizationStatus `json:"authorizationStatus,omitempty"`

	// The reason for inEligibility of device, in case it's not eligible for service data encryption key rollover.
	InEligibilityReason *InEligibilityCategory `json:"inEligibilityReason,omitempty"`
}

// DeviceSettingsBeginCreateOrUpdateAlertSettingsOptions contains the optional parameters for the DeviceSettings.BeginCreateOrUpdateAlertSettings method.
type DeviceSettingsBeginCreateOrUpdateAlertSettingsOptions struct {
	// placeholder for future optional parameters
}

// DeviceSettingsBeginCreateOrUpdateTimeSettingsOptions contains the optional parameters for the DeviceSettings.BeginCreateOrUpdateTimeSettings method.
type DeviceSettingsBeginCreateOrUpdateTimeSettingsOptions struct {
	// placeholder for future optional parameters
}

// DeviceSettingsBeginSyncRemotemanagementCertificateOptions contains the optional parameters for the DeviceSettings.BeginSyncRemotemanagementCertificate
// method.
type DeviceSettingsBeginSyncRemotemanagementCertificateOptions struct {
	// placeholder for future optional parameters
}

// DeviceSettingsBeginUpdateNetworkSettingsOptions contains the optional parameters for the DeviceSettings.BeginUpdateNetworkSettings method.
type DeviceSettingsBeginUpdateNetworkSettingsOptions struct {
	// placeholder for future optional parameters
}

// DeviceSettingsBeginUpdateSecuritySettingsOptions contains the optional parameters for the DeviceSettings.BeginUpdateSecuritySettings method.
type DeviceSettingsBeginUpdateSecuritySettingsOptions struct {
	// placeholder for future optional parameters
}

// DeviceSettingsGetAlertSettingsOptions contains the optional parameters for the DeviceSettings.GetAlertSettings method.
type DeviceSettingsGetAlertSettingsOptions struct {
	// placeholder for future optional parameters
}

// DeviceSettingsGetNetworkSettingsOptions contains the optional parameters for the DeviceSettings.GetNetworkSettings method.
type DeviceSettingsGetNetworkSettingsOptions struct {
	// placeholder for future optional parameters
}

// DeviceSettingsGetSecuritySettingsOptions contains the optional parameters for the DeviceSettings.GetSecuritySettings method.
type DeviceSettingsGetSecuritySettingsOptions struct {
	// placeholder for future optional parameters
}

// DeviceSettingsGetTimeSettingsOptions contains the optional parameters for the DeviceSettings.GetTimeSettings method.
type DeviceSettingsGetTimeSettingsOptions struct {
	// placeholder for future optional parameters
}

// DevicesAuthorizeForServiceEncryptionKeyRolloverOptions contains the optional parameters for the Devices.AuthorizeForServiceEncryptionKeyRollover method.
type DevicesAuthorizeForServiceEncryptionKeyRolloverOptions struct {
	// placeholder for future optional parameters
}

// DevicesBeginConfigureOptions contains the optional parameters for the Devices.BeginConfigure method.
type DevicesBeginConfigureOptions struct {
	// placeholder for future optional parameters
}

// DevicesBeginDeactivateOptions contains the optional parameters for the Devices.BeginDeactivate method.
type DevicesBeginDeactivateOptions struct {
	// placeholder for future optional parameters
}

// DevicesBeginDeleteOptions contains the optional parameters for the Devices.BeginDelete method.
type DevicesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// DevicesBeginFailoverOptions contains the optional parameters for the Devices.BeginFailover method.
type DevicesBeginFailoverOptions struct {
	// placeholder for future optional parameters
}

// DevicesBeginInstallUpdatesOptions contains the optional parameters for the Devices.BeginInstallUpdates method.
type DevicesBeginInstallUpdatesOptions struct {
	// placeholder for future optional parameters
}

// DevicesBeginScanForUpdatesOptions contains the optional parameters for the Devices.BeginScanForUpdates method.
type DevicesBeginScanForUpdatesOptions struct {
	// placeholder for future optional parameters
}

// DevicesGetOptions contains the optional parameters for the Devices.Get method.
type DevicesGetOptions struct {
	// Specify $expand=details to populate additional fields related to the device or $expand=rolloverdetails to populate additional fields related to the service
	// data encryption key rollover on device
	Expand *string
}

// DevicesGetUpdateSummaryOptions contains the optional parameters for the Devices.GetUpdateSummary method.
type DevicesGetUpdateSummaryOptions struct {
	// placeholder for future optional parameters
}

// DevicesListByManagerOptions contains the optional parameters for the Devices.ListByManager method.
type DevicesListByManagerOptions struct {
	// Specify $expand=details to populate additional fields related to the device or $expand=rolloverdetails to populate additional fields related to the service
	// data encryption key rollover on device
	Expand *string
}

// DevicesListFailoverSetsOptions contains the optional parameters for the Devices.ListFailoverSets method.
type DevicesListFailoverSetsOptions struct {
	// placeholder for future optional parameters
}

// DevicesListFailoverTargetsOptions contains the optional parameters for the Devices.ListFailoverTargets method.
type DevicesListFailoverTargetsOptions struct {
	// placeholder for future optional parameters
}

// DevicesListMetricDefinitionOptions contains the optional parameters for the Devices.ListMetricDefinition method.
type DevicesListMetricDefinitionOptions struct {
	// placeholder for future optional parameters
}

// DevicesListMetricsOptions contains the optional parameters for the Devices.ListMetrics method.
type DevicesListMetricsOptions struct {
	// placeholder for future optional parameters
}

// DevicesUpdateOptions contains the optional parameters for the Devices.Update method.
type DevicesUpdateOptions struct {
	// placeholder for future optional parameters
}

// DimensionFilter - The dimension filter.
type DimensionFilter struct {
	// Specifies the dimension name. E.g., NetworkInterface. Valid values are the ones specified in the field "dimensions" in the ListMetricDefinitions call.
	// Only 'Equality' operator is supported for this
	// property.
	Name *string `json:"name,omitempty"`

	// Specifies the dimension value. E.g., Data0. Valid values are the ones returned in the field "dimensions" in the ListMetricDefinitions call. Only 'Equality'
	// operator is supported for this property.
	Values *string `json:"values,omitempty"`
}

// EncryptionSettings - The encryption settings.
type EncryptionSettings struct {
	BaseModel
	// REQUIRED; The properties of the encryption settings.
	Properties *EncryptionSettingsProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type EncryptionSettings.
func (e EncryptionSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	e.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", e.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type EncryptionSettings.
func (e *EncryptionSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &e.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := e.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// EncryptionSettingsProperties - The properties of encryption settings.
type EncryptionSettingsProperties struct {
	// REQUIRED; The encryption status to indicates if encryption is enabled or not.
	EncryptionStatus *EncryptionStatus `json:"encryptionStatus,omitempty"`

	// REQUIRED; The key rollover status to indicates if key rollover is required or not. If secret's encryption has been upgraded, then it requires key rollover.
	KeyRolloverStatus *KeyRolloverStatus `json:"keyRolloverStatus,omitempty"`
}

// FailoverRequest - The request object for triggering a failover of volume containers, from a source device to a target device.
type FailoverRequest struct {
	// The ARM path ID of the device which will act as the failover target.
	TargetDeviceID *string `json:"targetDeviceId,omitempty"`

	// The list of path IDs of the volume containers which needs to be failed-over to the target device.
	VolumeContainers []*string `json:"volumeContainers,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FailoverRequest.
func (f FailoverRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "targetDeviceId", f.TargetDeviceID)
	populate(objectMap, "volumeContainers", f.VolumeContainers)
	return json.Marshal(objectMap)
}

// FailoverSet - The failover set on a device.
type FailoverSet struct {
	// The eligibility result of the failover set, for failover.
	EligibilityResult *FailoverSetEligibilityResult `json:"eligibilityResult,omitempty"`

	// The list of meta data of volume containers, which are part of the failover set.
	VolumeContainers []*VolumeContainerFailoverMetadata `json:"volumeContainers,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FailoverSet.
func (f FailoverSet) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "eligibilityResult", f.EligibilityResult)
	populate(objectMap, "volumeContainers", f.VolumeContainers)
	return json.Marshal(objectMap)
}

// FailoverSetEligibilityResult - The eligibility result of failover set, for failover.
type FailoverSetEligibilityResult struct {
	// The error message, if the failover set is not eligible for failover.
	ErrorMessage *string `json:"errorMessage,omitempty"`

	// Represents if this failover set is eligible for failover or not.
	IsEligibleForFailover *bool `json:"isEligibleForFailover,omitempty"`
}

// FailoverSetsList - The list of failover sets.
type FailoverSetsList struct {
	// The list of failover sets.
	Value []*FailoverSet `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FailoverSetsList.
func (f FailoverSetsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// FailoverTarget - Represents the eligibility of a device as a failover target device.
type FailoverTarget struct {
	// The amount of free local storage available on the device in bytes.
	AvailableLocalStorageInBytes *int64 `json:"availableLocalStorageInBytes,omitempty"`

	// The amount of free tiered storage available for the device in bytes.
	AvailableTieredStorageInBytes *int64 `json:"availableTieredStorageInBytes,omitempty"`

	// The count of data containers on the device.
	DataContainersCount *int32 `json:"dataContainersCount,omitempty"`

	// The path ID of the device.
	DeviceID *string `json:"deviceId,omitempty"`

	// The geo location (applicable only for cloud appliances) of the device.
	DeviceLocation *string `json:"deviceLocation,omitempty"`

	// The software version of the device.
	DeviceSoftwareVersion *string `json:"deviceSoftwareVersion,omitempty"`

	// The status of the device.
	DeviceStatus *DeviceStatus `json:"deviceStatus,omitempty"`

	// The eligibility result of the device, as a failover target device.
	EligibilityResult *TargetEligibilityResult `json:"eligibilityResult,omitempty"`

	// The friendly name for the current version of software on the device.
	FriendlyDeviceSoftwareVersion *string `json:"friendlyDeviceSoftwareVersion,omitempty"`

	// The model number of the device.
	ModelDescription *string `json:"modelDescription,omitempty"`

	// The count of volumes on the device.
	VolumesCount *int32 `json:"volumesCount,omitempty"`
}

// FailoverTargetsList - The list of all devices in a resource and their eligibility status as a failover target device.
type FailoverTargetsList struct {
	// The list of all the failover targets.
	Value []*FailoverTarget `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FailoverTargetsList.
func (f FailoverTargetsList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// Feature - The feature.
type Feature struct {
	// REQUIRED; The name of the feature.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The feature support status.
	Status *FeatureSupportStatus `json:"status,omitempty"`
}

// FeatureFilter - The OData filter to be used for features.
type FeatureFilter struct {
	// Specifies the device ID for which the features are required. Only 'Equality' operator is supported for this property.
	DeviceID *string `json:"deviceId,omitempty"`
}

// FeatureList - The collections of features.
type FeatureList struct {
	// REQUIRED; The value.
	Value []*Feature `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type FeatureList.
func (f FeatureList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", f.Value)
	return json.Marshal(objectMap)
}

// HardwareComponent - The hardware component.
type HardwareComponent struct {
	// REQUIRED; The component ID.
	ComponentID *string `json:"componentId,omitempty"`

	// REQUIRED; The display name of the hardware component.
	DisplayName *string `json:"displayName,omitempty"`

	// REQUIRED; The status of the hardware component.
	Status *HardwareComponentStatus `json:"status,omitempty"`

	// REQUIRED; The display name of the status of hardware component.
	StatusDisplayName *string `json:"statusDisplayName,omitempty"`
}

// HardwareComponentGroup - The hardware component group.
type HardwareComponentGroup struct {
	BaseModel
	// REQUIRED; The properties of the hardware component group.
	Properties *HardwareComponentGroupProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HardwareComponentGroup.
func (h HardwareComponentGroup) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	h.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", h.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HardwareComponentGroup.
func (h *HardwareComponentGroup) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &h.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := h.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// HardwareComponentGroupList - The collection of hardware component groups.
type HardwareComponentGroupList struct {
	// REQUIRED; The value.
	Value []*HardwareComponentGroup `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HardwareComponentGroupList.
func (h HardwareComponentGroupList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", h.Value)
	return json.Marshal(objectMap)
}

// HardwareComponentGroupProperties - The properties of hardware component group.
type HardwareComponentGroupProperties struct {
	// REQUIRED; The list of hardware components.
	Components []*HardwareComponent `json:"components,omitempty"`

	// REQUIRED; The display name the hardware component group.
	DisplayName *string `json:"displayName,omitempty"`

	// REQUIRED; The last updated time.
	LastUpdatedTime *time.Time `json:"lastUpdatedTime,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type HardwareComponentGroupProperties.
func (h HardwareComponentGroupProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "components", h.Components)
	populate(objectMap, "displayName", h.DisplayName)
	populate(objectMap, "lastUpdatedTime", (*timeRFC3339)(h.LastUpdatedTime))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type HardwareComponentGroupProperties.
func (h *HardwareComponentGroupProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "components":
			err = unpopulate(val, &h.Components)
			delete(rawMsg, key)
		case "displayName":
			err = unpopulate(val, &h.DisplayName)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			h.LastUpdatedTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// HardwareComponentGroupsBeginChangeControllerPowerStateOptions contains the optional parameters for the HardwareComponentGroups.BeginChangeControllerPowerState
// method.
type HardwareComponentGroupsBeginChangeControllerPowerStateOptions struct {
	// placeholder for future optional parameters
}

// HardwareComponentGroupsListByDeviceOptions contains the optional parameters for the HardwareComponentGroups.ListByDevice method.
type HardwareComponentGroupsListByDeviceOptions struct {
	// placeholder for future optional parameters
}

// Job - The job.
type Job struct {
	BaseModel
	// REQUIRED; The percentage of the job that is already complete.
	PercentComplete *int32 `json:"percentComplete,omitempty"`

	// REQUIRED; The current status of the job.
	Status *JobStatus `json:"status,omitempty"`

	// The UTC time at which the job completed.
	EndTime *time.Time `json:"endTime,omitempty"`

	// The error details, if any, for the job.
	Error *JobErrorDetails `json:"error,omitempty"`

	// The properties of the job.
	Properties *JobProperties `json:"properties,omitempty"`

	// The UTC time at which the job was started.
	StartTime *time.Time `json:"startTime,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Job.
func (j Job) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	j.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "endTime", (*timeRFC3339)(j.EndTime))
	populate(objectMap, "error", j.Error)
	populate(objectMap, "percentComplete", j.PercentComplete)
	populate(objectMap, "properties", j.Properties)
	populate(objectMap, "startTime", (*timeRFC3339)(j.StartTime))
	populate(objectMap, "status", j.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Job.
func (j *Job) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "endTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			j.EndTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "error":
			err = unpopulate(val, &j.Error)
			delete(rawMsg, key)
		case "percentComplete":
			err = unpopulate(val, &j.PercentComplete)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &j.Properties)
			delete(rawMsg, key)
		case "startTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			j.StartTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &j.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := j.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// JobErrorDetails - The job error details. Contains list of job error items.
type JobErrorDetails struct {
	// REQUIRED; The error code intended for programmatic access.
	Code *string `json:"code,omitempty"`

	// REQUIRED; The error message intended to describe the error in detail.
	Message *string `json:"message,omitempty"`

	// The error details.
	ErrorDetails []*JobErrorItem `json:"errorDetails,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobErrorDetails.
func (j JobErrorDetails) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", j.Code)
	populate(objectMap, "errorDetails", j.ErrorDetails)
	populate(objectMap, "message", j.Message)
	return json.Marshal(objectMap)
}

// JobErrorItem - The job error items.
type JobErrorItem struct {
	// REQUIRED; The error code intended for programmatic access.
	Code *string `json:"code,omitempty"`

	// REQUIRED; The error message intended to describe the error in detail.
	Message *string `json:"message,omitempty"`

	// The recommended actions.
	Recommendations []*string `json:"recommendations,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobErrorItem.
func (j JobErrorItem) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "code", j.Code)
	populate(objectMap, "message", j.Message)
	populate(objectMap, "recommendations", j.Recommendations)
	return json.Marshal(objectMap)
}

// JobFilter - The OData filter to be used for jobs.
type JobFilter struct {
	// Specifies the type of the jobs to be filtered. For e.g., "ScheduledBackup", "ManualBackup", "RestoreBackup", "CloneVolume", "FailoverVolumeContainers",
	// "CreateLocallyPinnedVolume", "ModifyVolume",
	// "InstallUpdates", "SupportPackageLogs", or "CreateCloudAppliance". Only 'Equality' operator can be used for this property.
	JobType *string `json:"jobType,omitempty"`

	// Specifies the start time of the jobs to be filtered. Only 'Greater Than or Equal To' and 'Lesser Than or Equal To' operators are supported for this property.
	StartTime *time.Time `json:"startTime,omitempty"`

	// Specifies the status of the jobs to be filtered. For e.g., "Running", "Succeeded", "Failed" or "Canceled". Only 'Equality' operator is supported for
	// this property.
	Status *string `json:"status,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobFilter.
func (j JobFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "jobType", j.JobType)
	populate(objectMap, "startTime", (*timeRFC3339)(j.StartTime))
	populate(objectMap, "status", j.Status)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobFilter.
func (j *JobFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "jobType":
			err = unpopulate(val, &j.JobType)
			delete(rawMsg, key)
		case "startTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			j.StartTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "status":
			err = unpopulate(val, &j.Status)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobList - The collection of jobs.
type JobList struct {
	// REQUIRED; The value.
	Value []*Job `json:"value,omitempty"`

	// The NextLink.
	NextLink *string `json:"nextLink,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobList.
func (j JobList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "nextLink", j.NextLink)
	populate(objectMap, "value", j.Value)
	return json.Marshal(objectMap)
}

// JobProperties - The properties of the job.
type JobProperties struct {
	// REQUIRED; The type of the job.
	JobType *JobType `json:"jobType,omitempty"`

	// The time of the backup used for the failover.
	BackupPointInTime *time.Time `json:"backupPointInTime,omitempty"`

	// The backup type (CloudSnapshot | LocalSnapshot). Applicable only for backup jobs.
	BackupType *BackupType `json:"backupType,omitempty"`

	// The data statistics properties of the job.
	DataStats *DataStatistics `json:"dataStats,omitempty"`

	// The device ID in which the job ran.
	DeviceID *string `json:"deviceId,omitempty"`

	// The entity identifier for which the job ran.
	EntityLabel *string `json:"entityLabel,omitempty"`

	// The entity type for which the job ran.
	EntityType *string `json:"entityType,omitempty"`

	// Represents whether the job is cancellable or not.
	IsCancellable *bool `json:"isCancellable,omitempty"`

	// The job stages.
	JobStages []*JobStage `json:"jobStages,omitempty"`

	// The source device ID of the failover job.
	SourceDeviceID *string `json:"sourceDeviceId,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type JobProperties.
func (j JobProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupPointInTime", (*timeRFC3339)(j.BackupPointInTime))
	populate(objectMap, "backupType", j.BackupType)
	populate(objectMap, "dataStats", j.DataStats)
	populate(objectMap, "deviceId", j.DeviceID)
	populate(objectMap, "entityLabel", j.EntityLabel)
	populate(objectMap, "entityType", j.EntityType)
	populate(objectMap, "isCancellable", j.IsCancellable)
	populate(objectMap, "jobStages", j.JobStages)
	populate(objectMap, "jobType", j.JobType)
	populate(objectMap, "sourceDeviceId", j.SourceDeviceID)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type JobProperties.
func (j *JobProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupPointInTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			j.BackupPointInTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "backupType":
			err = unpopulate(val, &j.BackupType)
			delete(rawMsg, key)
		case "dataStats":
			err = unpopulate(val, &j.DataStats)
			delete(rawMsg, key)
		case "deviceId":
			err = unpopulate(val, &j.DeviceID)
			delete(rawMsg, key)
		case "entityLabel":
			err = unpopulate(val, &j.EntityLabel)
			delete(rawMsg, key)
		case "entityType":
			err = unpopulate(val, &j.EntityType)
			delete(rawMsg, key)
		case "isCancellable":
			err = unpopulate(val, &j.IsCancellable)
			delete(rawMsg, key)
		case "jobStages":
			err = unpopulate(val, &j.JobStages)
			delete(rawMsg, key)
		case "jobType":
			err = unpopulate(val, &j.JobType)
			delete(rawMsg, key)
		case "sourceDeviceId":
			err = unpopulate(val, &j.SourceDeviceID)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// JobStage - The details about the specific stage of a job.
type JobStage struct {
	// REQUIRED; The stage status.
	StageStatus *JobStatus `json:"stageStatus,omitempty"`

	// The details of the stage.
	Detail *string `json:"detail,omitempty"`

	// The error code of the stage if any.
	ErrorCode *string `json:"errorCode,omitempty"`

	// The message of the job stage.
	Message *string `json:"message,omitempty"`
}

// JobsBeginCancelOptions contains the optional parameters for the Jobs.BeginCancel method.
type JobsBeginCancelOptions struct {
	// placeholder for future optional parameters
}

// JobsGetOptions contains the optional parameters for the Jobs.Get method.
type JobsGetOptions struct {
	// placeholder for future optional parameters
}

// JobsListByDeviceOptions contains the optional parameters for the Jobs.ListByDevice method.
type JobsListByDeviceOptions struct {
	// OData Filter options
	Filter *string
}

// JobsListByManagerOptions contains the optional parameters for the Jobs.ListByManager method.
type JobsListByManagerOptions struct {
	// OData Filter options
	Filter *string
}

// Key - The key.
type Key struct {
	// REQUIRED; The activation key for the device.
	ActivationKey *string `json:"activationKey,omitempty"`
}

// ListFailoverTargetsRequest - The request object for fetching the list of failover targets (eligible devices for failover).
type ListFailoverTargetsRequest struct {
	// The list of path IDs of the volume containers that needs to be failed-over, for which we want to fetch the eligible targets.
	VolumeContainers []*string `json:"volumeContainers,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ListFailoverTargetsRequest.
func (l ListFailoverTargetsRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "volumeContainers", l.VolumeContainers)
	return json.Marshal(objectMap)
}

// Manager - The StorSimple Manager.
type Manager struct {
	Resource
	// The etag of the manager.
	Etag *string `json:"etag,omitempty"`

	// The properties of the StorSimple Manager.
	Properties *ManagerProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Manager.
func (m Manager) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.Resource.marshalInternal(objectMap)
	populate(objectMap, "etag", m.Etag)
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// ManagerExtendedInfo - The extended info of the manager.
type ManagerExtendedInfo struct {
	BaseModel
	// The etag of the resource.
	Etag *string `json:"etag,omitempty"`

	// The extended info properties.
	Properties *ManagerExtendedInfoProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagerExtendedInfo.
func (m ManagerExtendedInfo) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	m.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "etag", m.Etag)
	populate(objectMap, "properties", m.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type ManagerExtendedInfo.
func (m *ManagerExtendedInfo) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "etag":
			err = unpopulate(val, &m.Etag)
			delete(rawMsg, key)
		case "properties":
			err = unpopulate(val, &m.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := m.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// ManagerExtendedInfoProperties - The properties of the manager extended info.
type ManagerExtendedInfoProperties struct {
	// REQUIRED; Represents the encryption algorithm used to encrypt the keys. None - if Key is saved in plain text format. Algorithm name - if key is encrypted
	Algorithm *string `json:"algorithm,omitempty"`

	// REQUIRED; Represents the CIK of the resource.
	IntegrityKey *string `json:"integrityKey,omitempty"`

	// Represents the CEK of the resource.
	EncryptionKey *string `json:"encryptionKey,omitempty"`

	// Represents the Cert thumbprint that was used to encrypt the CEK.
	EncryptionKeyThumbprint *string `json:"encryptionKeyThumbprint,omitempty"`

	// Represents the portal thumbprint which can be used optionally to encrypt the entire data before storing it.
	PortalCertificateThumbprint *string `json:"portalCertificateThumbprint,omitempty"`

	// The version of the extended info being persisted.
	Version *string `json:"version,omitempty"`
}

// ManagerIntrinsicSettings - Intrinsic settings which refers to the type of the StorSimple Manager.
type ManagerIntrinsicSettings struct {
	// REQUIRED; The type of StorSimple Manager.
	Type *ManagerType `json:"type,omitempty"`
}

// ManagerList - The list of StorSimple Managers.
type ManagerList struct {
	// REQUIRED; The list of StorSimple managers.
	Value []*Manager `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagerList.
func (m ManagerList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// ManagerPatch - The StorSimple Manager patch.
type ManagerPatch struct {
	// The tags attached to the Manager.
	Tags map[string]*string `json:"tags,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ManagerPatch.
func (m ManagerPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "tags", m.Tags)
	return json.Marshal(objectMap)
}

// ManagerProperties - The properties of the StorSimple Manager.
type ManagerProperties struct {
	// Represents the type of StorSimple Manager.
	CisIntrinsicSettings *ManagerIntrinsicSettings `json:"cisIntrinsicSettings,omitempty"`

	// Specifies the state of the resource as it is getting provisioned. Value of "Succeeded" means the Manager was successfully created.
	ProvisioningState *string `json:"provisioningState,omitempty"`

	// Specifies the Sku.
	SKU *ManagerSKU `json:"sku,omitempty"`
}

// ManagerSKU - The Sku.
type ManagerSKU struct {
	// REQUIRED; Refers to the sku name which should be "Standard"
	Name *string `json:"name,omitempty"`
}

// ManagersCreateExtendedInfoOptions contains the optional parameters for the Managers.CreateExtendedInfo method.
type ManagersCreateExtendedInfoOptions struct {
	// placeholder for future optional parameters
}

// ManagersCreateOrUpdateOptions contains the optional parameters for the Managers.CreateOrUpdate method.
type ManagersCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// ManagersDeleteExtendedInfoOptions contains the optional parameters for the Managers.DeleteExtendedInfo method.
type ManagersDeleteExtendedInfoOptions struct {
	// placeholder for future optional parameters
}

// ManagersDeleteOptions contains the optional parameters for the Managers.Delete method.
type ManagersDeleteOptions struct {
	// placeholder for future optional parameters
}

// ManagersGetActivationKeyOptions contains the optional parameters for the Managers.GetActivationKey method.
type ManagersGetActivationKeyOptions struct {
	// placeholder for future optional parameters
}

// ManagersGetDevicePublicEncryptionKeyOptions contains the optional parameters for the Managers.GetDevicePublicEncryptionKey method.
type ManagersGetDevicePublicEncryptionKeyOptions struct {
	// placeholder for future optional parameters
}

// ManagersGetEncryptionSettingsOptions contains the optional parameters for the Managers.GetEncryptionSettings method.
type ManagersGetEncryptionSettingsOptions struct {
	// placeholder for future optional parameters
}

// ManagersGetExtendedInfoOptions contains the optional parameters for the Managers.GetExtendedInfo method.
type ManagersGetExtendedInfoOptions struct {
	// placeholder for future optional parameters
}

// ManagersGetOptions contains the optional parameters for the Managers.Get method.
type ManagersGetOptions struct {
	// placeholder for future optional parameters
}

// ManagersGetPublicEncryptionKeyOptions contains the optional parameters for the Managers.GetPublicEncryptionKey method.
type ManagersGetPublicEncryptionKeyOptions struct {
	// placeholder for future optional parameters
}

// ManagersListByResourceGroupOptions contains the optional parameters for the Managers.ListByResourceGroup method.
type ManagersListByResourceGroupOptions struct {
	// placeholder for future optional parameters
}

// ManagersListFeatureSupportStatusOptions contains the optional parameters for the Managers.ListFeatureSupportStatus method.
type ManagersListFeatureSupportStatusOptions struct {
	// OData Filter options
	Filter *string
}

// ManagersListMetricDefinitionOptions contains the optional parameters for the Managers.ListMetricDefinition method.
type ManagersListMetricDefinitionOptions struct {
	// placeholder for future optional parameters
}

// ManagersListMetricsOptions contains the optional parameters for the Managers.ListMetrics method.
type ManagersListMetricsOptions struct {
	// placeholder for future optional parameters
}

// ManagersListOptions contains the optional parameters for the Managers.List method.
type ManagersListOptions struct {
	// placeholder for future optional parameters
}

// ManagersRegenerateActivationKeyOptions contains the optional parameters for the Managers.RegenerateActivationKey method.
type ManagersRegenerateActivationKeyOptions struct {
	// placeholder for future optional parameters
}

// ManagersUpdateExtendedInfoOptions contains the optional parameters for the Managers.UpdateExtendedInfo method.
type ManagersUpdateExtendedInfoOptions struct {
	// placeholder for future optional parameters
}

// ManagersUpdateOptions contains the optional parameters for the Managers.Update method.
type ManagersUpdateOptions struct {
	// placeholder for future optional parameters
}

// MetricAvailablity - The metric availability.
type MetricAvailablity struct {
	// The retention period for the metric at the specified timegrain.
	Retention *string `json:"retention,omitempty"`

	// The aggregation interval for the metric.
	TimeGrain *string `json:"timeGrain,omitempty"`
}

// MetricData - The metric data.
type MetricData struct {
	// The average of all samples at the time stamp.
	Average *float64 `json:"average,omitempty"`

	// The count of all samples at the time stamp.
	Count *int32 `json:"count,omitempty"`

	// The maximum of all samples at the time stamp.
	Maximum *float64 `json:"maximum,omitempty"`

	// The minimum of all samples at the time stamp.
	Minimum *float64 `json:"minimum,omitempty"`

	// The sum of all samples at the time stamp.
	Sum *float64 `json:"sum,omitempty"`

	// The time stamp of the metric data.
	TimeStamp *time.Time `json:"timeStamp,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MetricData.
func (m MetricData) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "average", m.Average)
	populate(objectMap, "count", m.Count)
	populate(objectMap, "maximum", m.Maximum)
	populate(objectMap, "minimum", m.Minimum)
	populate(objectMap, "sum", m.Sum)
	populate(objectMap, "timeStamp", (*timeRFC3339)(m.TimeStamp))
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MetricData.
func (m *MetricData) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "average":
			err = unpopulate(val, &m.Average)
			delete(rawMsg, key)
		case "count":
			err = unpopulate(val, &m.Count)
			delete(rawMsg, key)
		case "maximum":
			err = unpopulate(val, &m.Maximum)
			delete(rawMsg, key)
		case "minimum":
			err = unpopulate(val, &m.Minimum)
			delete(rawMsg, key)
		case "sum":
			err = unpopulate(val, &m.Sum)
			delete(rawMsg, key)
		case "timeStamp":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.TimeStamp = (*time.Time)(&aux)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MetricDefinition - The monitoring metric definition.
type MetricDefinition struct {
	// The category of the metric.
	Category *string `json:"category,omitempty"`

	// The available metric dimensions.
	Dimensions []*MetricDimension `json:"dimensions,omitempty"`

	// The available metric granularities.
	MetricAvailabilities []*MetricAvailablity `json:"metricAvailabilities,omitempty"`

	// The metric name.
	Name *MetricName `json:"name,omitempty"`

	// The metric aggregation type.
	PrimaryAggregationType *MetricAggregationType `json:"primaryAggregationType,omitempty"`

	// The metric source ID.
	ResourceID *string `json:"resourceId,omitempty"`

	// The metric definition type.
	Type *string `json:"type,omitempty"`

	// The metric unit.
	Unit *MetricUnit `json:"unit,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MetricDefinition.
func (m MetricDefinition) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "category", m.Category)
	populate(objectMap, "dimensions", m.Dimensions)
	populate(objectMap, "metricAvailabilities", m.MetricAvailabilities)
	populate(objectMap, "name", m.Name)
	populate(objectMap, "primaryAggregationType", m.PrimaryAggregationType)
	populate(objectMap, "resourceId", m.ResourceID)
	populate(objectMap, "type", m.Type)
	populate(objectMap, "unit", m.Unit)
	return json.Marshal(objectMap)
}

// MetricDefinitionList - The list of metric definitions.
type MetricDefinitionList struct {
	// The list of metric definitions.
	Value []*MetricDefinition `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MetricDefinitionList.
func (m MetricDefinitionList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// MetricDimension - The metric dimension. It indicates the source of the metric.
type MetricDimension struct {
	// The metric dimension name.
	Name *string `json:"name,omitempty"`

	// The metric dimension values.
	Value *string `json:"value,omitempty"`
}

// MetricFilter - The OData filters to be used for metrics.
type MetricFilter struct {
	// REQUIRED; Specifies the category of the metrics to be filtered. E.g., "CapacityUtilization". Valid values are the ones returned as the field "category"
	// in the ListMetricDefinitions call. Only 'Equality'
	// operator is supported for this property.
	Category *string `json:"category,omitempty"`

	// Specifies the source(the dimension) of the metrics to be filtered. Only 'Equality' operator is supported for this property.
	Dimensions *DimensionFilter `json:"dimensions,omitempty"`

	// Specifies the end time of the time range to be queried. Only 'Less Than Or Equal To' operator is supported for this property.
	EndTime *time.Time `json:"endTime,omitempty"`

	// Specifies the metric name filter specifying the name of the metric to be filtered on. Only 'Equality' operator is supported for this property.
	Name *MetricNameFilter `json:"name,omitempty"`

	// Specifies the start time of the time range to be queried. Only 'Greater Than Or Equal To' operator is supported for this property.
	StartTime *time.Time `json:"startTime,omitempty"`

	// Specifies the time granularity of the metrics to be returned. E.g., "P1D". Valid values are the ones returned as the field "timeGrain" in the ListMetricDefinitions
	// call. Only 'Equality' operator is
	// supported for this property.
	TimeGrain *string `json:"timeGrain,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MetricFilter.
func (m MetricFilter) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "category", m.Category)
	populate(objectMap, "dimensions", m.Dimensions)
	populate(objectMap, "endTime", (*timeRFC3339)(m.EndTime))
	populate(objectMap, "name", m.Name)
	populate(objectMap, "startTime", (*timeRFC3339)(m.StartTime))
	populate(objectMap, "timeGrain", m.TimeGrain)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type MetricFilter.
func (m *MetricFilter) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "category":
			err = unpopulate(val, &m.Category)
			delete(rawMsg, key)
		case "dimensions":
			err = unpopulate(val, &m.Dimensions)
			delete(rawMsg, key)
		case "endTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "startTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "timeGrain":
			err = unpopulate(val, &m.TimeGrain)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// MetricList - The metric list.
type MetricList struct {
	// The value.
	Value []*Metrics `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type MetricList.
func (m MetricList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", m.Value)
	return json.Marshal(objectMap)
}

// MetricName - The metric name.
type MetricName struct {
	// The localized metric name.
	LocalizedValue *string `json:"localizedValue,omitempty"`

	// The metric name.
	Value *string `json:"value,omitempty"`
}

// MetricNameFilter - The metric name filter, specifying the name of the metric to be filtered on.
type MetricNameFilter struct {
	// Specifies the metric name to be filtered on. E.g., CloudStorageUsed. Valid values are the ones returned in the field "name" in the ListMetricDefinitions
	// call. Only 'Equality' operator is supported for
	// this property.
	Value *string `json:"value,omitempty"`
}

// Metrics - The monitoring metric.
type Metrics struct {
	// The metric dimensions.
	Dimensions []*MetricDimension `json:"dimensions,omitempty"`

	// The end time of the metric data.
	EndTime *time.Time `json:"endTime,omitempty"`

	// The name of the metric.
	Name *MetricName `json:"name,omitempty"`

	// The metric aggregation type.
	PrimaryAggregation *MetricAggregationType `json:"primaryAggregation,omitempty"`

	// The ID of metric source.
	ResourceID *string `json:"resourceId,omitempty"`

	// The start time of the metric data.
	StartTime *time.Time `json:"startTime,omitempty"`

	// The time granularity of the metric data.
	TimeGrain *string `json:"timeGrain,omitempty"`

	// The type of the metric data.
	Type *string `json:"type,omitempty"`

	// The unit of the metric data.
	Unit *MetricUnit `json:"unit,omitempty"`

	// The list of the metric data.
	Values []*MetricData `json:"values,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Metrics.
func (m Metrics) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "dimensions", m.Dimensions)
	populate(objectMap, "endTime", (*timeRFC3339)(m.EndTime))
	populate(objectMap, "name", m.Name)
	populate(objectMap, "primaryAggregation", m.PrimaryAggregation)
	populate(objectMap, "resourceId", m.ResourceID)
	populate(objectMap, "startTime", (*timeRFC3339)(m.StartTime))
	populate(objectMap, "timeGrain", m.TimeGrain)
	populate(objectMap, "type", m.Type)
	populate(objectMap, "unit", m.Unit)
	populate(objectMap, "values", m.Values)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Metrics.
func (m *Metrics) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "dimensions":
			err = unpopulate(val, &m.Dimensions)
			delete(rawMsg, key)
		case "endTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.EndTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "name":
			err = unpopulate(val, &m.Name)
			delete(rawMsg, key)
		case "primaryAggregation":
			err = unpopulate(val, &m.PrimaryAggregation)
			delete(rawMsg, key)
		case "resourceId":
			err = unpopulate(val, &m.ResourceID)
			delete(rawMsg, key)
		case "startTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			m.StartTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "timeGrain":
			err = unpopulate(val, &m.TimeGrain)
			delete(rawMsg, key)
		case "type":
			err = unpopulate(val, &m.Type)
			delete(rawMsg, key)
		case "unit":
			err = unpopulate(val, &m.Unit)
			delete(rawMsg, key)
		case "values":
			err = unpopulate(val, &m.Values)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// NetworkAdapterList - The collection of network adapters on the device.
type NetworkAdapterList struct {
	// REQUIRED; The value.
	Value []*NetworkAdapters `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NetworkAdapterList.
func (n NetworkAdapterList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", n.Value)
	return json.Marshal(objectMap)
}

// NetworkAdapters - Represents the network adapter on device.
type NetworkAdapters struct {
	// REQUIRED; The ID of the network adapter.
	InterfaceID *NetInterfaceID `json:"interfaceId,omitempty"`

	// REQUIRED; Value indicating cloud and ISCSI status of network adapter.
	IscsiAndCloudStatus *ISCSIAndCloudStatus `json:"iscsiAndCloudStatus,omitempty"`

	// REQUIRED; The mode of network adapter, either IPv4, IPv6 or both.
	Mode *NetworkMode `json:"mode,omitempty"`

	// REQUIRED; Value indicating status of network adapter.
	NetInterfaceStatus *NetInterfaceStatus `json:"netInterfaceStatus,omitempty"`

	// Value indicating whether this instance is default.
	IsDefault *bool `json:"isDefault,omitempty"`

	// The IPv4 configuration of the network adapter.
	NicIPv4Settings *NicIPv4 `json:"nicIpv4Settings,omitempty"`

	// The IPv6 configuration of the network adapter.
	NicIPv6Settings *NicIPv6 `json:"nicIpv6Settings,omitempty"`

	// The speed of the network adapter.
	Speed *int64 `json:"speed,omitempty"`
}

// NetworkInterfaceData0Settings - The 'Data 0' network interface card settings.
type NetworkInterfaceData0Settings struct {
	// The controller 1's IPv4 address.
	ControllerOneIP *string `json:"controllerOneIp,omitempty"`

	// The controller 0's IPv4 address.
	ControllerZeroIP *string `json:"controllerZeroIp,omitempty"`
}

// NetworkSettings - Represents the network settings of a device.
type NetworkSettings struct {
	BaseModel
	// REQUIRED; The properties of network settings of a device.
	Properties *NetworkSettingsProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NetworkSettings.
func (n NetworkSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	n.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", n.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type NetworkSettings.
func (n *NetworkSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &n.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := n.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// NetworkSettingsPatch - Represents the patch request for the network settings of a device.
type NetworkSettingsPatch struct {
	// REQUIRED; The properties of the network settings patch.
	Properties *NetworkSettingsPatchProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type NetworkSettingsPatch.
func (n NetworkSettingsPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", n.Properties)
	return json.Marshal(objectMap)
}

// NetworkSettingsPatchProperties - The properties of the network settings patch.
type NetworkSettingsPatchProperties struct {
	// The DNS (Domain Name System) settings of device.
	DNSSettings *DNSSettings `json:"dnsSettings,omitempty"`

	// The network adapter list of device.
	NetworkAdapters *NetworkAdapterList `json:"networkAdapters,omitempty"`
}

// NetworkSettingsProperties - The properties of the network settings of device.
type NetworkSettingsProperties struct {
	// REQUIRED; The DNS (Domain Name System) settings of device.
	DNSSettings *DNSSettings `json:"dnsSettings,omitempty"`

	// REQUIRED; The network adapter list of device.
	NetworkAdapters *NetworkAdapterList `json:"networkAdapters,omitempty"`

	// REQUIRED; The webproxy settings of device.
	WebproxySettings *WebproxySettings `json:"webproxySettings,omitempty"`
}

// NicIPv4 - Details related to the IPv4 address configuration.
type NicIPv4 struct {
	// The IPv4 address of Controller0.
	Controller0IPv4Address *string `json:"controller0Ipv4Address,omitempty"`

	// The IPv4 address of Controller1.
	Controller1IPv4Address *string `json:"controller1Ipv4Address,omitempty"`

	// The IPv4 address of the network adapter.
	IPv4Address *string `json:"ipv4Address,omitempty"`

	// The IPv4 gateway of the network adapter.
	IPv4Gateway *string `json:"ipv4Gateway,omitempty"`

	// The IPv4 netmask of the network adapter.
	IPv4Netmask *string `json:"ipv4Netmask,omitempty"`
}

// NicIPv6 - Details related to the IPv6 address configuration.
type NicIPv6 struct {
	// The IPv6 address of Controller0.
	Controller0IPv6Address *string `json:"controller0Ipv6Address,omitempty"`

	// The IPv6 address of Controller1.
	Controller1IPv6Address *string `json:"controller1Ipv6Address,omitempty"`

	// The IPv6 address of the network adapter.
	IPv6Address *string `json:"ipv6Address,omitempty"`

	// The IPv6 gateway of the network adapter.
	IPv6Gateway *string `json:"ipv6Gateway,omitempty"`

	// The IPv6 prefix of the network adapter.
	IPv6Prefix *string `json:"ipv6Prefix,omitempty"`
}

// OperationsListOptions contains the optional parameters for the Operations.List method.
type OperationsListOptions struct {
	// placeholder for future optional parameters
}

// PublicKey - The public key.
type PublicKey struct {
	// REQUIRED; The key.
	Key *string `json:"key,omitempty"`
}

// RemoteManagementSettings - The settings for remote management of a device.
type RemoteManagementSettings struct {
	// REQUIRED; The remote management mode.
	RemoteManagementMode *RemoteManagementModeConfiguration `json:"remoteManagementMode,omitempty"`

	// The remote management certificates.
	RemoteManagementCertificate *string `json:"remoteManagementCertificate,omitempty"`
}

// RemoteManagementSettingsPatch - The settings for updating remote management mode of the device.
type RemoteManagementSettingsPatch struct {
	// REQUIRED; The remote management mode.
	RemoteManagementMode *RemoteManagementModeConfiguration `json:"remoteManagementMode,omitempty"`
}

// Resource - The Azure Resource.
type Resource struct {
	// REQUIRED; The geo location of the resource.
	Location *string `json:"location,omitempty"`

	// The tags attached to the resource.
	Tags map[string]*string `json:"tags,omitempty"`

	// READ-ONLY; The resource ID.
	ID *string `json:"id,omitempty" azure:"ro"`

	// READ-ONLY; The resource name.
	Name *string `json:"name,omitempty" azure:"ro"`

	// READ-ONLY; The resource type.
	Type *string `json:"type,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type Resource.
func (r Resource) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	r.marshalInternal(objectMap)
	return json.Marshal(objectMap)
}

func (r Resource) marshalInternal(objectMap map[string]interface{}) {
	populate(objectMap, "id", r.ID)
	populate(objectMap, "location", r.Location)
	populate(objectMap, "name", r.Name)
	populate(objectMap, "tags", r.Tags)
	populate(objectMap, "type", r.Type)
}

// ScheduleRecurrence - The schedule recurrence.
type ScheduleRecurrence struct {
	// REQUIRED; The recurrence type.
	RecurrenceType *RecurrenceType `json:"recurrenceType,omitempty"`

	// REQUIRED; The recurrence value.
	RecurrenceValue *int32 `json:"recurrenceValue,omitempty"`

	// The week days list. Applicable only for schedules of recurrence type 'weekly'.
	WeeklyDaysList []*DayOfWeek `json:"weeklyDaysList,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type ScheduleRecurrence.
func (s ScheduleRecurrence) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "recurrenceType", s.RecurrenceType)
	populate(objectMap, "recurrenceValue", s.RecurrenceValue)
	populate(objectMap, "weeklyDaysList", s.WeeklyDaysList)
	return json.Marshal(objectMap)
}

// SecondaryDNSSettings - The secondary DNS settings.
type SecondaryDNSSettings struct {
	// The list of secondary DNS Server IP addresses.
	SecondaryDNSServers []*string `json:"secondaryDnsServers,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SecondaryDNSSettings.
func (s SecondaryDNSSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "secondaryDnsServers", s.SecondaryDNSServers)
	return json.Marshal(objectMap)
}

// SecuritySettings - The security settings of a device.
type SecuritySettings struct {
	BaseModel
	// REQUIRED; The properties of the security settings of a device.
	Properties *SecuritySettingsProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SecuritySettings.
func (s SecuritySettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type SecuritySettings.
func (s *SecuritySettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// SecuritySettingsPatch - Represents the patch request for the security settings of a device.
type SecuritySettingsPatch struct {
	// REQUIRED; The properties of the security settings patch.
	Properties *SecuritySettingsPatchProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SecuritySettingsPatch.
func (s SecuritySettingsPatch) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// SecuritySettingsPatchProperties - The properties of the security settings patch.
type SecuritySettingsPatchProperties struct {
	// The device CHAP and reverse-CHAP settings.
	ChapSettings *ChapSettings `json:"chapSettings,omitempty"`

	// The cloud appliance settings.
	CloudApplianceSettings *CloudApplianceSettings `json:"cloudApplianceSettings,omitempty"`

	// The device administrator password.
	DeviceAdminPassword *AsymmetricEncryptedSecret `json:"deviceAdminPassword,omitempty"`

	// The remote management settings.
	RemoteManagementSettings *RemoteManagementSettingsPatch `json:"remoteManagementSettings,omitempty"`

	// The snapshot manager password.
	SnapshotPassword *AsymmetricEncryptedSecret `json:"snapshotPassword,omitempty"`
}

// SecuritySettingsProperties - The properties of security settings of a device.
type SecuritySettingsProperties struct {
	// REQUIRED; The Challenge-Handshake Authentication Protocol (CHAP) settings.
	ChapSettings *ChapSettings `json:"chapSettings,omitempty"`

	// REQUIRED; The settings for remote management of a device.
	RemoteManagementSettings *RemoteManagementSettings `json:"remoteManagementSettings,omitempty"`
}

// SendTestAlertEmailRequest - The request for sending test alert email
type SendTestAlertEmailRequest struct {
	// REQUIRED; The list of email IDs to send the test alert email
	EmailList []*string `json:"emailList,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type SendTestAlertEmailRequest.
func (s SendTestAlertEmailRequest) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "emailList", s.EmailList)
	return json.Marshal(objectMap)
}

// StorageAccountCredential - The storage account credential.
type StorageAccountCredential struct {
	BaseModel
	// REQUIRED; The storage account credential properties.
	Properties *StorageAccountCredentialProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageAccountCredential.
func (s StorageAccountCredential) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	s.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", s.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type StorageAccountCredential.
func (s *StorageAccountCredential) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &s.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := s.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// StorageAccountCredentialList - The collection of storage account credential entities.
type StorageAccountCredentialList struct {
	// REQUIRED; The value.
	Value []*StorageAccountCredential `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type StorageAccountCredentialList.
func (s StorageAccountCredentialList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", s.Value)
	return json.Marshal(objectMap)
}

// StorageAccountCredentialProperties - The storage account credential properties.
type StorageAccountCredentialProperties struct {
	// REQUIRED; The storage endpoint
	EndPoint *string `json:"endPoint,omitempty"`

	// REQUIRED; Signifies whether SSL needs to be enabled or not.
	SSLStatus *SSLStatus `json:"sslStatus,omitempty"`

	// The details of the storage account password.
	AccessKey *AsymmetricEncryptedSecret `json:"accessKey,omitempty"`

	// READ-ONLY; The count of volumes using this storage account credential.
	VolumesCount *int32 `json:"volumesCount,omitempty" azure:"ro"`
}

// StorageAccountCredentialsBeginCreateOrUpdateOptions contains the optional parameters for the StorageAccountCredentials.BeginCreateOrUpdate method.
type StorageAccountCredentialsBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountCredentialsBeginDeleteOptions contains the optional parameters for the StorageAccountCredentials.BeginDelete method.
type StorageAccountCredentialsBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountCredentialsGetOptions contains the optional parameters for the StorageAccountCredentials.Get method.
type StorageAccountCredentialsGetOptions struct {
	// placeholder for future optional parameters
}

// StorageAccountCredentialsListByManagerOptions contains the optional parameters for the StorageAccountCredentials.ListByManager method.
type StorageAccountCredentialsListByManagerOptions struct {
	// placeholder for future optional parameters
}

// SymmetricEncryptedSecret - Represents the secrets encrypted using Symmetric Encryption Key.
type SymmetricEncryptedSecret struct {
	// REQUIRED; The algorithm used to encrypt the "Value".
	EncryptionAlgorithm *EncryptionAlgorithm `json:"encryptionAlgorithm,omitempty"`

	// REQUIRED; The value of the secret itself. If the secret is in plaintext or null then EncryptionAlgorithm will be none.
	Value *string `json:"value,omitempty"`

	// The thumbprint of the cert that was used to encrypt "Value".
	ValueCertificateThumbprint *string `json:"valueCertificateThumbprint,omitempty"`
}

// TargetEligibilityErrorMessage - The error/warning message due to which the device is ineligible as a failover target device.
type TargetEligibilityErrorMessage struct {
	// The localized error message stating the reason why the device is not eligible as a target device.
	Message *string `json:"message,omitempty"`

	// The localized resolution message for the error.
	Resolution *string `json:"resolution,omitempty"`

	// The result code for the error, due to which the device does not qualify as a failover target device.
	ResultCode *TargetEligibilityResultCode `json:"resultCode,omitempty"`
}

// TargetEligibilityResult - The eligibility result of device, as a failover target device.
type TargetEligibilityResult struct {
	// The eligibility status of device, as a failover target device.
	EligibilityStatus *TargetEligibilityStatus `json:"eligibilityStatus,omitempty"`

	// The list of error messages, if a device does not qualify as a failover target device.
	Messages []*TargetEligibilityErrorMessage `json:"messages,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TargetEligibilityResult.
func (t TargetEligibilityResult) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "eligibilityStatus", t.EligibilityStatus)
	populate(objectMap, "messages", t.Messages)
	return json.Marshal(objectMap)
}

// Time - The time.
type Time struct {
	// REQUIRED; The hour.
	Hours *int32 `json:"hours,omitempty"`

	// REQUIRED; The minute.
	Minutes *int32 `json:"minutes,omitempty"`

	// REQUIRED; The second.
	Seconds *int32 `json:"seconds,omitempty"`
}

// TimeSettings - The time settings of a device.
type TimeSettings struct {
	BaseModel
	// REQUIRED; The properties of the time settings of a device.
	Properties *TimeSettingsProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TimeSettings.
func (t TimeSettings) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	t.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", t.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type TimeSettings.
func (t *TimeSettings) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &t.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := t.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// TimeSettingsProperties - The properties of time settings of a device.
type TimeSettingsProperties struct {
	// REQUIRED; The timezone of device, like '(UTC -06:00) Central America'
	TimeZone *string `json:"timeZone,omitempty"`

	// The primary Network Time Protocol (NTP) server name, like 'time.windows.com'.
	PrimaryTimeServer *string `json:"primaryTimeServer,omitempty"`

	// The secondary Network Time Protocol (NTP) server name, like 'time.contoso.com'. It's optional.
	SecondaryTimeServer []*string `json:"secondaryTimeServer,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type TimeSettingsProperties.
func (t TimeSettingsProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "primaryTimeServer", t.PrimaryTimeServer)
	populate(objectMap, "secondaryTimeServer", t.SecondaryTimeServer)
	populate(objectMap, "timeZone", t.TimeZone)
	return json.Marshal(objectMap)
}

// Updates - The updates profile of a device.
type Updates struct {
	BaseModel
	// REQUIRED; The properties of the updates profile.
	Properties *UpdatesProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Updates.
func (u Updates) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	u.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", u.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Updates.
func (u *Updates) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &u.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := u.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// UpdatesProperties - The properties of the updates profile.
type UpdatesProperties struct {
	// Indicates whether an update is in progress or not.
	IsUpdateInProgress *bool `json:"isUpdateInProgress,omitempty"`

	// The time when the last update was completed.
	LastUpdatedTime *time.Time `json:"lastUpdatedTime,omitempty"`

	// Set to 'true' if maintenance mode update available.
	MaintenanceModeUpdatesAvailable *bool `json:"maintenanceModeUpdatesAvailable,omitempty"`

	// Set to 'true' if regular updates are available for the device.
	RegularUpdatesAvailable *bool `json:"regularUpdatesAvailable,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type UpdatesProperties.
func (u UpdatesProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "isUpdateInProgress", u.IsUpdateInProgress)
	populate(objectMap, "lastUpdatedTime", (*timeRFC3339)(u.LastUpdatedTime))
	populate(objectMap, "maintenanceModeUpdatesAvailable", u.MaintenanceModeUpdatesAvailable)
	populate(objectMap, "regularUpdatesAvailable", u.RegularUpdatesAvailable)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type UpdatesProperties.
func (u *UpdatesProperties) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "isUpdateInProgress":
			err = unpopulate(val, &u.IsUpdateInProgress)
			delete(rawMsg, key)
		case "lastUpdatedTime":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			u.LastUpdatedTime = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "maintenanceModeUpdatesAvailable":
			err = unpopulate(val, &u.MaintenanceModeUpdatesAvailable)
			delete(rawMsg, key)
		case "regularUpdatesAvailable":
			err = unpopulate(val, &u.RegularUpdatesAvailable)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// VMImage - The virtual machine image.
type VMImage struct {
	// REQUIRED; The name.
	Name *string `json:"name,omitempty"`

	// REQUIRED; The offer.
	Offer *string `json:"offer,omitempty"`

	// REQUIRED; The publisher.
	Publisher *string `json:"publisher,omitempty"`

	// REQUIRED; The SKU.
	SKU *string `json:"sku,omitempty"`

	// REQUIRED; The version.
	Version *string `json:"version,omitempty"`
}

// Volume - The volume.
type Volume struct {
	BaseModel
	// REQUIRED; The properties of the volume.
	Properties *VolumeProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type Volume.
func (v Volume) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	v.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", v.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type Volume.
func (v *Volume) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &v.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := v.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// VolumeContainer - The volume container.
type VolumeContainer struct {
	BaseModel
	// REQUIRED; The volume container properties.
	Properties *VolumeContainerProperties `json:"properties,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VolumeContainer.
func (v VolumeContainer) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	v.BaseModel.marshalInternal(objectMap)
	populate(objectMap, "properties", v.Properties)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VolumeContainer.
func (v *VolumeContainer) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "properties":
			err = unpopulate(val, &v.Properties)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	if err := v.BaseModel.unmarshalInternal(rawMsg); err != nil {
		return err
	}
	return nil
}

// VolumeContainerFailoverMetadata - The metadata of the volume container, that is being considered as part of a failover set.
type VolumeContainerFailoverMetadata struct {
	// The path ID of the volume container.
	VolumeContainerID *string `json:"volumeContainerId,omitempty"`

	// The list of metadata of volumes inside the volume container, which contains valid cloud snapshots.
	Volumes []*VolumeFailoverMetadata `json:"volumes,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VolumeContainerFailoverMetadata.
func (v VolumeContainerFailoverMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "volumeContainerId", v.VolumeContainerID)
	populate(objectMap, "volumes", v.Volumes)
	return json.Marshal(objectMap)
}

// VolumeContainerList - The collection of volume container entities.
type VolumeContainerList struct {
	// REQUIRED; The value.
	Value []*VolumeContainer `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VolumeContainerList.
func (v VolumeContainerList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// VolumeContainerProperties - The properties of volume container.
type VolumeContainerProperties struct {
	// REQUIRED; The path ID of storage account associated with the volume container.
	StorageAccountCredentialID *string `json:"storageAccountCredentialId,omitempty"`

	// The bandwidth-rate set on the volume container.
	BandWidthRateInMbps *int32 `json:"bandWidthRateInMbps,omitempty"`

	// The ID of the bandwidth setting associated with the volume container.
	BandwidthSettingID *string `json:"bandwidthSettingId,omitempty"`

	// The key used to encrypt data in the volume container. It is required when property 'EncryptionStatus' is "Enabled".
	EncryptionKey *AsymmetricEncryptedSecret `json:"encryptionKey,omitempty"`

	// READ-ONLY; The flag to denote whether encryption is enabled or not.
	EncryptionStatus *EncryptionStatus `json:"encryptionStatus,omitempty" azure:"ro"`

	// READ-ONLY; The owner ship status of the volume container. Only when the status is "NotOwned", the delete operation on the volume container is permitted.
	OwnerShipStatus *OwnerShipStatus `json:"ownerShipStatus,omitempty" azure:"ro"`

	// READ-ONLY; The total cloud storage for the volume container.
	TotalCloudStorageUsageInBytes *int64 `json:"totalCloudStorageUsageInBytes,omitempty" azure:"ro"`

	// READ-ONLY; The number of volumes in the volume Container.
	VolumeCount *int32 `json:"volumeCount,omitempty" azure:"ro"`
}

// VolumeContainersBeginCreateOrUpdateOptions contains the optional parameters for the VolumeContainers.BeginCreateOrUpdate method.
type VolumeContainersBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// VolumeContainersBeginDeleteOptions contains the optional parameters for the VolumeContainers.BeginDelete method.
type VolumeContainersBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// VolumeContainersGetOptions contains the optional parameters for the VolumeContainers.Get method.
type VolumeContainersGetOptions struct {
	// placeholder for future optional parameters
}

// VolumeContainersListByDeviceOptions contains the optional parameters for the VolumeContainers.ListByDevice method.
type VolumeContainersListByDeviceOptions struct {
	// placeholder for future optional parameters
}

// VolumeContainersListMetricDefinitionOptions contains the optional parameters for the VolumeContainers.ListMetricDefinition method.
type VolumeContainersListMetricDefinitionOptions struct {
	// placeholder for future optional parameters
}

// VolumeContainersListMetricsOptions contains the optional parameters for the VolumeContainers.ListMetrics method.
type VolumeContainersListMetricsOptions struct {
	// placeholder for future optional parameters
}

// VolumeFailoverMetadata - The metadata of a volume that has valid cloud snapshot.
type VolumeFailoverMetadata struct {
	// The date at which the snapshot was taken.
	BackupCreatedDate *time.Time `json:"backupCreatedDate,omitempty"`

	// The path ID of the backup-element for this volume, inside the backup set.
	BackupElementID *string `json:"backupElementId,omitempty"`

	// The path ID of the backup set.
	BackupID *string `json:"backupId,omitempty"`

	// The path ID of the backup policy using which the snapshot was taken.
	BackupPolicyID *string `json:"backupPolicyId,omitempty"`

	// The size of the volume in bytes at the time the snapshot was taken.
	SizeInBytes *int64 `json:"sizeInBytes,omitempty"`

	// The path ID of the volume.
	VolumeID *string `json:"volumeId,omitempty"`

	// The type of the volume.
	VolumeType *VolumeType `json:"volumeType,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VolumeFailoverMetadata.
func (v VolumeFailoverMetadata) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "backupCreatedDate", (*timeRFC3339)(v.BackupCreatedDate))
	populate(objectMap, "backupElementId", v.BackupElementID)
	populate(objectMap, "backupId", v.BackupID)
	populate(objectMap, "backupPolicyId", v.BackupPolicyID)
	populate(objectMap, "sizeInBytes", v.SizeInBytes)
	populate(objectMap, "volumeId", v.VolumeID)
	populate(objectMap, "volumeType", v.VolumeType)
	return json.Marshal(objectMap)
}

// UnmarshalJSON implements the json.Unmarshaller interface for type VolumeFailoverMetadata.
func (v *VolumeFailoverMetadata) UnmarshalJSON(data []byte) error {
	var rawMsg map[string]json.RawMessage
	if err := json.Unmarshal(data, &rawMsg); err != nil {
		return err
	}
	for key, val := range rawMsg {
		var err error
		switch key {
		case "backupCreatedDate":
			var aux timeRFC3339
			err = unpopulate(val, &aux)
			v.BackupCreatedDate = (*time.Time)(&aux)
			delete(rawMsg, key)
		case "backupElementId":
			err = unpopulate(val, &v.BackupElementID)
			delete(rawMsg, key)
		case "backupId":
			err = unpopulate(val, &v.BackupID)
			delete(rawMsg, key)
		case "backupPolicyId":
			err = unpopulate(val, &v.BackupPolicyID)
			delete(rawMsg, key)
		case "sizeInBytes":
			err = unpopulate(val, &v.SizeInBytes)
			delete(rawMsg, key)
		case "volumeId":
			err = unpopulate(val, &v.VolumeID)
			delete(rawMsg, key)
		case "volumeType":
			err = unpopulate(val, &v.VolumeType)
			delete(rawMsg, key)
		}
		if err != nil {
			return err
		}
	}
	return nil
}

// VolumeList - The collection of volumes.
type VolumeList struct {
	// REQUIRED; The value.
	Value []*Volume `json:"value,omitempty"`
}

// MarshalJSON implements the json.Marshaller interface for type VolumeList.
func (v VolumeList) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "value", v.Value)
	return json.Marshal(objectMap)
}

// VolumeProperties - The properties of volume.
type VolumeProperties struct {
	// REQUIRED; The IDs of the access control records, associated with the volume.
	AccessControlRecordIDs []*string `json:"accessControlRecordIds,omitempty"`

	// REQUIRED; The monitoring status of the volume.
	MonitoringStatus *MonitoringStatus `json:"monitoringStatus,omitempty"`

	// REQUIRED; The size of the volume in bytes.
	SizeInBytes *int64 `json:"sizeInBytes,omitempty"`

	// REQUIRED; The volume status.
	VolumeStatus *VolumeStatus `json:"volumeStatus,omitempty"`

	// REQUIRED; The type of the volume.
	VolumeType *VolumeType `json:"volumeType,omitempty"`

	// READ-ONLY; The IDs of the backup policies, in which this volume is part of.
	BackupPolicyIDs []*string `json:"backupPolicyIds,omitempty" azure:"ro"`

	// READ-ONLY; The backup status of the volume.
	BackupStatus *BackupStatus `json:"backupStatus,omitempty" azure:"ro"`

	// READ-ONLY; The operation status on the volume.
	OperationStatus *OperationStatus `json:"operationStatus,omitempty" azure:"ro"`

	// READ-ONLY; The ID of the volume container, in which this volume is created.
	VolumeContainerID *string `json:"volumeContainerId,omitempty" azure:"ro"`
}

// MarshalJSON implements the json.Marshaller interface for type VolumeProperties.
func (v VolumeProperties) MarshalJSON() ([]byte, error) {
	objectMap := make(map[string]interface{})
	populate(objectMap, "accessControlRecordIds", v.AccessControlRecordIDs)
	populate(objectMap, "backupPolicyIds", v.BackupPolicyIDs)
	populate(objectMap, "backupStatus", v.BackupStatus)
	populate(objectMap, "monitoringStatus", v.MonitoringStatus)
	populate(objectMap, "operationStatus", v.OperationStatus)
	populate(objectMap, "sizeInBytes", v.SizeInBytes)
	populate(objectMap, "volumeContainerId", v.VolumeContainerID)
	populate(objectMap, "volumeStatus", v.VolumeStatus)
	populate(objectMap, "volumeType", v.VolumeType)
	return json.Marshal(objectMap)
}

// VolumesBeginCreateOrUpdateOptions contains the optional parameters for the Volumes.BeginCreateOrUpdate method.
type VolumesBeginCreateOrUpdateOptions struct {
	// placeholder for future optional parameters
}

// VolumesBeginDeleteOptions contains the optional parameters for the Volumes.BeginDelete method.
type VolumesBeginDeleteOptions struct {
	// placeholder for future optional parameters
}

// VolumesGetOptions contains the optional parameters for the Volumes.Get method.
type VolumesGetOptions struct {
	// placeholder for future optional parameters
}

// VolumesListByDeviceOptions contains the optional parameters for the Volumes.ListByDevice method.
type VolumesListByDeviceOptions struct {
	// placeholder for future optional parameters
}

// VolumesListByVolumeContainerOptions contains the optional parameters for the Volumes.ListByVolumeContainer method.
type VolumesListByVolumeContainerOptions struct {
	// placeholder for future optional parameters
}

// VolumesListMetricDefinitionOptions contains the optional parameters for the Volumes.ListMetricDefinition method.
type VolumesListMetricDefinitionOptions struct {
	// placeholder for future optional parameters
}

// VolumesListMetricsOptions contains the optional parameters for the Volumes.ListMetrics method.
type VolumesListMetricsOptions struct {
	// placeholder for future optional parameters
}

// WebproxySettings - The web proxy settings on the device.
type WebproxySettings struct {
	// REQUIRED; The authentication type.
	Authentication *AuthenticationType `json:"authentication,omitempty"`

	// REQUIRED; The webproxy username.
	Username *string `json:"username,omitempty"`

	// The connection URI.
	ConnectionURI *string `json:"connectionUri,omitempty"`
}

func populate(m map[string]interface{}, k string, v interface{}) {
	if v == nil {
		return
	} else if azcore.IsNullValue(v) {
		m[k] = nil
	} else if !reflect.ValueOf(v).IsNil() {
		m[k] = v
	}
}

func unpopulate(data json.RawMessage, v interface{}) error {
	if data == nil {
		return nil
	}
	return json.Unmarshal(data, v)
}
