//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armstorsimple8000series

import (
	"context"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"strings"
)

// DevicesClient contains the methods for the Devices group.
// Don't use this type directly, use NewDevicesClient() instead.
type DevicesClient struct {
	host           string
	subscriptionID string
	pl             runtime.Pipeline
}

// NewDevicesClient creates a new instance of DevicesClient with the specified values.
// subscriptionID - The subscription id
// credential - used to authorize requests. Usually a credential from azidentity.
// options - pass nil to accept the default values.
func NewDevicesClient(subscriptionID string, credential azcore.TokenCredential, options *arm.ClientOptions) *DevicesClient {
	if options == nil {
		options = &arm.ClientOptions{}
	}
	ep := options.Endpoint
	if len(ep) == 0 {
		ep = arm.AzurePublicCloud
	}
	client := &DevicesClient{
		subscriptionID: subscriptionID,
		host:           string(ep),
		pl:             armruntime.NewPipeline(moduleName, moduleVersion, credential, runtime.PipelineOptions{}, options),
	}
	return client
}

// AuthorizeForServiceEncryptionKeyRollover - Authorizes the specified device for service data encryption key rollover.
// If the operation fails it returns an *azcore.ResponseError type.
// deviceName - The device name
// resourceGroupName - The resource group name
// managerName - The manager name
// options - DevicesClientAuthorizeForServiceEncryptionKeyRolloverOptions contains the optional parameters for the DevicesClient.AuthorizeForServiceEncryptionKeyRollover
// method.
func (client *DevicesClient) AuthorizeForServiceEncryptionKeyRollover(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesClientAuthorizeForServiceEncryptionKeyRolloverOptions) (DevicesClientAuthorizeForServiceEncryptionKeyRolloverResponse, error) {
	req, err := client.authorizeForServiceEncryptionKeyRolloverCreateRequest(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return DevicesClientAuthorizeForServiceEncryptionKeyRolloverResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DevicesClientAuthorizeForServiceEncryptionKeyRolloverResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return DevicesClientAuthorizeForServiceEncryptionKeyRolloverResponse{}, runtime.NewResponseError(resp)
	}
	return DevicesClientAuthorizeForServiceEncryptionKeyRolloverResponse{}, nil
}

// authorizeForServiceEncryptionKeyRolloverCreateRequest creates the AuthorizeForServiceEncryptionKeyRollover request.
func (client *DevicesClient) authorizeForServiceEncryptionKeyRolloverCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesClientAuthorizeForServiceEncryptionKeyRolloverOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}/authorizeForServiceEncryptionKeyRollover"
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// BeginConfigure - Complete minimal setup before using the device.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - The resource group name
// managerName - The manager name
// parameters - The minimal properties to configure a device.
// options - DevicesClientBeginConfigureOptions contains the optional parameters for the DevicesClient.BeginConfigure method.
func (client *DevicesClient) BeginConfigure(ctx context.Context, resourceGroupName string, managerName string, parameters ConfigureDeviceRequest, options *DevicesClientBeginConfigureOptions) (DevicesClientConfigurePollerResponse, error) {
	resp, err := client.configure(ctx, resourceGroupName, managerName, parameters, options)
	if err != nil {
		return DevicesClientConfigurePollerResponse{}, err
	}
	result := DevicesClientConfigurePollerResponse{}
	pt, err := armruntime.NewPoller("DevicesClient.Configure", "", resp, client.pl)
	if err != nil {
		return DevicesClientConfigurePollerResponse{}, err
	}
	result.Poller = &DevicesClientConfigurePoller{
		pt: pt,
	}
	return result, nil
}

// Configure - Complete minimal setup before using the device.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *DevicesClient) configure(ctx context.Context, resourceGroupName string, managerName string, parameters ConfigureDeviceRequest, options *DevicesClientBeginConfigureOptions) (*http.Response, error) {
	req, err := client.configureCreateRequest(ctx, resourceGroupName, managerName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// configureCreateRequest creates the Configure request.
func (client *DevicesClient) configureCreateRequest(ctx context.Context, resourceGroupName string, managerName string, parameters ConfigureDeviceRequest, options *DevicesClientBeginConfigureOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/configureDevice"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, runtime.MarshalAsJSON(req, parameters)
}

// BeginDeactivate - Deactivates the device.
// If the operation fails it returns an *azcore.ResponseError type.
// deviceName - The device name
// resourceGroupName - The resource group name
// managerName - The manager name
// options - DevicesClientBeginDeactivateOptions contains the optional parameters for the DevicesClient.BeginDeactivate method.
func (client *DevicesClient) BeginDeactivate(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesClientBeginDeactivateOptions) (DevicesClientDeactivatePollerResponse, error) {
	resp, err := client.deactivate(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return DevicesClientDeactivatePollerResponse{}, err
	}
	result := DevicesClientDeactivatePollerResponse{}
	pt, err := armruntime.NewPoller("DevicesClient.Deactivate", "", resp, client.pl)
	if err != nil {
		return DevicesClientDeactivatePollerResponse{}, err
	}
	result.Poller = &DevicesClientDeactivatePoller{
		pt: pt,
	}
	return result, nil
}

// Deactivate - Deactivates the device.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *DevicesClient) deactivate(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesClientBeginDeactivateOptions) (*http.Response, error) {
	req, err := client.deactivateCreateRequest(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deactivateCreateRequest creates the Deactivate request.
func (client *DevicesClient) deactivateCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesClientBeginDeactivateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}/deactivate"
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// BeginDelete - Deletes the device.
// If the operation fails it returns an *azcore.ResponseError type.
// deviceName - The device name
// resourceGroupName - The resource group name
// managerName - The manager name
// options - DevicesClientBeginDeleteOptions contains the optional parameters for the DevicesClient.BeginDelete method.
func (client *DevicesClient) BeginDelete(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesClientBeginDeleteOptions) (DevicesClientDeletePollerResponse, error) {
	resp, err := client.deleteOperation(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return DevicesClientDeletePollerResponse{}, err
	}
	result := DevicesClientDeletePollerResponse{}
	pt, err := armruntime.NewPoller("DevicesClient.Delete", "", resp, client.pl)
	if err != nil {
		return DevicesClientDeletePollerResponse{}, err
	}
	result.Poller = &DevicesClientDeletePoller{
		pt: pt,
	}
	return result, nil
}

// Delete - Deletes the device.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *DevicesClient) deleteOperation(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesClientBeginDeleteOptions) (*http.Response, error) {
	req, err := client.deleteCreateRequest(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// deleteCreateRequest creates the Delete request.
func (client *DevicesClient) deleteCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesClientBeginDeleteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}"
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// BeginFailover - Failovers a set of volume containers from a specified source device to a target device.
// If the operation fails it returns an *azcore.ResponseError type.
// sourceDeviceName - The source device name on which failover is performed.
// resourceGroupName - The resource group name
// managerName - The manager name
// parameters - FailoverRequest containing the source device and the list of volume containers to be failed over.
// options - DevicesClientBeginFailoverOptions contains the optional parameters for the DevicesClient.BeginFailover method.
func (client *DevicesClient) BeginFailover(ctx context.Context, sourceDeviceName string, resourceGroupName string, managerName string, parameters FailoverRequest, options *DevicesClientBeginFailoverOptions) (DevicesClientFailoverPollerResponse, error) {
	resp, err := client.failover(ctx, sourceDeviceName, resourceGroupName, managerName, parameters, options)
	if err != nil {
		return DevicesClientFailoverPollerResponse{}, err
	}
	result := DevicesClientFailoverPollerResponse{}
	pt, err := armruntime.NewPoller("DevicesClient.Failover", "", resp, client.pl)
	if err != nil {
		return DevicesClientFailoverPollerResponse{}, err
	}
	result.Poller = &DevicesClientFailoverPoller{
		pt: pt,
	}
	return result, nil
}

// Failover - Failovers a set of volume containers from a specified source device to a target device.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *DevicesClient) failover(ctx context.Context, sourceDeviceName string, resourceGroupName string, managerName string, parameters FailoverRequest, options *DevicesClientBeginFailoverOptions) (*http.Response, error) {
	req, err := client.failoverCreateRequest(ctx, sourceDeviceName, resourceGroupName, managerName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// failoverCreateRequest creates the Failover request.
func (client *DevicesClient) failoverCreateRequest(ctx context.Context, sourceDeviceName string, resourceGroupName string, managerName string, parameters FailoverRequest, options *DevicesClientBeginFailoverOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{sourceDeviceName}/failover"
	urlPath = strings.ReplaceAll(urlPath, "{sourceDeviceName}", sourceDeviceName)
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, runtime.MarshalAsJSON(req, parameters)
}

// Get - Returns the properties of the specified device.
// If the operation fails it returns an *azcore.ResponseError type.
// deviceName - The device name
// resourceGroupName - The resource group name
// managerName - The manager name
// options - DevicesClientGetOptions contains the optional parameters for the DevicesClient.Get method.
func (client *DevicesClient) Get(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesClientGetOptions) (DevicesClientGetResponse, error) {
	req, err := client.getCreateRequest(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return DevicesClientGetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DevicesClientGetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DevicesClientGetResponse{}, runtime.NewResponseError(resp)
	}
	return client.getHandleResponse(resp)
}

// getCreateRequest creates the Get request.
func (client *DevicesClient) getCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesClientGetOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}"
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", *options.Expand)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *DevicesClient) getHandleResponse(resp *http.Response) (DevicesClientGetResponse, error) {
	result := DevicesClientGetResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Device); err != nil {
		return DevicesClientGetResponse{}, err
	}
	return result, nil
}

// GetUpdateSummary - Returns the update summary of the specified device name.
// If the operation fails it returns an *azcore.ResponseError type.
// deviceName - The device name
// resourceGroupName - The resource group name
// managerName - The manager name
// options - DevicesClientGetUpdateSummaryOptions contains the optional parameters for the DevicesClient.GetUpdateSummary
// method.
func (client *DevicesClient) GetUpdateSummary(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesClientGetUpdateSummaryOptions) (DevicesClientGetUpdateSummaryResponse, error) {
	req, err := client.getUpdateSummaryCreateRequest(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return DevicesClientGetUpdateSummaryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DevicesClientGetUpdateSummaryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DevicesClientGetUpdateSummaryResponse{}, runtime.NewResponseError(resp)
	}
	return client.getUpdateSummaryHandleResponse(resp)
}

// getUpdateSummaryCreateRequest creates the GetUpdateSummary request.
func (client *DevicesClient) getUpdateSummaryCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesClientGetUpdateSummaryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}/updateSummary/default"
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getUpdateSummaryHandleResponse handles the GetUpdateSummary response.
func (client *DevicesClient) getUpdateSummaryHandleResponse(resp *http.Response) (DevicesClientGetUpdateSummaryResponse, error) {
	result := DevicesClientGetUpdateSummaryResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Updates); err != nil {
		return DevicesClientGetUpdateSummaryResponse{}, err
	}
	return result, nil
}

// BeginInstallUpdates - Downloads and installs the updates on the device.
// If the operation fails it returns an *azcore.ResponseError type.
// deviceName - The device name
// resourceGroupName - The resource group name
// managerName - The manager name
// options - DevicesClientBeginInstallUpdatesOptions contains the optional parameters for the DevicesClient.BeginInstallUpdates
// method.
func (client *DevicesClient) BeginInstallUpdates(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesClientBeginInstallUpdatesOptions) (DevicesClientInstallUpdatesPollerResponse, error) {
	resp, err := client.installUpdates(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return DevicesClientInstallUpdatesPollerResponse{}, err
	}
	result := DevicesClientInstallUpdatesPollerResponse{}
	pt, err := armruntime.NewPoller("DevicesClient.InstallUpdates", "", resp, client.pl)
	if err != nil {
		return DevicesClientInstallUpdatesPollerResponse{}, err
	}
	result.Poller = &DevicesClientInstallUpdatesPoller{
		pt: pt,
	}
	return result, nil
}

// InstallUpdates - Downloads and installs the updates on the device.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *DevicesClient) installUpdates(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesClientBeginInstallUpdatesOptions) (*http.Response, error) {
	req, err := client.installUpdatesCreateRequest(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// installUpdatesCreateRequest creates the InstallUpdates request.
func (client *DevicesClient) installUpdatesCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesClientBeginInstallUpdatesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}/installUpdates"
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// ListByManager - Returns the list of devices for the specified manager.
// If the operation fails it returns an *azcore.ResponseError type.
// resourceGroupName - The resource group name
// managerName - The manager name
// options - DevicesClientListByManagerOptions contains the optional parameters for the DevicesClient.ListByManager method.
func (client *DevicesClient) ListByManager(resourceGroupName string, managerName string, options *DevicesClientListByManagerOptions) *DevicesClientListByManagerPager {
	return &DevicesClientListByManagerPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listByManagerCreateRequest(ctx, resourceGroupName, managerName, options)
		},
	}
}

// listByManagerCreateRequest creates the ListByManager request.
func (client *DevicesClient) listByManagerCreateRequest(ctx context.Context, resourceGroupName string, managerName string, options *DevicesClientListByManagerOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices"
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", *options.Expand)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listByManagerHandleResponse handles the ListByManager response.
func (client *DevicesClient) listByManagerHandleResponse(resp *http.Response) (DevicesClientListByManagerResponse, error) {
	result := DevicesClientListByManagerResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeviceList); err != nil {
		return DevicesClientListByManagerResponse{}, err
	}
	return result, nil
}

// ListFailoverSets - Returns all failover sets for a given device and their eligibility for participating in a failover.
// A failover set refers to a set of volume containers that need to be failed-over as a single unit to
// maintain data integrity.
// If the operation fails it returns an *azcore.ResponseError type.
// deviceName - The device name
// resourceGroupName - The resource group name
// managerName - The manager name
// options - DevicesClientListFailoverSetsOptions contains the optional parameters for the DevicesClient.ListFailoverSets
// method.
func (client *DevicesClient) ListFailoverSets(deviceName string, resourceGroupName string, managerName string, options *DevicesClientListFailoverSetsOptions) *DevicesClientListFailoverSetsPager {
	return &DevicesClientListFailoverSetsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listFailoverSetsCreateRequest(ctx, deviceName, resourceGroupName, managerName, options)
		},
	}
}

// listFailoverSetsCreateRequest creates the ListFailoverSets request.
func (client *DevicesClient) listFailoverSetsCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesClientListFailoverSetsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}/listFailoverSets"
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listFailoverSetsHandleResponse handles the ListFailoverSets response.
func (client *DevicesClient) listFailoverSetsHandleResponse(resp *http.Response) (DevicesClientListFailoverSetsResponse, error) {
	result := DevicesClientListFailoverSetsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FailoverSetsList); err != nil {
		return DevicesClientListFailoverSetsResponse{}, err
	}
	return result, nil
}

// ListFailoverTargets - Given a list of volume containers to be failed over from a source device, this method returns the
// eligibility result, as a failover target, for all devices under that resource.
// If the operation fails it returns an *azcore.ResponseError type.
// sourceDeviceName - The source device name on which failover is performed.
// resourceGroupName - The resource group name
// managerName - The manager name
// parameters - ListFailoverTargetsRequest containing the list of volume containers to be failed over.
// options - DevicesClientListFailoverTargetsOptions contains the optional parameters for the DevicesClient.ListFailoverTargets
// method.
func (client *DevicesClient) ListFailoverTargets(sourceDeviceName string, resourceGroupName string, managerName string, parameters ListFailoverTargetsRequest, options *DevicesClientListFailoverTargetsOptions) *DevicesClientListFailoverTargetsPager {
	return &DevicesClientListFailoverTargetsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listFailoverTargetsCreateRequest(ctx, sourceDeviceName, resourceGroupName, managerName, parameters, options)
		},
	}
}

// listFailoverTargetsCreateRequest creates the ListFailoverTargets request.
func (client *DevicesClient) listFailoverTargetsCreateRequest(ctx context.Context, sourceDeviceName string, resourceGroupName string, managerName string, parameters ListFailoverTargetsRequest, options *DevicesClientListFailoverTargetsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{sourceDeviceName}/listFailoverTargets"
	urlPath = strings.ReplaceAll(urlPath, "{sourceDeviceName}", sourceDeviceName)
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// listFailoverTargetsHandleResponse handles the ListFailoverTargets response.
func (client *DevicesClient) listFailoverTargetsHandleResponse(resp *http.Response) (DevicesClientListFailoverTargetsResponse, error) {
	result := DevicesClientListFailoverTargetsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.FailoverTargetsList); err != nil {
		return DevicesClientListFailoverTargetsResponse{}, err
	}
	return result, nil
}

// ListMetricDefinition - Gets the metric definitions for the specified device.
// If the operation fails it returns an *azcore.ResponseError type.
// deviceName - The device name
// resourceGroupName - The resource group name
// managerName - The manager name
// options - DevicesClientListMetricDefinitionOptions contains the optional parameters for the DevicesClient.ListMetricDefinition
// method.
func (client *DevicesClient) ListMetricDefinition(deviceName string, resourceGroupName string, managerName string, options *DevicesClientListMetricDefinitionOptions) *DevicesClientListMetricDefinitionPager {
	return &DevicesClientListMetricDefinitionPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listMetricDefinitionCreateRequest(ctx, deviceName, resourceGroupName, managerName, options)
		},
	}
}

// listMetricDefinitionCreateRequest creates the ListMetricDefinition request.
func (client *DevicesClient) listMetricDefinitionCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesClientListMetricDefinitionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}/metricsDefinitions"
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listMetricDefinitionHandleResponse handles the ListMetricDefinition response.
func (client *DevicesClient) listMetricDefinitionHandleResponse(resp *http.Response) (DevicesClientListMetricDefinitionResponse, error) {
	result := DevicesClientListMetricDefinitionResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MetricDefinitionList); err != nil {
		return DevicesClientListMetricDefinitionResponse{}, err
	}
	return result, nil
}

// ListMetrics - Gets the metrics for the specified device.
// If the operation fails it returns an *azcore.ResponseError type.
// deviceName - The device name
// resourceGroupName - The resource group name
// managerName - The manager name
// filter - OData Filter options
// options - DevicesClientListMetricsOptions contains the optional parameters for the DevicesClient.ListMetrics method.
func (client *DevicesClient) ListMetrics(deviceName string, resourceGroupName string, managerName string, filter string, options *DevicesClientListMetricsOptions) *DevicesClientListMetricsPager {
	return &DevicesClientListMetricsPager{
		client: client,
		requester: func(ctx context.Context) (*policy.Request, error) {
			return client.listMetricsCreateRequest(ctx, deviceName, resourceGroupName, managerName, filter, options)
		},
	}
}

// listMetricsCreateRequest creates the ListMetrics request.
func (client *DevicesClient) listMetricsCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, filter string, options *DevicesClientListMetricsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}/metrics"
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	reqQP.Set("$filter", filter)
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listMetricsHandleResponse handles the ListMetrics response.
func (client *DevicesClient) listMetricsHandleResponse(resp *http.Response) (DevicesClientListMetricsResponse, error) {
	result := DevicesClientListMetricsResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.MetricList); err != nil {
		return DevicesClientListMetricsResponse{}, err
	}
	return result, nil
}

// BeginScanForUpdates - Scans for updates on the device.
// If the operation fails it returns an *azcore.ResponseError type.
// deviceName - The device name
// resourceGroupName - The resource group name
// managerName - The manager name
// options - DevicesClientBeginScanForUpdatesOptions contains the optional parameters for the DevicesClient.BeginScanForUpdates
// method.
func (client *DevicesClient) BeginScanForUpdates(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesClientBeginScanForUpdatesOptions) (DevicesClientScanForUpdatesPollerResponse, error) {
	resp, err := client.scanForUpdates(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return DevicesClientScanForUpdatesPollerResponse{}, err
	}
	result := DevicesClientScanForUpdatesPollerResponse{}
	pt, err := armruntime.NewPoller("DevicesClient.ScanForUpdates", "", resp, client.pl)
	if err != nil {
		return DevicesClientScanForUpdatesPollerResponse{}, err
	}
	result.Poller = &DevicesClientScanForUpdatesPoller{
		pt: pt,
	}
	return result, nil
}

// ScanForUpdates - Scans for updates on the device.
// If the operation fails it returns an *azcore.ResponseError type.
func (client *DevicesClient) scanForUpdates(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesClientBeginScanForUpdatesOptions) (*http.Response, error) {
	req, err := client.scanForUpdatesCreateRequest(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent) {
		return nil, runtime.NewResponseError(resp)
	}
	return resp, nil
}

// scanForUpdatesCreateRequest creates the ScanForUpdates request.
func (client *DevicesClient) scanForUpdatesCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesClientBeginScanForUpdatesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}/scanForUpdates"
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// Update - Patches the device.
// If the operation fails it returns an *azcore.ResponseError type.
// deviceName - The device name
// resourceGroupName - The resource group name
// managerName - The manager name
// parameters - Patch representation of the device.
// options - DevicesClientUpdateOptions contains the optional parameters for the DevicesClient.Update method.
func (client *DevicesClient) Update(ctx context.Context, deviceName string, resourceGroupName string, managerName string, parameters DevicePatch, options *DevicesClientUpdateOptions) (DevicesClientUpdateResponse, error) {
	req, err := client.updateCreateRequest(ctx, deviceName, resourceGroupName, managerName, parameters, options)
	if err != nil {
		return DevicesClientUpdateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DevicesClientUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DevicesClientUpdateResponse{}, runtime.NewResponseError(resp)
	}
	return client.updateHandleResponse(resp)
}

// updateCreateRequest creates the Update request.
func (client *DevicesClient) updateCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, parameters DevicePatch, options *DevicesClientUpdateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}"
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.host, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// updateHandleResponse handles the Update response.
func (client *DevicesClient) updateHandleResponse(resp *http.Response) (DevicesClientUpdateResponse, error) {
	result := DevicesClientUpdateResponse{}
	if err := runtime.UnmarshalAsJSON(resp, &result.Device); err != nil {
		return DevicesClientUpdateResponse{}, err
	}
	return result, nil
}
