//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armstorsimple8000series

import (
	"context"
	"errors"
	"net/http"
	"strings"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	armruntime "github.com/Azure/azure-sdk-for-go/sdk/azcore/arm/runtime"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
)

// DevicesClient contains the methods for the Devices group.
// Don't use this type directly, use NewDevicesClient() instead.
type DevicesClient struct {
	ep             string
	pl             runtime.Pipeline
	subscriptionID string
}

// NewDevicesClient creates a new instance of DevicesClient with the specified values.
func NewDevicesClient(con *arm.Connection, subscriptionID string) *DevicesClient {
	return &DevicesClient{ep: con.Endpoint(), pl: con.NewPipeline(module, version), subscriptionID: subscriptionID}
}

// AuthorizeForServiceEncryptionKeyRollover - Authorizes the specified device for service data encryption key rollover.
// If the operation fails it returns a generic error.
func (client *DevicesClient) AuthorizeForServiceEncryptionKeyRollover(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesAuthorizeForServiceEncryptionKeyRolloverOptions) (DevicesAuthorizeForServiceEncryptionKeyRolloverResponse, error) {
	req, err := client.authorizeForServiceEncryptionKeyRolloverCreateRequest(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return DevicesAuthorizeForServiceEncryptionKeyRolloverResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DevicesAuthorizeForServiceEncryptionKeyRolloverResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusNoContent) {
		return DevicesAuthorizeForServiceEncryptionKeyRolloverResponse{}, client.authorizeForServiceEncryptionKeyRolloverHandleError(resp)
	}
	return DevicesAuthorizeForServiceEncryptionKeyRolloverResponse{RawResponse: resp}, nil
}

// authorizeForServiceEncryptionKeyRolloverCreateRequest creates the AuthorizeForServiceEncryptionKeyRollover request.
func (client *DevicesClient) authorizeForServiceEncryptionKeyRolloverCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesAuthorizeForServiceEncryptionKeyRolloverOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}/authorizeForServiceEncryptionKeyRollover"
	if deviceName == "" {
		return nil, errors.New("parameter deviceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// authorizeForServiceEncryptionKeyRolloverHandleError handles the AuthorizeForServiceEncryptionKeyRollover error response.
func (client *DevicesClient) authorizeForServiceEncryptionKeyRolloverHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// BeginConfigure - Complete minimal setup before using the device.
// If the operation fails it returns a generic error.
func (client *DevicesClient) BeginConfigure(ctx context.Context, resourceGroupName string, managerName string, parameters ConfigureDeviceRequest, options *DevicesBeginConfigureOptions) (DevicesConfigurePollerResponse, error) {
	resp, err := client.configure(ctx, resourceGroupName, managerName, parameters, options)
	if err != nil {
		return DevicesConfigurePollerResponse{}, err
	}
	result := DevicesConfigurePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("DevicesClient.Configure", "", resp, client.pl, client.configureHandleError)
	if err != nil {
		return DevicesConfigurePollerResponse{}, err
	}
	result.Poller = &DevicesConfigurePoller{
		pt: pt,
	}
	return result, nil
}

// Configure - Complete minimal setup before using the device.
// If the operation fails it returns a generic error.
func (client *DevicesClient) configure(ctx context.Context, resourceGroupName string, managerName string, parameters ConfigureDeviceRequest, options *DevicesBeginConfigureOptions) (*http.Response, error) {
	req, err := client.configureCreateRequest(ctx, resourceGroupName, managerName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.configureHandleError(resp)
	}
	return resp, nil
}

// configureCreateRequest creates the Configure request.
func (client *DevicesClient) configureCreateRequest(ctx context.Context, resourceGroupName string, managerName string, parameters ConfigureDeviceRequest, options *DevicesBeginConfigureOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/configureDevice"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, runtime.MarshalAsJSON(req, parameters)
}

// configureHandleError handles the Configure error response.
func (client *DevicesClient) configureHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// BeginDeactivate - Deactivates the device.
// If the operation fails it returns a generic error.
func (client *DevicesClient) BeginDeactivate(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesBeginDeactivateOptions) (DevicesDeactivatePollerResponse, error) {
	resp, err := client.deactivate(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return DevicesDeactivatePollerResponse{}, err
	}
	result := DevicesDeactivatePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("DevicesClient.Deactivate", "", resp, client.pl, client.deactivateHandleError)
	if err != nil {
		return DevicesDeactivatePollerResponse{}, err
	}
	result.Poller = &DevicesDeactivatePoller{
		pt: pt,
	}
	return result, nil
}

// Deactivate - Deactivates the device.
// If the operation fails it returns a generic error.
func (client *DevicesClient) deactivate(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesBeginDeactivateOptions) (*http.Response, error) {
	req, err := client.deactivateCreateRequest(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deactivateHandleError(resp)
	}
	return resp, nil
}

// deactivateCreateRequest creates the Deactivate request.
func (client *DevicesClient) deactivateCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesBeginDeactivateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}/deactivate"
	if deviceName == "" {
		return nil, errors.New("parameter deviceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// deactivateHandleError handles the Deactivate error response.
func (client *DevicesClient) deactivateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// BeginDelete - Deletes the device.
// If the operation fails it returns a generic error.
func (client *DevicesClient) BeginDelete(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesBeginDeleteOptions) (DevicesDeletePollerResponse, error) {
	resp, err := client.deleteOperation(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return DevicesDeletePollerResponse{}, err
	}
	result := DevicesDeletePollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("DevicesClient.Delete", "", resp, client.pl, client.deleteHandleError)
	if err != nil {
		return DevicesDeletePollerResponse{}, err
	}
	result.Poller = &DevicesDeletePoller{
		pt: pt,
	}
	return result, nil
}

// Delete - Deletes the device.
// If the operation fails it returns a generic error.
func (client *DevicesClient) deleteOperation(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesBeginDeleteOptions) (*http.Response, error) {
	req, err := client.deleteCreateRequest(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.deleteHandleError(resp)
	}
	return resp, nil
}

// deleteCreateRequest creates the Delete request.
func (client *DevicesClient) deleteCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesBeginDeleteOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}"
	if deviceName == "" {
		return nil, errors.New("parameter deviceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodDelete, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// deleteHandleError handles the Delete error response.
func (client *DevicesClient) deleteHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// BeginFailover - Failovers a set of volume containers from a specified source device to a target device.
// If the operation fails it returns a generic error.
func (client *DevicesClient) BeginFailover(ctx context.Context, sourceDeviceName string, resourceGroupName string, managerName string, parameters FailoverRequest, options *DevicesBeginFailoverOptions) (DevicesFailoverPollerResponse, error) {
	resp, err := client.failover(ctx, sourceDeviceName, resourceGroupName, managerName, parameters, options)
	if err != nil {
		return DevicesFailoverPollerResponse{}, err
	}
	result := DevicesFailoverPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("DevicesClient.Failover", "", resp, client.pl, client.failoverHandleError)
	if err != nil {
		return DevicesFailoverPollerResponse{}, err
	}
	result.Poller = &DevicesFailoverPoller{
		pt: pt,
	}
	return result, nil
}

// Failover - Failovers a set of volume containers from a specified source device to a target device.
// If the operation fails it returns a generic error.
func (client *DevicesClient) failover(ctx context.Context, sourceDeviceName string, resourceGroupName string, managerName string, parameters FailoverRequest, options *DevicesBeginFailoverOptions) (*http.Response, error) {
	req, err := client.failoverCreateRequest(ctx, sourceDeviceName, resourceGroupName, managerName, parameters, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.failoverHandleError(resp)
	}
	return resp, nil
}

// failoverCreateRequest creates the Failover request.
func (client *DevicesClient) failoverCreateRequest(ctx context.Context, sourceDeviceName string, resourceGroupName string, managerName string, parameters FailoverRequest, options *DevicesBeginFailoverOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{sourceDeviceName}/failover"
	if sourceDeviceName == "" {
		return nil, errors.New("parameter sourceDeviceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sourceDeviceName}", sourceDeviceName)
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, runtime.MarshalAsJSON(req, parameters)
}

// failoverHandleError handles the Failover error response.
func (client *DevicesClient) failoverHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// Get - Returns the properties of the specified device.
// If the operation fails it returns a generic error.
func (client *DevicesClient) Get(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesGetOptions) (DevicesGetResponse, error) {
	req, err := client.getCreateRequest(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return DevicesGetResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DevicesGetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DevicesGetResponse{}, client.getHandleError(resp)
	}
	return client.getHandleResponse(resp)
}

// getCreateRequest creates the Get request.
func (client *DevicesClient) getCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesGetOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}"
	if deviceName == "" {
		return nil, errors.New("parameter deviceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", *options.Expand)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getHandleResponse handles the Get response.
func (client *DevicesClient) getHandleResponse(resp *http.Response) (DevicesGetResponse, error) {
	result := DevicesGetResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Device); err != nil {
		return DevicesGetResponse{}, err
	}
	return result, nil
}

// getHandleError handles the Get error response.
func (client *DevicesClient) getHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// GetUpdateSummary - Returns the update summary of the specified device name.
// If the operation fails it returns a generic error.
func (client *DevicesClient) GetUpdateSummary(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesGetUpdateSummaryOptions) (DevicesGetUpdateSummaryResponse, error) {
	req, err := client.getUpdateSummaryCreateRequest(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return DevicesGetUpdateSummaryResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DevicesGetUpdateSummaryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DevicesGetUpdateSummaryResponse{}, client.getUpdateSummaryHandleError(resp)
	}
	return client.getUpdateSummaryHandleResponse(resp)
}

// getUpdateSummaryCreateRequest creates the GetUpdateSummary request.
func (client *DevicesClient) getUpdateSummaryCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesGetUpdateSummaryOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}/updateSummary/default"
	if deviceName == "" {
		return nil, errors.New("parameter deviceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// getUpdateSummaryHandleResponse handles the GetUpdateSummary response.
func (client *DevicesClient) getUpdateSummaryHandleResponse(resp *http.Response) (DevicesGetUpdateSummaryResponse, error) {
	result := DevicesGetUpdateSummaryResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Updates); err != nil {
		return DevicesGetUpdateSummaryResponse{}, err
	}
	return result, nil
}

// getUpdateSummaryHandleError handles the GetUpdateSummary error response.
func (client *DevicesClient) getUpdateSummaryHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// BeginInstallUpdates - Downloads and installs the updates on the device.
// If the operation fails it returns a generic error.
func (client *DevicesClient) BeginInstallUpdates(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesBeginInstallUpdatesOptions) (DevicesInstallUpdatesPollerResponse, error) {
	resp, err := client.installUpdates(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return DevicesInstallUpdatesPollerResponse{}, err
	}
	result := DevicesInstallUpdatesPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("DevicesClient.InstallUpdates", "", resp, client.pl, client.installUpdatesHandleError)
	if err != nil {
		return DevicesInstallUpdatesPollerResponse{}, err
	}
	result.Poller = &DevicesInstallUpdatesPoller{
		pt: pt,
	}
	return result, nil
}

// InstallUpdates - Downloads and installs the updates on the device.
// If the operation fails it returns a generic error.
func (client *DevicesClient) installUpdates(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesBeginInstallUpdatesOptions) (*http.Response, error) {
	req, err := client.installUpdatesCreateRequest(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.installUpdatesHandleError(resp)
	}
	return resp, nil
}

// installUpdatesCreateRequest creates the InstallUpdates request.
func (client *DevicesClient) installUpdatesCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesBeginInstallUpdatesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}/installUpdates"
	if deviceName == "" {
		return nil, errors.New("parameter deviceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// installUpdatesHandleError handles the InstallUpdates error response.
func (client *DevicesClient) installUpdatesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// ListByManager - Returns the list of devices for the specified manager.
// If the operation fails it returns a generic error.
func (client *DevicesClient) ListByManager(ctx context.Context, resourceGroupName string, managerName string, options *DevicesListByManagerOptions) (DevicesListByManagerResponse, error) {
	req, err := client.listByManagerCreateRequest(ctx, resourceGroupName, managerName, options)
	if err != nil {
		return DevicesListByManagerResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DevicesListByManagerResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DevicesListByManagerResponse{}, client.listByManagerHandleError(resp)
	}
	return client.listByManagerHandleResponse(resp)
}

// listByManagerCreateRequest creates the ListByManager request.
func (client *DevicesClient) listByManagerCreateRequest(ctx context.Context, resourceGroupName string, managerName string, options *DevicesListByManagerOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices"
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	if options != nil && options.Expand != nil {
		reqQP.Set("$expand", *options.Expand)
	}
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listByManagerHandleResponse handles the ListByManager response.
func (client *DevicesClient) listByManagerHandleResponse(resp *http.Response) (DevicesListByManagerResponse, error) {
	result := DevicesListByManagerResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.DeviceList); err != nil {
		return DevicesListByManagerResponse{}, err
	}
	return result, nil
}

// listByManagerHandleError handles the ListByManager error response.
func (client *DevicesClient) listByManagerHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// ListFailoverSets - Returns all failover sets for a given device and their eligibility for participating in a failover. A failover set refers to a set
// of volume containers that need to be failed-over as a single unit to
// maintain data integrity.
// If the operation fails it returns a generic error.
func (client *DevicesClient) ListFailoverSets(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesListFailoverSetsOptions) (DevicesListFailoverSetsResponse, error) {
	req, err := client.listFailoverSetsCreateRequest(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return DevicesListFailoverSetsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DevicesListFailoverSetsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DevicesListFailoverSetsResponse{}, client.listFailoverSetsHandleError(resp)
	}
	return client.listFailoverSetsHandleResponse(resp)
}

// listFailoverSetsCreateRequest creates the ListFailoverSets request.
func (client *DevicesClient) listFailoverSetsCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesListFailoverSetsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}/listFailoverSets"
	if deviceName == "" {
		return nil, errors.New("parameter deviceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listFailoverSetsHandleResponse handles the ListFailoverSets response.
func (client *DevicesClient) listFailoverSetsHandleResponse(resp *http.Response) (DevicesListFailoverSetsResponse, error) {
	result := DevicesListFailoverSetsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.FailoverSetsList); err != nil {
		return DevicesListFailoverSetsResponse{}, err
	}
	return result, nil
}

// listFailoverSetsHandleError handles the ListFailoverSets error response.
func (client *DevicesClient) listFailoverSetsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// ListFailoverTargets - Given a list of volume containers to be failed over from a source device, this method returns the eligibility result, as a failover
// target, for all devices under that resource.
// If the operation fails it returns a generic error.
func (client *DevicesClient) ListFailoverTargets(ctx context.Context, sourceDeviceName string, resourceGroupName string, managerName string, parameters ListFailoverTargetsRequest, options *DevicesListFailoverTargetsOptions) (DevicesListFailoverTargetsResponse, error) {
	req, err := client.listFailoverTargetsCreateRequest(ctx, sourceDeviceName, resourceGroupName, managerName, parameters, options)
	if err != nil {
		return DevicesListFailoverTargetsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DevicesListFailoverTargetsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DevicesListFailoverTargetsResponse{}, client.listFailoverTargetsHandleError(resp)
	}
	return client.listFailoverTargetsHandleResponse(resp)
}

// listFailoverTargetsCreateRequest creates the ListFailoverTargets request.
func (client *DevicesClient) listFailoverTargetsCreateRequest(ctx context.Context, sourceDeviceName string, resourceGroupName string, managerName string, parameters ListFailoverTargetsRequest, options *DevicesListFailoverTargetsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{sourceDeviceName}/listFailoverTargets"
	if sourceDeviceName == "" {
		return nil, errors.New("parameter sourceDeviceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{sourceDeviceName}", sourceDeviceName)
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// listFailoverTargetsHandleResponse handles the ListFailoverTargets response.
func (client *DevicesClient) listFailoverTargetsHandleResponse(resp *http.Response) (DevicesListFailoverTargetsResponse, error) {
	result := DevicesListFailoverTargetsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.FailoverTargetsList); err != nil {
		return DevicesListFailoverTargetsResponse{}, err
	}
	return result, nil
}

// listFailoverTargetsHandleError handles the ListFailoverTargets error response.
func (client *DevicesClient) listFailoverTargetsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// ListMetricDefinition - Gets the metric definitions for the specified device.
// If the operation fails it returns a generic error.
func (client *DevicesClient) ListMetricDefinition(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesListMetricDefinitionOptions) (DevicesListMetricDefinitionResponse, error) {
	req, err := client.listMetricDefinitionCreateRequest(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return DevicesListMetricDefinitionResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DevicesListMetricDefinitionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DevicesListMetricDefinitionResponse{}, client.listMetricDefinitionHandleError(resp)
	}
	return client.listMetricDefinitionHandleResponse(resp)
}

// listMetricDefinitionCreateRequest creates the ListMetricDefinition request.
func (client *DevicesClient) listMetricDefinitionCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesListMetricDefinitionOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}/metricsDefinitions"
	if deviceName == "" {
		return nil, errors.New("parameter deviceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listMetricDefinitionHandleResponse handles the ListMetricDefinition response.
func (client *DevicesClient) listMetricDefinitionHandleResponse(resp *http.Response) (DevicesListMetricDefinitionResponse, error) {
	result := DevicesListMetricDefinitionResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.MetricDefinitionList); err != nil {
		return DevicesListMetricDefinitionResponse{}, err
	}
	return result, nil
}

// listMetricDefinitionHandleError handles the ListMetricDefinition error response.
func (client *DevicesClient) listMetricDefinitionHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// ListMetrics - Gets the metrics for the specified device.
// If the operation fails it returns a generic error.
func (client *DevicesClient) ListMetrics(ctx context.Context, deviceName string, resourceGroupName string, managerName string, filter string, options *DevicesListMetricsOptions) (DevicesListMetricsResponse, error) {
	req, err := client.listMetricsCreateRequest(ctx, deviceName, resourceGroupName, managerName, filter, options)
	if err != nil {
		return DevicesListMetricsResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DevicesListMetricsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DevicesListMetricsResponse{}, client.listMetricsHandleError(resp)
	}
	return client.listMetricsHandleResponse(resp)
}

// listMetricsCreateRequest creates the ListMetrics request.
func (client *DevicesClient) listMetricsCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, filter string, options *DevicesListMetricsOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}/metrics"
	if deviceName == "" {
		return nil, errors.New("parameter deviceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodGet, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	reqQP.Set("$filter", filter)
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, nil
}

// listMetricsHandleResponse handles the ListMetrics response.
func (client *DevicesClient) listMetricsHandleResponse(resp *http.Response) (DevicesListMetricsResponse, error) {
	result := DevicesListMetricsResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.MetricList); err != nil {
		return DevicesListMetricsResponse{}, err
	}
	return result, nil
}

// listMetricsHandleError handles the ListMetrics error response.
func (client *DevicesClient) listMetricsHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// BeginScanForUpdates - Scans for updates on the device.
// If the operation fails it returns a generic error.
func (client *DevicesClient) BeginScanForUpdates(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesBeginScanForUpdatesOptions) (DevicesScanForUpdatesPollerResponse, error) {
	resp, err := client.scanForUpdates(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return DevicesScanForUpdatesPollerResponse{}, err
	}
	result := DevicesScanForUpdatesPollerResponse{
		RawResponse: resp,
	}
	pt, err := armruntime.NewPoller("DevicesClient.ScanForUpdates", "", resp, client.pl, client.scanForUpdatesHandleError)
	if err != nil {
		return DevicesScanForUpdatesPollerResponse{}, err
	}
	result.Poller = &DevicesScanForUpdatesPoller{
		pt: pt,
	}
	return result, nil
}

// ScanForUpdates - Scans for updates on the device.
// If the operation fails it returns a generic error.
func (client *DevicesClient) scanForUpdates(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesBeginScanForUpdatesOptions) (*http.Response, error) {
	req, err := client.scanForUpdatesCreateRequest(ctx, deviceName, resourceGroupName, managerName, options)
	if err != nil {
		return nil, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return nil, err
	}
	if !runtime.HasStatusCode(resp, http.StatusAccepted, http.StatusNoContent) {
		return nil, client.scanForUpdatesHandleError(resp)
	}
	return resp, nil
}

// scanForUpdatesCreateRequest creates the ScanForUpdates request.
func (client *DevicesClient) scanForUpdatesCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, options *DevicesBeginScanForUpdatesOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}/scanForUpdates"
	if deviceName == "" {
		return nil, errors.New("parameter deviceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPost, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	return req, nil
}

// scanForUpdatesHandleError handles the ScanForUpdates error response.
func (client *DevicesClient) scanForUpdatesHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}

// Update - Patches the device.
// If the operation fails it returns a generic error.
func (client *DevicesClient) Update(ctx context.Context, deviceName string, resourceGroupName string, managerName string, parameters DevicePatch, options *DevicesUpdateOptions) (DevicesUpdateResponse, error) {
	req, err := client.updateCreateRequest(ctx, deviceName, resourceGroupName, managerName, parameters, options)
	if err != nil {
		return DevicesUpdateResponse{}, err
	}
	resp, err := client.pl.Do(req)
	if err != nil {
		return DevicesUpdateResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {
		return DevicesUpdateResponse{}, client.updateHandleError(resp)
	}
	return client.updateHandleResponse(resp)
}

// updateCreateRequest creates the Update request.
func (client *DevicesClient) updateCreateRequest(ctx context.Context, deviceName string, resourceGroupName string, managerName string, parameters DevicePatch, options *DevicesUpdateOptions) (*policy.Request, error) {
	urlPath := "/subscriptions/{subscriptionId}/resourceGroups/{resourceGroupName}/providers/Microsoft.StorSimple/managers/{managerName}/devices/{deviceName}"
	if deviceName == "" {
		return nil, errors.New("parameter deviceName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{deviceName}", deviceName)
	if client.subscriptionID == "" {
		return nil, errors.New("parameter client.subscriptionID cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{subscriptionId}", client.subscriptionID)
	if resourceGroupName == "" {
		return nil, errors.New("parameter resourceGroupName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{resourceGroupName}", resourceGroupName)
	if managerName == "" {
		return nil, errors.New("parameter managerName cannot be empty")
	}
	urlPath = strings.ReplaceAll(urlPath, "{managerName}", managerName)
	req, err := runtime.NewRequest(ctx, http.MethodPatch, runtime.JoinPaths(client.ep, urlPath))
	if err != nil {
		return nil, err
	}
	reqQP := req.Raw().URL.Query()
	reqQP.Set("api-version", "2017-06-01")
	req.Raw().URL.RawQuery = reqQP.Encode()
	req.Raw().Header.Set("Accept", "application/json")
	return req, runtime.MarshalAsJSON(req, parameters)
}

// updateHandleResponse handles the Update response.
func (client *DevicesClient) updateHandleResponse(resp *http.Response) (DevicesUpdateResponse, error) {
	result := DevicesUpdateResponse{RawResponse: resp}
	if err := runtime.UnmarshalAsJSON(resp, &result.Device); err != nil {
		return DevicesUpdateResponse{}, err
	}
	return result, nil
}

// updateHandleError handles the Update error response.
func (client *DevicesClient) updateHandleError(resp *http.Response) error {
	body, err := runtime.Payload(resp)
	if err != nil {
		return runtime.NewResponseError(err, resp)
	}
	if len(body) == 0 {
		return runtime.NewResponseError(errors.New(resp.Status), resp)
	}
	return runtime.NewResponseError(errors.New(string(body)), resp)
}
