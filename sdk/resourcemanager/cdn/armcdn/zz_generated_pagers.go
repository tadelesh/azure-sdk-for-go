//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcdn

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AFDCustomDomainsClientListByProfilePager provides operations for iterating over paged responses.
type AFDCustomDomainsClientListByProfilePager struct {
	client    *AFDCustomDomainsClient
	current   AFDCustomDomainsClientListByProfileResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AFDCustomDomainsClientListByProfileResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AFDCustomDomainsClientListByProfilePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AFDDomainListResult.NextLink == nil || len(*p.current.AFDDomainListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AFDCustomDomainsClientListByProfilePager) NextPage(ctx context.Context) (AFDCustomDomainsClientListByProfileResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AFDCustomDomainsClientListByProfileResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AFDCustomDomainsClientListByProfileResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AFDCustomDomainsClientListByProfileResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AFDCustomDomainsClientListByProfileResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByProfileHandleResponse(resp)
	if err != nil {
		return AFDCustomDomainsClientListByProfileResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AFDEndpointsClientListByProfilePager provides operations for iterating over paged responses.
type AFDEndpointsClientListByProfilePager struct {
	client    *AFDEndpointsClient
	current   AFDEndpointsClientListByProfileResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AFDEndpointsClientListByProfileResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AFDEndpointsClientListByProfilePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AFDEndpointListResult.NextLink == nil || len(*p.current.AFDEndpointListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AFDEndpointsClientListByProfilePager) NextPage(ctx context.Context) (AFDEndpointsClientListByProfileResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AFDEndpointsClientListByProfileResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AFDEndpointsClientListByProfileResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AFDEndpointsClientListByProfileResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AFDEndpointsClientListByProfileResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByProfileHandleResponse(resp)
	if err != nil {
		return AFDEndpointsClientListByProfileResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AFDEndpointsClientListResourceUsagePager provides operations for iterating over paged responses.
type AFDEndpointsClientListResourceUsagePager struct {
	client    *AFDEndpointsClient
	current   AFDEndpointsClientListResourceUsageResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AFDEndpointsClientListResourceUsageResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AFDEndpointsClientListResourceUsagePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UsagesListResult.NextLink == nil || len(*p.current.UsagesListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AFDEndpointsClientListResourceUsagePager) NextPage(ctx context.Context) (AFDEndpointsClientListResourceUsageResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AFDEndpointsClientListResourceUsageResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AFDEndpointsClientListResourceUsageResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AFDEndpointsClientListResourceUsageResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AFDEndpointsClientListResourceUsageResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listResourceUsageHandleResponse(resp)
	if err != nil {
		return AFDEndpointsClientListResourceUsageResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AFDOriginGroupsClientListByProfilePager provides operations for iterating over paged responses.
type AFDOriginGroupsClientListByProfilePager struct {
	client    *AFDOriginGroupsClient
	current   AFDOriginGroupsClientListByProfileResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AFDOriginGroupsClientListByProfileResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AFDOriginGroupsClientListByProfilePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AFDOriginGroupListResult.NextLink == nil || len(*p.current.AFDOriginGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AFDOriginGroupsClientListByProfilePager) NextPage(ctx context.Context) (AFDOriginGroupsClientListByProfileResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AFDOriginGroupsClientListByProfileResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AFDOriginGroupsClientListByProfileResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AFDOriginGroupsClientListByProfileResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AFDOriginGroupsClientListByProfileResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByProfileHandleResponse(resp)
	if err != nil {
		return AFDOriginGroupsClientListByProfileResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AFDOriginGroupsClientListResourceUsagePager provides operations for iterating over paged responses.
type AFDOriginGroupsClientListResourceUsagePager struct {
	client    *AFDOriginGroupsClient
	current   AFDOriginGroupsClientListResourceUsageResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AFDOriginGroupsClientListResourceUsageResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AFDOriginGroupsClientListResourceUsagePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UsagesListResult.NextLink == nil || len(*p.current.UsagesListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AFDOriginGroupsClientListResourceUsagePager) NextPage(ctx context.Context) (AFDOriginGroupsClientListResourceUsageResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AFDOriginGroupsClientListResourceUsageResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AFDOriginGroupsClientListResourceUsageResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AFDOriginGroupsClientListResourceUsageResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AFDOriginGroupsClientListResourceUsageResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listResourceUsageHandleResponse(resp)
	if err != nil {
		return AFDOriginGroupsClientListResourceUsageResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AFDOriginsClientListByOriginGroupPager provides operations for iterating over paged responses.
type AFDOriginsClientListByOriginGroupPager struct {
	client    *AFDOriginsClient
	current   AFDOriginsClientListByOriginGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AFDOriginsClientListByOriginGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AFDOriginsClientListByOriginGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AFDOriginListResult.NextLink == nil || len(*p.current.AFDOriginListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AFDOriginsClientListByOriginGroupPager) NextPage(ctx context.Context) (AFDOriginsClientListByOriginGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AFDOriginsClientListByOriginGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AFDOriginsClientListByOriginGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AFDOriginsClientListByOriginGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AFDOriginsClientListByOriginGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByOriginGroupHandleResponse(resp)
	if err != nil {
		return AFDOriginsClientListByOriginGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AFDProfilesClientListResourceUsagePager provides operations for iterating over paged responses.
type AFDProfilesClientListResourceUsagePager struct {
	client    *AFDProfilesClient
	current   AFDProfilesClientListResourceUsageResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AFDProfilesClientListResourceUsageResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AFDProfilesClientListResourceUsagePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UsagesListResult.NextLink == nil || len(*p.current.UsagesListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AFDProfilesClientListResourceUsagePager) NextPage(ctx context.Context) (AFDProfilesClientListResourceUsageResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AFDProfilesClientListResourceUsageResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AFDProfilesClientListResourceUsageResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AFDProfilesClientListResourceUsageResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AFDProfilesClientListResourceUsageResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listResourceUsageHandleResponse(resp)
	if err != nil {
		return AFDProfilesClientListResourceUsageResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CustomDomainsClientListByEndpointPager provides operations for iterating over paged responses.
type CustomDomainsClientListByEndpointPager struct {
	client    *CustomDomainsClient
	current   CustomDomainsClientListByEndpointResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CustomDomainsClientListByEndpointResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CustomDomainsClientListByEndpointPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CustomDomainListResult.NextLink == nil || len(*p.current.CustomDomainListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CustomDomainsClientListByEndpointPager) NextPage(ctx context.Context) (CustomDomainsClientListByEndpointResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CustomDomainsClientListByEndpointResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CustomDomainsClientListByEndpointResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CustomDomainsClientListByEndpointResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CustomDomainsClientListByEndpointResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByEndpointHandleResponse(resp)
	if err != nil {
		return CustomDomainsClientListByEndpointResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// EdgeNodesClientListPager provides operations for iterating over paged responses.
type EdgeNodesClientListPager struct {
	client    *EdgeNodesClient
	current   EdgeNodesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EdgeNodesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *EdgeNodesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EdgenodeResult.NextLink == nil || len(*p.current.EdgenodeResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *EdgeNodesClientListPager) NextPage(ctx context.Context) (EdgeNodesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return EdgeNodesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return EdgeNodesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return EdgeNodesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return EdgeNodesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return EdgeNodesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// EndpointsClientListByProfilePager provides operations for iterating over paged responses.
type EndpointsClientListByProfilePager struct {
	client    *EndpointsClient
	current   EndpointsClientListByProfileResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EndpointsClientListByProfileResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *EndpointsClientListByProfilePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.EndpointListResult.NextLink == nil || len(*p.current.EndpointListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *EndpointsClientListByProfilePager) NextPage(ctx context.Context) (EndpointsClientListByProfileResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return EndpointsClientListByProfileResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return EndpointsClientListByProfileResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return EndpointsClientListByProfileResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return EndpointsClientListByProfileResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByProfileHandleResponse(resp)
	if err != nil {
		return EndpointsClientListByProfileResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// EndpointsClientListResourceUsagePager provides operations for iterating over paged responses.
type EndpointsClientListResourceUsagePager struct {
	client    *EndpointsClient
	current   EndpointsClientListResourceUsageResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, EndpointsClientListResourceUsageResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *EndpointsClientListResourceUsagePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceUsageListResult.NextLink == nil || len(*p.current.ResourceUsageListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *EndpointsClientListResourceUsagePager) NextPage(ctx context.Context) (EndpointsClientListResourceUsageResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return EndpointsClientListResourceUsageResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return EndpointsClientListResourceUsageResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return EndpointsClientListResourceUsageResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return EndpointsClientListResourceUsageResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listResourceUsageHandleResponse(resp)
	if err != nil {
		return EndpointsClientListResourceUsageResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ManagedRuleSetsClientListPager provides operations for iterating over paged responses.
type ManagedRuleSetsClientListPager struct {
	client    *ManagedRuleSetsClient
	current   ManagedRuleSetsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ManagedRuleSetsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ManagedRuleSetsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ManagedRuleSetDefinitionList.NextLink == nil || len(*p.current.ManagedRuleSetDefinitionList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ManagedRuleSetsClientListPager) NextPage(ctx context.Context) (ManagedRuleSetsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ManagedRuleSetsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ManagedRuleSetsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ManagedRuleSetsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ManagedRuleSetsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ManagedRuleSetsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *OperationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationsListResult.NextLink == nil || len(*p.current.OperationsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *OperationsClientListPager) NextPage(ctx context.Context) (OperationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return OperationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return OperationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// OriginGroupsClientListByEndpointPager provides operations for iterating over paged responses.
type OriginGroupsClientListByEndpointPager struct {
	client    *OriginGroupsClient
	current   OriginGroupsClientListByEndpointResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OriginGroupsClientListByEndpointResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *OriginGroupsClientListByEndpointPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OriginGroupListResult.NextLink == nil || len(*p.current.OriginGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *OriginGroupsClientListByEndpointPager) NextPage(ctx context.Context) (OriginGroupsClientListByEndpointResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return OriginGroupsClientListByEndpointResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return OriginGroupsClientListByEndpointResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return OriginGroupsClientListByEndpointResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return OriginGroupsClientListByEndpointResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByEndpointHandleResponse(resp)
	if err != nil {
		return OriginGroupsClientListByEndpointResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// OriginsClientListByEndpointPager provides operations for iterating over paged responses.
type OriginsClientListByEndpointPager struct {
	client    *OriginsClient
	current   OriginsClientListByEndpointResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OriginsClientListByEndpointResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *OriginsClientListByEndpointPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OriginListResult.NextLink == nil || len(*p.current.OriginListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *OriginsClientListByEndpointPager) NextPage(ctx context.Context) (OriginsClientListByEndpointResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return OriginsClientListByEndpointResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return OriginsClientListByEndpointResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return OriginsClientListByEndpointResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return OriginsClientListByEndpointResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByEndpointHandleResponse(resp)
	if err != nil {
		return OriginsClientListByEndpointResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PoliciesClientListPager provides operations for iterating over paged responses.
type PoliciesClientListPager struct {
	client    *PoliciesClient
	current   PoliciesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PoliciesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PoliciesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WebApplicationFirewallPolicyList.NextLink == nil || len(*p.current.WebApplicationFirewallPolicyList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PoliciesClientListPager) NextPage(ctx context.Context) (PoliciesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PoliciesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PoliciesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PoliciesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PoliciesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return PoliciesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProfilesClientListByResourceGroupPager provides operations for iterating over paged responses.
type ProfilesClientListByResourceGroupPager struct {
	client    *ProfilesClient
	current   ProfilesClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProfilesClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProfilesClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProfileListResult.NextLink == nil || len(*p.current.ProfileListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProfilesClientListByResourceGroupPager) NextPage(ctx context.Context) (ProfilesClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProfilesClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProfilesClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProfilesClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProfilesClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return ProfilesClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProfilesClientListPager provides operations for iterating over paged responses.
type ProfilesClientListPager struct {
	client    *ProfilesClient
	current   ProfilesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProfilesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProfilesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProfileListResult.NextLink == nil || len(*p.current.ProfileListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProfilesClientListPager) NextPage(ctx context.Context) (ProfilesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProfilesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProfilesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProfilesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProfilesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ProfilesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProfilesClientListResourceUsagePager provides operations for iterating over paged responses.
type ProfilesClientListResourceUsagePager struct {
	client    *ProfilesClient
	current   ProfilesClientListResourceUsageResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProfilesClientListResourceUsageResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProfilesClientListResourceUsagePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceUsageListResult.NextLink == nil || len(*p.current.ResourceUsageListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProfilesClientListResourceUsagePager) NextPage(ctx context.Context) (ProfilesClientListResourceUsageResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProfilesClientListResourceUsageResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProfilesClientListResourceUsageResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProfilesClientListResourceUsageResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProfilesClientListResourceUsageResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listResourceUsageHandleResponse(resp)
	if err != nil {
		return ProfilesClientListResourceUsageResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ResourceUsageClientListPager provides operations for iterating over paged responses.
type ResourceUsageClientListPager struct {
	client    *ResourceUsageClient
	current   ResourceUsageClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ResourceUsageClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ResourceUsageClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceUsageListResult.NextLink == nil || len(*p.current.ResourceUsageListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ResourceUsageClientListPager) NextPage(ctx context.Context) (ResourceUsageClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ResourceUsageClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ResourceUsageClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ResourceUsageClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ResourceUsageClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ResourceUsageClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RoutesClientListByEndpointPager provides operations for iterating over paged responses.
type RoutesClientListByEndpointPager struct {
	client    *RoutesClient
	current   RoutesClientListByEndpointResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RoutesClientListByEndpointResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RoutesClientListByEndpointPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RouteListResult.NextLink == nil || len(*p.current.RouteListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RoutesClientListByEndpointPager) NextPage(ctx context.Context) (RoutesClientListByEndpointResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RoutesClientListByEndpointResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RoutesClientListByEndpointResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RoutesClientListByEndpointResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RoutesClientListByEndpointResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByEndpointHandleResponse(resp)
	if err != nil {
		return RoutesClientListByEndpointResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RuleSetsClientListByProfilePager provides operations for iterating over paged responses.
type RuleSetsClientListByProfilePager struct {
	client    *RuleSetsClient
	current   RuleSetsClientListByProfileResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RuleSetsClientListByProfileResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RuleSetsClientListByProfilePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RuleSetListResult.NextLink == nil || len(*p.current.RuleSetListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RuleSetsClientListByProfilePager) NextPage(ctx context.Context) (RuleSetsClientListByProfileResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RuleSetsClientListByProfileResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RuleSetsClientListByProfileResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RuleSetsClientListByProfileResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RuleSetsClientListByProfileResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByProfileHandleResponse(resp)
	if err != nil {
		return RuleSetsClientListByProfileResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RuleSetsClientListResourceUsagePager provides operations for iterating over paged responses.
type RuleSetsClientListResourceUsagePager struct {
	client    *RuleSetsClient
	current   RuleSetsClientListResourceUsageResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RuleSetsClientListResourceUsageResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RuleSetsClientListResourceUsagePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UsagesListResult.NextLink == nil || len(*p.current.UsagesListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RuleSetsClientListResourceUsagePager) NextPage(ctx context.Context) (RuleSetsClientListResourceUsageResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RuleSetsClientListResourceUsageResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RuleSetsClientListResourceUsageResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RuleSetsClientListResourceUsageResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RuleSetsClientListResourceUsageResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listResourceUsageHandleResponse(resp)
	if err != nil {
		return RuleSetsClientListResourceUsageResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RulesClientListByRuleSetPager provides operations for iterating over paged responses.
type RulesClientListByRuleSetPager struct {
	client    *RulesClient
	current   RulesClientListByRuleSetResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RulesClientListByRuleSetResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RulesClientListByRuleSetPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RuleListResult.NextLink == nil || len(*p.current.RuleListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RulesClientListByRuleSetPager) NextPage(ctx context.Context) (RulesClientListByRuleSetResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RulesClientListByRuleSetResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RulesClientListByRuleSetResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RulesClientListByRuleSetResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RulesClientListByRuleSetResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByRuleSetHandleResponse(resp)
	if err != nil {
		return RulesClientListByRuleSetResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SecretsClientListByProfilePager provides operations for iterating over paged responses.
type SecretsClientListByProfilePager struct {
	client    *SecretsClient
	current   SecretsClientListByProfileResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecretsClientListByProfileResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SecretsClientListByProfilePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecretListResult.NextLink == nil || len(*p.current.SecretListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SecretsClientListByProfilePager) NextPage(ctx context.Context) (SecretsClientListByProfileResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SecretsClientListByProfileResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SecretsClientListByProfileResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SecretsClientListByProfileResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SecretsClientListByProfileResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByProfileHandleResponse(resp)
	if err != nil {
		return SecretsClientListByProfileResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SecurityPoliciesClientListByProfilePager provides operations for iterating over paged responses.
type SecurityPoliciesClientListByProfilePager struct {
	client    *SecurityPoliciesClient
	current   SecurityPoliciesClientListByProfileResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SecurityPoliciesClientListByProfileResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SecurityPoliciesClientListByProfilePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SecurityPolicyListResult.NextLink == nil || len(*p.current.SecurityPolicyListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SecurityPoliciesClientListByProfilePager) NextPage(ctx context.Context) (SecurityPoliciesClientListByProfileResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SecurityPoliciesClientListByProfileResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SecurityPoliciesClientListByProfileResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SecurityPoliciesClientListByProfileResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SecurityPoliciesClientListByProfileResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByProfileHandleResponse(resp)
	if err != nil {
		return SecurityPoliciesClientListByProfileResponse{}, err
	}
	p.current = result
	return p.current, nil
}
