//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcontainerservice

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"runtime/debug"
	"testing"

	"time"

	"github.com/Azure/azure-sdk-for-go/sdk/azcore"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/arm"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/to"
	"github.com/Azure/azure-sdk-for-go/sdk/azidentity"
	"golang.org/x/net/http2"
)

var (
	ctx            context.Context
	subscriptionId string
	cred           azcore.TokenCredential
	err            error
	con            *arm.Connection
	mockHost       string
)

func TestOperations_List(t *testing.T) {
	t.Skip("Warning: No test steps for this operation!")
}

func TestManagedClusters_GetOSOptions(t *testing.T) {
	// From example Get Container Service OS Options
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewManagedClustersClient(con,
		"subid1")
	res, err := client.GetOSOptions(ctx,
		"location1",
		&ManagedClustersGetOSOptionsOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.OSOptionProfile.ID == nil {
		t.Fatal("OSOptionProfile.ID should not be nil!")
	}
}

func TestManagedClusters_List(t *testing.T) {
	// From example List Managed Clusters
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewManagedClustersClient(con,
		"subid1")
	pager := client.List(&ManagedClustersListOptions{})
	for pager.NextPage(ctx) {
		if err := pager.Err(); err != nil {
			t.Fatalf("failed to advance page: %v", err)
		}
		for _, v := range pager.PageResponse().Value {
			fmt.Printf("ManagedCluster.ID: %s\n", *v.ID)
			if v.ID == nil {
				t.Fatal("ManagedCluster.ID should not be nil!")
			}
		}
	}
}

func TestManagedClusters_ListByResourceGroup(t *testing.T) {
	// From example Get Managed Clusters by Resource Group
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewManagedClustersClient(con,
		"subid1")
	pager := client.ListByResourceGroup("rg1",
		&ManagedClustersListByResourceGroupOptions{})
	for pager.NextPage(ctx) {
		if err := pager.Err(); err != nil {
			t.Fatalf("failed to advance page: %v", err)
		}
		for _, v := range pager.PageResponse().Value {
			fmt.Printf("ManagedCluster.ID: %s\n", *v.ID)
			if v.ID == nil {
				t.Fatal("ManagedCluster.ID should not be nil!")
			}
		}
	}
}

func TestManagedClusters_GetUpgradeProfile(t *testing.T) {
	// From example Get Upgrade Profile for Managed Cluster
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewManagedClustersClient(con,
		"subid1")
	res, err := client.GetUpgradeProfile(ctx,
		"rg1",
		"clustername1",
		&ManagedClustersGetUpgradeProfileOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedClusterUpgradeProfile.ID == nil {
		t.Fatal("ManagedClusterUpgradeProfile.ID should not be nil!")
	}
}

func TestManagedClusters_GetAccessProfile(t *testing.T) {
	// From example Get Managed Cluster
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewManagedClustersClient(con,
		"subid1")
	res, err := client.GetAccessProfile(ctx,
		"rg1",
		"clustername1",
		"clusterUser",
		&ManagedClustersGetAccessProfileOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedClusterAccessProfile.ID == nil {
		t.Fatal("ManagedClusterAccessProfile.ID should not be nil!")
	}
}

func TestManagedClusters_ListClusterAdminCredentials(t *testing.T) {
	// From example Get Managed Cluster
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewManagedClustersClient(con,
		"subid1")
	_, err := client.ListClusterAdminCredentials(ctx,
		"rg1",
		"clustername1",
		&ManagedClustersListClusterAdminCredentialsOptions{})
	if err != nil {
		t.Fatal(err)
	}
}

func TestManagedClusters_ListClusterUserCredentials(t *testing.T) {
	// From example Get Managed Cluster
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewManagedClustersClient(con,
		"subid1")
	_, err := client.ListClusterUserCredentials(ctx,
		"rg1",
		"clustername1",
		&ManagedClustersListClusterUserCredentialsOptions{})
	if err != nil {
		t.Fatal(err)
	}
}

func TestManagedClusters_ListClusterMonitoringUserCredentials(t *testing.T) {
	// From example Get Managed Cluster
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewManagedClustersClient(con,
		"subid1")
	_, err := client.ListClusterMonitoringUserCredentials(ctx,
		"rg1",
		"clustername1",
		&ManagedClustersListClusterMonitoringUserCredentialsOptions{})
	if err != nil {
		t.Fatal(err)
	}
}

func TestManagedClusters_Get(t *testing.T) {
	// From example Get Managed Cluster
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewManagedClustersClient(con,
		"subid1")
	res, err := client.Get(ctx,
		"rg1",
		"clustername1",
		&ManagedClustersGetOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedCluster.ID == nil {
		t.Fatal("ManagedCluster.ID should not be nil!")
	}
}

func TestManagedClusters_CreateOrUpdate(t *testing.T) {
	// From example Create Managed Cluster using an agent pool snapshot
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewManagedClustersClient(con,
		"subid1")
	poller, err := client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		ManagedCluster{
			Resource: Resource{
				Location: to.StringPtr("location1"),
				Tags: map[string]*string{
					"archv2": to.StringPtr(""),
					"tier":   to.StringPtr("production"),
				},
			},
			Properties: &ManagedClusterProperties{
				AddonProfiles: map[string]*ManagedClusterAddonProfile{},
				AgentPoolProfiles: []*ManagedClusterAgentPoolProfile{
					{
						ManagedClusterAgentPoolProfileProperties: ManagedClusterAgentPoolProfileProperties{
							Type:  AgentPoolTypeVirtualMachineScaleSets.ToPtr(),
							Count: to.Int32Ptr(3),
							CreationData: &CreationData{
								SourceResourceID: to.StringPtr("/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.ContainerService/snapshots/snapshot1"),
							},
							EnableFIPS:         to.BoolPtr(true),
							EnableNodePublicIP: to.BoolPtr(true),
							Mode:               AgentPoolModeSystem.ToPtr(),
							OSType:             OSTypeLinux.ToPtr(),
							VMSize:             to.StringPtr("Standard_DS2_v2"),
						},
						Name: to.StringPtr("nodepool1"),
					}},
				AutoScalerProfile: &ManagedClusterPropertiesAutoScalerProfile{
					ScaleDownDelayAfterAdd: to.StringPtr("15m"),
					ScanInterval:           to.StringPtr("20s"),
				},
				DiskEncryptionSetID:     to.StringPtr("/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des"),
				DNSPrefix:               to.StringPtr("dnsprefix1"),
				EnablePodSecurityPolicy: to.BoolPtr(false),
				EnableRBAC:              to.BoolPtr(true),
				KubernetesVersion:       to.StringPtr(""),
				LinuxProfile: &ContainerServiceLinuxProfile{
					AdminUsername: to.StringPtr("azureuser"),
					SSH: &ContainerServiceSSHConfiguration{
						PublicKeys: []*ContainerServiceSSHPublicKey{
							{
								KeyData: to.StringPtr("keydata"),
							}},
					},
				},
				NetworkProfile: &ContainerServiceNetworkProfile{
					LoadBalancerProfile: &ManagedClusterLoadBalancerProfile{
						ManagedOutboundIPs: &ManagedClusterLoadBalancerProfileManagedOutboundIPs{
							Count: to.Int32Ptr(2),
						},
					},
					LoadBalancerSKU: LoadBalancerSKUStandard.ToPtr(),
					OutboundType:    OutboundTypeLoadBalancer.ToPtr(),
				},
				ServicePrincipalProfile: &ManagedClusterServicePrincipalProfile{
					ClientID: to.StringPtr("clientid"),
					Secret:   to.StringPtr("secret"),
				},
				WindowsProfile: &ManagedClusterWindowsProfile{
					AdminPassword: to.StringPtr("replacePassword1234$"),
					AdminUsername: to.StringPtr("azureuser"),
				},
			},
			SKU: &ManagedClusterSKU{
				Name: ManagedClusterSKUNameBasic.ToPtr(),
				Tier: ManagedClusterSKUTierFree.ToPtr(),
			},
		},
		&ManagedClustersBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err := poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedCluster.ID == nil {
		t.Fatal("ManagedCluster.ID should not be nil!")
	}

	// From example Create Managed Cluster with AKS-managed NAT gateway as outbound type
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		ManagedCluster{
			Resource: Resource{
				Location: to.StringPtr("location1"),
				Tags: map[string]*string{
					"archv2": to.StringPtr(""),
					"tier":   to.StringPtr("production"),
				},
			},
			Properties: &ManagedClusterProperties{
				AddonProfiles: map[string]*ManagedClusterAddonProfile{},
				AgentPoolProfiles: []*ManagedClusterAgentPoolProfile{
					{
						ManagedClusterAgentPoolProfileProperties: ManagedClusterAgentPoolProfileProperties{
							Type:               AgentPoolTypeVirtualMachineScaleSets.ToPtr(),
							Count:              to.Int32Ptr(3),
							EnableNodePublicIP: to.BoolPtr(false),
							Mode:               AgentPoolModeSystem.ToPtr(),
							OSType:             OSTypeLinux.ToPtr(),
							VMSize:             to.StringPtr("Standard_DS2_v2"),
						},
						Name: to.StringPtr("nodepool1"),
					}},
				AutoScalerProfile: &ManagedClusterPropertiesAutoScalerProfile{
					ScaleDownDelayAfterAdd: to.StringPtr("15m"),
					ScanInterval:           to.StringPtr("20s"),
				},
				DiskEncryptionSetID:     to.StringPtr("/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des"),
				DNSPrefix:               to.StringPtr("dnsprefix1"),
				EnablePodSecurityPolicy: to.BoolPtr(true),
				EnableRBAC:              to.BoolPtr(true),
				KubernetesVersion:       to.StringPtr(""),
				LinuxProfile: &ContainerServiceLinuxProfile{
					AdminUsername: to.StringPtr("azureuser"),
					SSH: &ContainerServiceSSHConfiguration{
						PublicKeys: []*ContainerServiceSSHPublicKey{
							{
								KeyData: to.StringPtr("keydata"),
							}},
					},
				},
				NetworkProfile: &ContainerServiceNetworkProfile{
					LoadBalancerSKU: LoadBalancerSKUStandard.ToPtr(),
					NatGatewayProfile: &ManagedClusterNATGatewayProfile{
						ManagedOutboundIPProfile: &ManagedClusterManagedOutboundIPProfile{
							Count: to.Int32Ptr(2),
						},
					},
					OutboundType: OutboundTypeManagedNATGateway.ToPtr(),
				},
				ServicePrincipalProfile: &ManagedClusterServicePrincipalProfile{
					ClientID: to.StringPtr("clientid"),
					Secret:   to.StringPtr("secret"),
				},
				WindowsProfile: &ManagedClusterWindowsProfile{
					AdminPassword: to.StringPtr("replacePassword1234$"),
					AdminUsername: to.StringPtr("azureuser"),
				},
			},
			SKU: &ManagedClusterSKU{
				Name: ManagedClusterSKUNameBasic.ToPtr(),
				Tier: ManagedClusterSKUTierFree.ToPtr(),
			},
		},
		&ManagedClustersBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedCluster.ID == nil {
		t.Fatal("ManagedCluster.ID should not be nil!")
	}

	// From example Create Managed Cluster with EncryptionAtHost enabled
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		ManagedCluster{
			Resource: Resource{
				Location: to.StringPtr("location1"),
				Tags: map[string]*string{
					"archv2": to.StringPtr(""),
					"tier":   to.StringPtr("production"),
				},
			},
			Properties: &ManagedClusterProperties{
				AddonProfiles: map[string]*ManagedClusterAddonProfile{},
				AgentPoolProfiles: []*ManagedClusterAgentPoolProfile{
					{
						ManagedClusterAgentPoolProfileProperties: ManagedClusterAgentPoolProfileProperties{
							Type:                   AgentPoolTypeVirtualMachineScaleSets.ToPtr(),
							Count:                  to.Int32Ptr(3),
							EnableEncryptionAtHost: to.BoolPtr(true),
							EnableNodePublicIP:     to.BoolPtr(true),
							Mode:                   AgentPoolModeSystem.ToPtr(),
							OSType:                 OSTypeLinux.ToPtr(),
							VMSize:                 to.StringPtr("Standard_DS2_v2"),
						},
						Name: to.StringPtr("nodepool1"),
					}},
				AutoScalerProfile: &ManagedClusterPropertiesAutoScalerProfile{
					ScaleDownDelayAfterAdd: to.StringPtr("15m"),
					ScanInterval:           to.StringPtr("20s"),
				},
				DiskEncryptionSetID:     to.StringPtr("/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des"),
				DNSPrefix:               to.StringPtr("dnsprefix1"),
				EnablePodSecurityPolicy: to.BoolPtr(true),
				EnableRBAC:              to.BoolPtr(true),
				KubernetesVersion:       to.StringPtr(""),
				LinuxProfile: &ContainerServiceLinuxProfile{
					AdminUsername: to.StringPtr("azureuser"),
					SSH: &ContainerServiceSSHConfiguration{
						PublicKeys: []*ContainerServiceSSHPublicKey{
							{
								KeyData: to.StringPtr("keydata"),
							}},
					},
				},
				NetworkProfile: &ContainerServiceNetworkProfile{
					LoadBalancerProfile: &ManagedClusterLoadBalancerProfile{
						ManagedOutboundIPs: &ManagedClusterLoadBalancerProfileManagedOutboundIPs{
							Count: to.Int32Ptr(2),
						},
					},
					LoadBalancerSKU: LoadBalancerSKUStandard.ToPtr(),
					OutboundType:    OutboundTypeLoadBalancer.ToPtr(),
				},
				ServicePrincipalProfile: &ManagedClusterServicePrincipalProfile{
					ClientID: to.StringPtr("clientid"),
					Secret:   to.StringPtr("secret"),
				},
				WindowsProfile: &ManagedClusterWindowsProfile{
					AdminPassword: to.StringPtr("replacePassword1234$"),
					AdminUsername: to.StringPtr("azureuser"),
				},
			},
			SKU: &ManagedClusterSKU{
				Name: ManagedClusterSKUNameBasic.ToPtr(),
				Tier: ManagedClusterSKUTierFree.ToPtr(),
			},
		},
		&ManagedClustersBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedCluster.ID == nil {
		t.Fatal("ManagedCluster.ID should not be nil!")
	}

	// From example Create Managed Cluster with FIPS enabled OS
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		ManagedCluster{
			Resource: Resource{
				Location: to.StringPtr("location1"),
				Tags: map[string]*string{
					"archv2": to.StringPtr(""),
					"tier":   to.StringPtr("production"),
				},
			},
			Properties: &ManagedClusterProperties{
				AddonProfiles: map[string]*ManagedClusterAddonProfile{},
				AgentPoolProfiles: []*ManagedClusterAgentPoolProfile{
					{
						ManagedClusterAgentPoolProfileProperties: ManagedClusterAgentPoolProfileProperties{
							Type:               AgentPoolTypeVirtualMachineScaleSets.ToPtr(),
							Count:              to.Int32Ptr(3),
							EnableFIPS:         to.BoolPtr(true),
							EnableNodePublicIP: to.BoolPtr(true),
							Mode:               AgentPoolModeSystem.ToPtr(),
							OSType:             OSTypeLinux.ToPtr(),
							VMSize:             to.StringPtr("Standard_DS2_v2"),
						},
						Name: to.StringPtr("nodepool1"),
					}},
				AutoScalerProfile: &ManagedClusterPropertiesAutoScalerProfile{
					ScaleDownDelayAfterAdd: to.StringPtr("15m"),
					ScanInterval:           to.StringPtr("20s"),
				},
				DiskEncryptionSetID:     to.StringPtr("/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des"),
				DNSPrefix:               to.StringPtr("dnsprefix1"),
				EnablePodSecurityPolicy: to.BoolPtr(false),
				EnableRBAC:              to.BoolPtr(true),
				KubernetesVersion:       to.StringPtr(""),
				LinuxProfile: &ContainerServiceLinuxProfile{
					AdminUsername: to.StringPtr("azureuser"),
					SSH: &ContainerServiceSSHConfiguration{
						PublicKeys: []*ContainerServiceSSHPublicKey{
							{
								KeyData: to.StringPtr("keydata"),
							}},
					},
				},
				NetworkProfile: &ContainerServiceNetworkProfile{
					LoadBalancerProfile: &ManagedClusterLoadBalancerProfile{
						ManagedOutboundIPs: &ManagedClusterLoadBalancerProfileManagedOutboundIPs{
							Count: to.Int32Ptr(2),
						},
					},
					LoadBalancerSKU: LoadBalancerSKUStandard.ToPtr(),
					OutboundType:    OutboundTypeLoadBalancer.ToPtr(),
				},
				ServicePrincipalProfile: &ManagedClusterServicePrincipalProfile{
					ClientID: to.StringPtr("clientid"),
					Secret:   to.StringPtr("secret"),
				},
				WindowsProfile: &ManagedClusterWindowsProfile{
					AdminPassword: to.StringPtr("replacePassword1234$"),
					AdminUsername: to.StringPtr("azureuser"),
				},
			},
			SKU: &ManagedClusterSKU{
				Name: ManagedClusterSKUNameBasic.ToPtr(),
				Tier: ManagedClusterSKUTierFree.ToPtr(),
			},
		},
		&ManagedClustersBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedCluster.ID == nil {
		t.Fatal("ManagedCluster.ID should not be nil!")
	}

	// From example Create Managed Cluster with GPUMIG
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		ManagedCluster{
			Resource: Resource{
				Location: to.StringPtr("location1"),
				Tags: map[string]*string{
					"archv2": to.StringPtr(""),
					"tier":   to.StringPtr("production"),
				},
			},
			Properties: &ManagedClusterProperties{
				AddonProfiles: map[string]*ManagedClusterAddonProfile{},
				AgentPoolProfiles: []*ManagedClusterAgentPoolProfile{
					{
						ManagedClusterAgentPoolProfileProperties: ManagedClusterAgentPoolProfileProperties{
							Type:               AgentPoolTypeVirtualMachineScaleSets.ToPtr(),
							Count:              to.Int32Ptr(3),
							EnableNodePublicIP: to.BoolPtr(true),
							GpuInstanceProfile: GPUInstanceProfileMIG3G.ToPtr(),
							Mode:               AgentPoolModeSystem.ToPtr(),
							OSType:             OSTypeLinux.ToPtr(),
							VMSize:             to.StringPtr("Standard_ND96asr_v4"),
						},
						Name: to.StringPtr("nodepool1"),
					}},
				AutoScalerProfile: &ManagedClusterPropertiesAutoScalerProfile{
					ScaleDownDelayAfterAdd: to.StringPtr("15m"),
					ScanInterval:           to.StringPtr("20s"),
				},
				DiskEncryptionSetID:     to.StringPtr("/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des"),
				DNSPrefix:               to.StringPtr("dnsprefix1"),
				EnablePodSecurityPolicy: to.BoolPtr(true),
				EnableRBAC:              to.BoolPtr(true),
				HTTPProxyConfig: &ManagedClusterHTTPProxyConfig{
					HTTPProxy:  to.StringPtr("http://myproxy.server.com:8080"),
					HTTPSProxy: to.StringPtr("https://myproxy.server.com:8080"),
					NoProxy: []*string{
						to.StringPtr("localhost"),
						to.StringPtr("127.0.0.1")},
					TrustedCa: to.StringPtr("Q29uZ3JhdHMhIFlvdSBoYXZlIGZvdW5kIGEgaGlkZGVuIG1lc3NhZ2U="),
				},
				KubernetesVersion: to.StringPtr(""),
				LinuxProfile: &ContainerServiceLinuxProfile{
					AdminUsername: to.StringPtr("azureuser"),
					SSH: &ContainerServiceSSHConfiguration{
						PublicKeys: []*ContainerServiceSSHPublicKey{
							{
								KeyData: to.StringPtr("keydata"),
							}},
					},
				},
				NetworkProfile: &ContainerServiceNetworkProfile{
					LoadBalancerProfile: &ManagedClusterLoadBalancerProfile{
						ManagedOutboundIPs: &ManagedClusterLoadBalancerProfileManagedOutboundIPs{
							Count: to.Int32Ptr(2),
						},
					},
					LoadBalancerSKU: LoadBalancerSKUStandard.ToPtr(),
					OutboundType:    OutboundTypeLoadBalancer.ToPtr(),
				},
				ServicePrincipalProfile: &ManagedClusterServicePrincipalProfile{
					ClientID: to.StringPtr("clientid"),
					Secret:   to.StringPtr("secret"),
				},
				WindowsProfile: &ManagedClusterWindowsProfile{
					AdminPassword: to.StringPtr("replacePassword1234$"),
					AdminUsername: to.StringPtr("azureuser"),
				},
			},
			SKU: &ManagedClusterSKU{
				Name: ManagedClusterSKUNameBasic.ToPtr(),
				Tier: ManagedClusterSKUTierFree.ToPtr(),
			},
		},
		&ManagedClustersBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedCluster.ID == nil {
		t.Fatal("ManagedCluster.ID should not be nil!")
	}

	// From example Create Managed Cluster with HTTP proxy configured
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		ManagedCluster{
			Resource: Resource{
				Location: to.StringPtr("location1"),
				Tags: map[string]*string{
					"archv2": to.StringPtr(""),
					"tier":   to.StringPtr("production"),
				},
			},
			Properties: &ManagedClusterProperties{
				AddonProfiles: map[string]*ManagedClusterAddonProfile{},
				AgentPoolProfiles: []*ManagedClusterAgentPoolProfile{
					{
						ManagedClusterAgentPoolProfileProperties: ManagedClusterAgentPoolProfileProperties{
							Type:               AgentPoolTypeVirtualMachineScaleSets.ToPtr(),
							Count:              to.Int32Ptr(3),
							EnableNodePublicIP: to.BoolPtr(true),
							Mode:               AgentPoolModeSystem.ToPtr(),
							OSType:             OSTypeLinux.ToPtr(),
							VMSize:             to.StringPtr("Standard_DS2_v2"),
						},
						Name: to.StringPtr("nodepool1"),
					}},
				AutoScalerProfile: &ManagedClusterPropertiesAutoScalerProfile{
					ScaleDownDelayAfterAdd: to.StringPtr("15m"),
					ScanInterval:           to.StringPtr("20s"),
				},
				DiskEncryptionSetID:     to.StringPtr("/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des"),
				DNSPrefix:               to.StringPtr("dnsprefix1"),
				EnablePodSecurityPolicy: to.BoolPtr(true),
				EnableRBAC:              to.BoolPtr(true),
				HTTPProxyConfig: &ManagedClusterHTTPProxyConfig{
					HTTPProxy:  to.StringPtr("http://myproxy.server.com:8080"),
					HTTPSProxy: to.StringPtr("https://myproxy.server.com:8080"),
					NoProxy: []*string{
						to.StringPtr("localhost"),
						to.StringPtr("127.0.0.1")},
					TrustedCa: to.StringPtr("Q29uZ3JhdHMhIFlvdSBoYXZlIGZvdW5kIGEgaGlkZGVuIG1lc3NhZ2U="),
				},
				KubernetesVersion: to.StringPtr(""),
				LinuxProfile: &ContainerServiceLinuxProfile{
					AdminUsername: to.StringPtr("azureuser"),
					SSH: &ContainerServiceSSHConfiguration{
						PublicKeys: []*ContainerServiceSSHPublicKey{
							{
								KeyData: to.StringPtr("keydata"),
							}},
					},
				},
				NetworkProfile: &ContainerServiceNetworkProfile{
					LoadBalancerProfile: &ManagedClusterLoadBalancerProfile{
						ManagedOutboundIPs: &ManagedClusterLoadBalancerProfileManagedOutboundIPs{
							Count: to.Int32Ptr(2),
						},
					},
					LoadBalancerSKU: LoadBalancerSKUStandard.ToPtr(),
					OutboundType:    OutboundTypeLoadBalancer.ToPtr(),
				},
				ServicePrincipalProfile: &ManagedClusterServicePrincipalProfile{
					ClientID: to.StringPtr("clientid"),
					Secret:   to.StringPtr("secret"),
				},
				WindowsProfile: &ManagedClusterWindowsProfile{
					AdminPassword: to.StringPtr("replacePassword1234$"),
					AdminUsername: to.StringPtr("azureuser"),
				},
			},
			SKU: &ManagedClusterSKU{
				Name: ManagedClusterSKUNameBasic.ToPtr(),
				Tier: ManagedClusterSKUTierFree.ToPtr(),
			},
		},
		&ManagedClustersBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedCluster.ID == nil {
		t.Fatal("ManagedCluster.ID should not be nil!")
	}

	// From example Create Managed Cluster with Node Public IP Prefix
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		ManagedCluster{
			Resource: Resource{
				Location: to.StringPtr("location1"),
				Tags: map[string]*string{
					"archv2": to.StringPtr(""),
					"tier":   to.StringPtr("production"),
				},
			},
			Properties: &ManagedClusterProperties{
				AddonProfiles: map[string]*ManagedClusterAddonProfile{},
				AgentPoolProfiles: []*ManagedClusterAgentPoolProfile{
					{
						ManagedClusterAgentPoolProfileProperties: ManagedClusterAgentPoolProfileProperties{
							Type:                 AgentPoolTypeVirtualMachineScaleSets.ToPtr(),
							Count:                to.Int32Ptr(3),
							EnableNodePublicIP:   to.BoolPtr(true),
							Mode:                 AgentPoolModeSystem.ToPtr(),
							NodePublicIPPrefixID: to.StringPtr("/subscriptions/subid1/resourcegroups/rg1/providers/Microsoft.Network/publicIPPrefixes/public-ip-prefix"),
							OSType:               OSTypeLinux.ToPtr(),
							VMSize:               to.StringPtr("Standard_DS2_v2"),
						},
						Name: to.StringPtr("nodepool1"),
					}},
				AutoScalerProfile: &ManagedClusterPropertiesAutoScalerProfile{
					ScaleDownDelayAfterAdd: to.StringPtr("15m"),
					ScanInterval:           to.StringPtr("20s"),
				},
				DiskEncryptionSetID:     to.StringPtr("/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des"),
				DNSPrefix:               to.StringPtr("dnsprefix1"),
				EnablePodSecurityPolicy: to.BoolPtr(true),
				EnableRBAC:              to.BoolPtr(true),
				KubernetesVersion:       to.StringPtr(""),
				LinuxProfile: &ContainerServiceLinuxProfile{
					AdminUsername: to.StringPtr("azureuser"),
					SSH: &ContainerServiceSSHConfiguration{
						PublicKeys: []*ContainerServiceSSHPublicKey{
							{
								KeyData: to.StringPtr("keydata"),
							}},
					},
				},
				NetworkProfile: &ContainerServiceNetworkProfile{
					LoadBalancerProfile: &ManagedClusterLoadBalancerProfile{
						ManagedOutboundIPs: &ManagedClusterLoadBalancerProfileManagedOutboundIPs{
							Count: to.Int32Ptr(2),
						},
					},
					LoadBalancerSKU: LoadBalancerSKUStandard.ToPtr(),
					OutboundType:    OutboundTypeLoadBalancer.ToPtr(),
				},
				ServicePrincipalProfile: &ManagedClusterServicePrincipalProfile{
					ClientID: to.StringPtr("clientid"),
					Secret:   to.StringPtr("secret"),
				},
				WindowsProfile: &ManagedClusterWindowsProfile{
					AdminPassword: to.StringPtr("replacePassword1234$"),
					AdminUsername: to.StringPtr("azureuser"),
				},
			},
			SKU: &ManagedClusterSKU{
				Name: ManagedClusterSKUNameBasic.ToPtr(),
				Tier: ManagedClusterSKUTierFree.ToPtr(),
			},
		},
		&ManagedClustersBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedCluster.ID == nil {
		t.Fatal("ManagedCluster.ID should not be nil!")
	}

	// From example Create Managed Cluster with OSSKU
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		ManagedCluster{
			Resource: Resource{
				Location: to.StringPtr("location1"),
				Tags: map[string]*string{
					"archv2": to.StringPtr(""),
					"tier":   to.StringPtr("production"),
				},
			},
			Properties: &ManagedClusterProperties{
				AddonProfiles: map[string]*ManagedClusterAddonProfile{},
				AgentPoolProfiles: []*ManagedClusterAgentPoolProfile{
					{
						ManagedClusterAgentPoolProfileProperties: ManagedClusterAgentPoolProfileProperties{
							Type:               AgentPoolTypeVirtualMachineScaleSets.ToPtr(),
							Count:              to.Int32Ptr(3),
							EnableNodePublicIP: to.BoolPtr(true),
							Mode:               AgentPoolModeSystem.ToPtr(),
							OSSKU:              OSSKUCBLMariner.ToPtr(),
							OSType:             OSTypeLinux.ToPtr(),
							VMSize:             to.StringPtr("Standard_DS2_v2"),
						},
						Name: to.StringPtr("nodepool1"),
					}},
				AutoScalerProfile: &ManagedClusterPropertiesAutoScalerProfile{
					ScaleDownDelayAfterAdd: to.StringPtr("15m"),
					ScanInterval:           to.StringPtr("20s"),
				},
				DiskEncryptionSetID:     to.StringPtr("/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des"),
				DNSPrefix:               to.StringPtr("dnsprefix1"),
				EnablePodSecurityPolicy: to.BoolPtr(true),
				EnableRBAC:              to.BoolPtr(true),
				HTTPProxyConfig: &ManagedClusterHTTPProxyConfig{
					HTTPProxy:  to.StringPtr("http://myproxy.server.com:8080"),
					HTTPSProxy: to.StringPtr("https://myproxy.server.com:8080"),
					NoProxy: []*string{
						to.StringPtr("localhost"),
						to.StringPtr("127.0.0.1")},
					TrustedCa: to.StringPtr("Q29uZ3JhdHMhIFlvdSBoYXZlIGZvdW5kIGEgaGlkZGVuIG1lc3NhZ2U="),
				},
				KubernetesVersion: to.StringPtr(""),
				LinuxProfile: &ContainerServiceLinuxProfile{
					AdminUsername: to.StringPtr("azureuser"),
					SSH: &ContainerServiceSSHConfiguration{
						PublicKeys: []*ContainerServiceSSHPublicKey{
							{
								KeyData: to.StringPtr("keydata"),
							}},
					},
				},
				NetworkProfile: &ContainerServiceNetworkProfile{
					LoadBalancerProfile: &ManagedClusterLoadBalancerProfile{
						ManagedOutboundIPs: &ManagedClusterLoadBalancerProfileManagedOutboundIPs{
							Count: to.Int32Ptr(2),
						},
					},
					LoadBalancerSKU: LoadBalancerSKUStandard.ToPtr(),
					OutboundType:    OutboundTypeLoadBalancer.ToPtr(),
				},
				ServicePrincipalProfile: &ManagedClusterServicePrincipalProfile{
					ClientID: to.StringPtr("clientid"),
					Secret:   to.StringPtr("secret"),
				},
				WindowsProfile: &ManagedClusterWindowsProfile{
					AdminPassword: to.StringPtr("replacePassword1234$"),
					AdminUsername: to.StringPtr("azureuser"),
				},
			},
			SKU: &ManagedClusterSKU{
				Name: ManagedClusterSKUNameBasic.ToPtr(),
				Tier: ManagedClusterSKUTierFree.ToPtr(),
			},
		},
		&ManagedClustersBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedCluster.ID == nil {
		t.Fatal("ManagedCluster.ID should not be nil!")
	}

	// From example Create Managed Cluster with PPG
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		ManagedCluster{
			Resource: Resource{
				Location: to.StringPtr("location1"),
				Tags: map[string]*string{
					"archv2": to.StringPtr(""),
					"tier":   to.StringPtr("production"),
				},
			},
			Properties: &ManagedClusterProperties{
				AddonProfiles: map[string]*ManagedClusterAddonProfile{},
				AgentPoolProfiles: []*ManagedClusterAgentPoolProfile{
					{
						ManagedClusterAgentPoolProfileProperties: ManagedClusterAgentPoolProfileProperties{
							Type:                      AgentPoolTypeVirtualMachineScaleSets.ToPtr(),
							Count:                     to.Int32Ptr(3),
							EnableNodePublicIP:        to.BoolPtr(true),
							Mode:                      AgentPoolModeSystem.ToPtr(),
							OSType:                    OSTypeLinux.ToPtr(),
							ProximityPlacementGroupID: to.StringPtr("/subscriptions/subid1/resourcegroups/rg1/providers//Microsoft.Compute/proximityPlacementGroups/ppg1"),
							VMSize:                    to.StringPtr("Standard_DS2_v2"),
						},
						Name: to.StringPtr("nodepool1"),
					}},
				AutoScalerProfile: &ManagedClusterPropertiesAutoScalerProfile{
					ScaleDownDelayAfterAdd: to.StringPtr("15m"),
					ScanInterval:           to.StringPtr("20s"),
				},
				DiskEncryptionSetID:     to.StringPtr("/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des"),
				DNSPrefix:               to.StringPtr("dnsprefix1"),
				EnablePodSecurityPolicy: to.BoolPtr(true),
				EnableRBAC:              to.BoolPtr(true),
				KubernetesVersion:       to.StringPtr(""),
				LinuxProfile: &ContainerServiceLinuxProfile{
					AdminUsername: to.StringPtr("azureuser"),
					SSH: &ContainerServiceSSHConfiguration{
						PublicKeys: []*ContainerServiceSSHPublicKey{
							{
								KeyData: to.StringPtr("keydata"),
							}},
					},
				},
				NetworkProfile: &ContainerServiceNetworkProfile{
					LoadBalancerProfile: &ManagedClusterLoadBalancerProfile{
						ManagedOutboundIPs: &ManagedClusterLoadBalancerProfileManagedOutboundIPs{
							Count: to.Int32Ptr(2),
						},
					},
					LoadBalancerSKU: LoadBalancerSKUStandard.ToPtr(),
					OutboundType:    OutboundTypeLoadBalancer.ToPtr(),
				},
				ServicePrincipalProfile: &ManagedClusterServicePrincipalProfile{
					ClientID: to.StringPtr("clientid"),
					Secret:   to.StringPtr("secret"),
				},
				WindowsProfile: &ManagedClusterWindowsProfile{
					AdminPassword: to.StringPtr("replacePassword1234$"),
					AdminUsername: to.StringPtr("azureuser"),
				},
			},
			SKU: &ManagedClusterSKU{
				Name: ManagedClusterSKUNameBasic.ToPtr(),
				Tier: ManagedClusterSKUTierFree.ToPtr(),
			},
		},
		&ManagedClustersBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedCluster.ID == nil {
		t.Fatal("ManagedCluster.ID should not be nil!")
	}

	// From example Create Managed Cluster with PodIdentity enabled
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		ManagedCluster{
			Resource: Resource{
				Location: to.StringPtr("location1"),
				Tags: map[string]*string{
					"archv2": to.StringPtr(""),
					"tier":   to.StringPtr("production"),
				},
			},
			Properties: &ManagedClusterProperties{
				AddonProfiles: map[string]*ManagedClusterAddonProfile{},
				AgentPoolProfiles: []*ManagedClusterAgentPoolProfile{
					{
						ManagedClusterAgentPoolProfileProperties: ManagedClusterAgentPoolProfileProperties{
							Type:               AgentPoolTypeVirtualMachineScaleSets.ToPtr(),
							Count:              to.Int32Ptr(3),
							EnableNodePublicIP: to.BoolPtr(true),
							Mode:               AgentPoolModeSystem.ToPtr(),
							OSType:             OSTypeLinux.ToPtr(),
							VMSize:             to.StringPtr("Standard_DS2_v2"),
						},
						Name: to.StringPtr("nodepool1"),
					}},
				AutoScalerProfile: &ManagedClusterPropertiesAutoScalerProfile{
					ScaleDownDelayAfterAdd: to.StringPtr("15m"),
					ScanInterval:           to.StringPtr("20s"),
				},
				DiskEncryptionSetID:     to.StringPtr("/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des"),
				DNSPrefix:               to.StringPtr("dnsprefix1"),
				EnablePodSecurityPolicy: to.BoolPtr(true),
				EnableRBAC:              to.BoolPtr(true),
				KubernetesVersion:       to.StringPtr(""),
				LinuxProfile: &ContainerServiceLinuxProfile{
					AdminUsername: to.StringPtr("azureuser"),
					SSH: &ContainerServiceSSHConfiguration{
						PublicKeys: []*ContainerServiceSSHPublicKey{
							{
								KeyData: to.StringPtr("keydata"),
							}},
					},
				},
				NetworkProfile: &ContainerServiceNetworkProfile{
					LoadBalancerProfile: &ManagedClusterLoadBalancerProfile{
						ManagedOutboundIPs: &ManagedClusterLoadBalancerProfileManagedOutboundIPs{
							Count: to.Int32Ptr(2),
						},
					},
					LoadBalancerSKU: LoadBalancerSKUStandard.ToPtr(),
					OutboundType:    OutboundTypeLoadBalancer.ToPtr(),
				},
				PodIdentityProfile: &ManagedClusterPodIdentityProfile{
					AllowNetworkPluginKubenet: to.BoolPtr(true),
					Enabled:                   to.BoolPtr(true),
				},
				ServicePrincipalProfile: &ManagedClusterServicePrincipalProfile{
					ClientID: to.StringPtr("clientid"),
					Secret:   to.StringPtr("secret"),
				},
				WindowsProfile: &ManagedClusterWindowsProfile{
					AdminPassword: to.StringPtr("replacePassword1234$"),
					AdminUsername: to.StringPtr("azureuser"),
				},
			},
			SKU: &ManagedClusterSKU{
				Name: ManagedClusterSKUNameBasic.ToPtr(),
				Tier: ManagedClusterSKUTierFree.ToPtr(),
			},
		},
		&ManagedClustersBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedCluster.ID == nil {
		t.Fatal("ManagedCluster.ID should not be nil!")
	}

	// From example Create Managed Cluster with RunCommand disabled
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		ManagedCluster{
			Resource: Resource{
				Location: to.StringPtr("location1"),
				Tags: map[string]*string{
					"archv2": to.StringPtr(""),
					"tier":   to.StringPtr("production"),
				},
			},
			Properties: &ManagedClusterProperties{
				AddonProfiles: map[string]*ManagedClusterAddonProfile{},
				AgentPoolProfiles: []*ManagedClusterAgentPoolProfile{
					{
						ManagedClusterAgentPoolProfileProperties: ManagedClusterAgentPoolProfileProperties{
							Type:                   AgentPoolTypeVirtualMachineScaleSets.ToPtr(),
							Count:                  to.Int32Ptr(3),
							EnableEncryptionAtHost: to.BoolPtr(true),
							EnableNodePublicIP:     to.BoolPtr(true),
							Mode:                   AgentPoolModeSystem.ToPtr(),
							OSType:                 OSTypeLinux.ToPtr(),
							VMSize:                 to.StringPtr("Standard_DS2_v2"),
						},
						Name: to.StringPtr("nodepool1"),
					}},
				APIServerAccessProfile: &ManagedClusterAPIServerAccessProfile{
					DisableRunCommand: to.BoolPtr(true),
				},
				AutoScalerProfile: &ManagedClusterPropertiesAutoScalerProfile{
					ScaleDownDelayAfterAdd: to.StringPtr("15m"),
					ScanInterval:           to.StringPtr("20s"),
				},
				DNSPrefix:               to.StringPtr("dnsprefix1"),
				EnablePodSecurityPolicy: to.BoolPtr(true),
				EnableRBAC:              to.BoolPtr(true),
				KubernetesVersion:       to.StringPtr(""),
				LinuxProfile: &ContainerServiceLinuxProfile{
					AdminUsername: to.StringPtr("azureuser"),
					SSH: &ContainerServiceSSHConfiguration{
						PublicKeys: []*ContainerServiceSSHPublicKey{
							{
								KeyData: to.StringPtr("keydata"),
							}},
					},
				},
				NetworkProfile: &ContainerServiceNetworkProfile{
					LoadBalancerProfile: &ManagedClusterLoadBalancerProfile{
						ManagedOutboundIPs: &ManagedClusterLoadBalancerProfileManagedOutboundIPs{
							Count: to.Int32Ptr(2),
						},
					},
					LoadBalancerSKU: LoadBalancerSKUStandard.ToPtr(),
					OutboundType:    OutboundTypeLoadBalancer.ToPtr(),
				},
				ServicePrincipalProfile: &ManagedClusterServicePrincipalProfile{
					ClientID: to.StringPtr("clientid"),
					Secret:   to.StringPtr("secret"),
				},
				WindowsProfile: &ManagedClusterWindowsProfile{
					AdminPassword: to.StringPtr("replacePassword1234$"),
					AdminUsername: to.StringPtr("azureuser"),
				},
			},
			SKU: &ManagedClusterSKU{
				Name: ManagedClusterSKUNameBasic.ToPtr(),
				Tier: ManagedClusterSKUTierFree.ToPtr(),
			},
		},
		&ManagedClustersBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedCluster.ID == nil {
		t.Fatal("ManagedCluster.ID should not be nil!")
	}

	// From example Create Managed Cluster with Security Profile configured
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		ManagedCluster{
			Resource: Resource{
				Location: to.StringPtr("location1"),
				Tags: map[string]*string{
					"archv2": to.StringPtr(""),
					"tier":   to.StringPtr("production"),
				},
			},
			Properties: &ManagedClusterProperties{
				AgentPoolProfiles: []*ManagedClusterAgentPoolProfile{
					{
						ManagedClusterAgentPoolProfileProperties: ManagedClusterAgentPoolProfileProperties{
							Type:               AgentPoolTypeVirtualMachineScaleSets.ToPtr(),
							Count:              to.Int32Ptr(3),
							EnableNodePublicIP: to.BoolPtr(true),
							Mode:               AgentPoolModeSystem.ToPtr(),
							OSType:             OSTypeLinux.ToPtr(),
							VMSize:             to.StringPtr("Standard_DS2_v2"),
						},
						Name: to.StringPtr("nodepool1"),
					}},
				DNSPrefix:         to.StringPtr("dnsprefix1"),
				KubernetesVersion: to.StringPtr(""),
				LinuxProfile: &ContainerServiceLinuxProfile{
					AdminUsername: to.StringPtr("azureuser"),
					SSH: &ContainerServiceSSHConfiguration{
						PublicKeys: []*ContainerServiceSSHPublicKey{
							{
								KeyData: to.StringPtr("keydata"),
							}},
					},
				},
				NetworkProfile: &ContainerServiceNetworkProfile{
					LoadBalancerProfile: &ManagedClusterLoadBalancerProfile{
						ManagedOutboundIPs: &ManagedClusterLoadBalancerProfileManagedOutboundIPs{
							Count: to.Int32Ptr(2),
						},
					},
					LoadBalancerSKU: LoadBalancerSKUStandard.ToPtr(),
					OutboundType:    OutboundTypeLoadBalancer.ToPtr(),
				},
				SecurityProfile: &ManagedClusterSecurityProfile{
					AzureDefender: &ManagedClusterSecurityProfileAzureDefender{
						Enabled:                         to.BoolPtr(true),
						LogAnalyticsWorkspaceResourceID: to.StringPtr("/subscriptions/SUB_ID/resourcegroups/RG_NAME/providers/microsoft.operationalinsights/workspaces/WORKSPACE_NAME"),
					},
				},
			},
			SKU: &ManagedClusterSKU{
				Name: ManagedClusterSKUNameBasic.ToPtr(),
				Tier: ManagedClusterSKUTierFree.ToPtr(),
			},
		},
		&ManagedClustersBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedCluster.ID == nil {
		t.Fatal("ManagedCluster.ID should not be nil!")
	}

	// From example Create Managed Cluster with UltraSSD enabled
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		ManagedCluster{
			Resource: Resource{
				Location: to.StringPtr("location1"),
				Tags: map[string]*string{
					"archv2": to.StringPtr(""),
					"tier":   to.StringPtr("production"),
				},
			},
			Properties: &ManagedClusterProperties{
				AddonProfiles: map[string]*ManagedClusterAddonProfile{},
				AgentPoolProfiles: []*ManagedClusterAgentPoolProfile{
					{
						ManagedClusterAgentPoolProfileProperties: ManagedClusterAgentPoolProfileProperties{
							Type:               AgentPoolTypeVirtualMachineScaleSets.ToPtr(),
							Count:              to.Int32Ptr(3),
							EnableNodePublicIP: to.BoolPtr(true),
							EnableUltraSSD:     to.BoolPtr(true),
							Mode:               AgentPoolModeSystem.ToPtr(),
							OSType:             OSTypeLinux.ToPtr(),
							VMSize:             to.StringPtr("Standard_DS2_v2"),
						},
						Name: to.StringPtr("nodepool1"),
					}},
				AutoScalerProfile: &ManagedClusterPropertiesAutoScalerProfile{
					ScaleDownDelayAfterAdd: to.StringPtr("15m"),
					ScanInterval:           to.StringPtr("20s"),
				},
				DiskEncryptionSetID:     to.StringPtr("/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des"),
				DNSPrefix:               to.StringPtr("dnsprefix1"),
				EnablePodSecurityPolicy: to.BoolPtr(true),
				EnableRBAC:              to.BoolPtr(true),
				KubernetesVersion:       to.StringPtr(""),
				LinuxProfile: &ContainerServiceLinuxProfile{
					AdminUsername: to.StringPtr("azureuser"),
					SSH: &ContainerServiceSSHConfiguration{
						PublicKeys: []*ContainerServiceSSHPublicKey{
							{
								KeyData: to.StringPtr("keydata"),
							}},
					},
				},
				NetworkProfile: &ContainerServiceNetworkProfile{
					LoadBalancerProfile: &ManagedClusterLoadBalancerProfile{
						ManagedOutboundIPs: &ManagedClusterLoadBalancerProfileManagedOutboundIPs{
							Count: to.Int32Ptr(2),
						},
					},
					LoadBalancerSKU: LoadBalancerSKUStandard.ToPtr(),
					OutboundType:    OutboundTypeLoadBalancer.ToPtr(),
				},
				ServicePrincipalProfile: &ManagedClusterServicePrincipalProfile{
					ClientID: to.StringPtr("clientid"),
					Secret:   to.StringPtr("secret"),
				},
				WindowsProfile: &ManagedClusterWindowsProfile{
					AdminPassword: to.StringPtr("replacePassword1234$"),
					AdminUsername: to.StringPtr("azureuser"),
				},
			},
			SKU: &ManagedClusterSKU{
				Name: ManagedClusterSKUNameBasic.ToPtr(),
				Tier: ManagedClusterSKUTierFree.ToPtr(),
			},
		},
		&ManagedClustersBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedCluster.ID == nil {
		t.Fatal("ManagedCluster.ID should not be nil!")
	}

	// From example Create Managed Cluster with user-assigned NAT gateway as outbound type
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		ManagedCluster{
			Resource: Resource{
				Location: to.StringPtr("location1"),
				Tags: map[string]*string{
					"archv2": to.StringPtr(""),
					"tier":   to.StringPtr("production"),
				},
			},
			Properties: &ManagedClusterProperties{
				AddonProfiles: map[string]*ManagedClusterAddonProfile{},
				AgentPoolProfiles: []*ManagedClusterAgentPoolProfile{
					{
						ManagedClusterAgentPoolProfileProperties: ManagedClusterAgentPoolProfileProperties{
							Type:               AgentPoolTypeVirtualMachineScaleSets.ToPtr(),
							Count:              to.Int32Ptr(3),
							EnableNodePublicIP: to.BoolPtr(false),
							Mode:               AgentPoolModeSystem.ToPtr(),
							OSType:             OSTypeLinux.ToPtr(),
							VMSize:             to.StringPtr("Standard_DS2_v2"),
						},
						Name: to.StringPtr("nodepool1"),
					}},
				AutoScalerProfile: &ManagedClusterPropertiesAutoScalerProfile{
					ScaleDownDelayAfterAdd: to.StringPtr("15m"),
					ScanInterval:           to.StringPtr("20s"),
				},
				DiskEncryptionSetID:     to.StringPtr("/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des"),
				DNSPrefix:               to.StringPtr("dnsprefix1"),
				EnablePodSecurityPolicy: to.BoolPtr(true),
				EnableRBAC:              to.BoolPtr(true),
				KubernetesVersion:       to.StringPtr(""),
				LinuxProfile: &ContainerServiceLinuxProfile{
					AdminUsername: to.StringPtr("azureuser"),
					SSH: &ContainerServiceSSHConfiguration{
						PublicKeys: []*ContainerServiceSSHPublicKey{
							{
								KeyData: to.StringPtr("keydata"),
							}},
					},
				},
				NetworkProfile: &ContainerServiceNetworkProfile{
					LoadBalancerSKU: LoadBalancerSKUStandard.ToPtr(),
					OutboundType:    OutboundTypeUserAssignedNATGateway.ToPtr(),
				},
				ServicePrincipalProfile: &ManagedClusterServicePrincipalProfile{
					ClientID: to.StringPtr("clientid"),
					Secret:   to.StringPtr("secret"),
				},
				WindowsProfile: &ManagedClusterWindowsProfile{
					AdminPassword: to.StringPtr("replacePassword1234$"),
					AdminUsername: to.StringPtr("azureuser"),
				},
			},
			SKU: &ManagedClusterSKU{
				Name: ManagedClusterSKUNameBasic.ToPtr(),
				Tier: ManagedClusterSKUTierFree.ToPtr(),
			},
		},
		&ManagedClustersBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedCluster.ID == nil {
		t.Fatal("ManagedCluster.ID should not be nil!")
	}

	// From example Create Managed Private Cluster with Public FQDN specified
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		ManagedCluster{
			Resource: Resource{
				Location: to.StringPtr("location1"),
				Tags: map[string]*string{
					"archv2": to.StringPtr(""),
					"tier":   to.StringPtr("production"),
				},
			},
			Properties: &ManagedClusterProperties{
				AddonProfiles: map[string]*ManagedClusterAddonProfile{},
				AgentPoolProfiles: []*ManagedClusterAgentPoolProfile{
					{
						ManagedClusterAgentPoolProfileProperties: ManagedClusterAgentPoolProfileProperties{
							Type:                   AgentPoolTypeVirtualMachineScaleSets.ToPtr(),
							Count:                  to.Int32Ptr(3),
							EnableEncryptionAtHost: to.BoolPtr(true),
							EnableNodePublicIP:     to.BoolPtr(true),
							Mode:                   AgentPoolModeSystem.ToPtr(),
							OSType:                 OSTypeLinux.ToPtr(),
							VMSize:                 to.StringPtr("Standard_DS2_v2"),
						},
						Name: to.StringPtr("nodepool1"),
					}},
				APIServerAccessProfile: &ManagedClusterAPIServerAccessProfile{
					EnablePrivateCluster:           to.BoolPtr(true),
					EnablePrivateClusterPublicFQDN: to.BoolPtr(true),
				},
				AutoScalerProfile: &ManagedClusterPropertiesAutoScalerProfile{
					ScaleDownDelayAfterAdd: to.StringPtr("15m"),
					ScanInterval:           to.StringPtr("20s"),
				},
				DNSPrefix:               to.StringPtr("dnsprefix1"),
				EnablePodSecurityPolicy: to.BoolPtr(true),
				EnableRBAC:              to.BoolPtr(true),
				KubernetesVersion:       to.StringPtr(""),
				LinuxProfile: &ContainerServiceLinuxProfile{
					AdminUsername: to.StringPtr("azureuser"),
					SSH: &ContainerServiceSSHConfiguration{
						PublicKeys: []*ContainerServiceSSHPublicKey{
							{
								KeyData: to.StringPtr("keydata"),
							}},
					},
				},
				NetworkProfile: &ContainerServiceNetworkProfile{
					LoadBalancerProfile: &ManagedClusterLoadBalancerProfile{
						ManagedOutboundIPs: &ManagedClusterLoadBalancerProfileManagedOutboundIPs{
							Count: to.Int32Ptr(2),
						},
					},
					LoadBalancerSKU: LoadBalancerSKUStandard.ToPtr(),
					OutboundType:    OutboundTypeLoadBalancer.ToPtr(),
				},
				ServicePrincipalProfile: &ManagedClusterServicePrincipalProfile{
					ClientID: to.StringPtr("clientid"),
					Secret:   to.StringPtr("secret"),
				},
				WindowsProfile: &ManagedClusterWindowsProfile{
					AdminPassword: to.StringPtr("replacePassword1234$"),
					AdminUsername: to.StringPtr("azureuser"),
				},
			},
			SKU: &ManagedClusterSKU{
				Name: ManagedClusterSKUNameBasic.ToPtr(),
				Tier: ManagedClusterSKUTierFree.ToPtr(),
			},
		},
		&ManagedClustersBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedCluster.ID == nil {
		t.Fatal("ManagedCluster.ID should not be nil!")
	}

	// From example Create Managed Private Cluster with fqdn subdomain specified
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		ManagedCluster{
			Resource: Resource{
				Location: to.StringPtr("location1"),
				Tags: map[string]*string{
					"archv2": to.StringPtr(""),
					"tier":   to.StringPtr("production"),
				},
			},
			Properties: &ManagedClusterProperties{
				AddonProfiles: map[string]*ManagedClusterAddonProfile{},
				AgentPoolProfiles: []*ManagedClusterAgentPoolProfile{
					{
						ManagedClusterAgentPoolProfileProperties: ManagedClusterAgentPoolProfileProperties{
							Type:                   AgentPoolTypeVirtualMachineScaleSets.ToPtr(),
							Count:                  to.Int32Ptr(3),
							EnableEncryptionAtHost: to.BoolPtr(true),
							EnableNodePublicIP:     to.BoolPtr(true),
							Mode:                   AgentPoolModeSystem.ToPtr(),
							OSType:                 OSTypeLinux.ToPtr(),
							VMSize:                 to.StringPtr("Standard_DS2_v2"),
						},
						Name: to.StringPtr("nodepool1"),
					}},
				APIServerAccessProfile: &ManagedClusterAPIServerAccessProfile{
					EnablePrivateCluster: to.BoolPtr(true),
					PrivateDNSZone:       to.StringPtr("/subscriptions/subid1/resourcegroups/rg1/providers/Microsoft.Network/privateDnsZones/privatelink.location1.azmk8s.io"),
				},
				AutoScalerProfile: &ManagedClusterPropertiesAutoScalerProfile{
					ScaleDownDelayAfterAdd: to.StringPtr("15m"),
					ScanInterval:           to.StringPtr("20s"),
				},
				EnablePodSecurityPolicy: to.BoolPtr(true),
				EnableRBAC:              to.BoolPtr(true),
				FqdnSubdomain:           to.StringPtr("domain1"),
				KubernetesVersion:       to.StringPtr(""),
				LinuxProfile: &ContainerServiceLinuxProfile{
					AdminUsername: to.StringPtr("azureuser"),
					SSH: &ContainerServiceSSHConfiguration{
						PublicKeys: []*ContainerServiceSSHPublicKey{
							{
								KeyData: to.StringPtr("keydata"),
							}},
					},
				},
				NetworkProfile: &ContainerServiceNetworkProfile{
					LoadBalancerProfile: &ManagedClusterLoadBalancerProfile{
						ManagedOutboundIPs: &ManagedClusterLoadBalancerProfileManagedOutboundIPs{
							Count: to.Int32Ptr(2),
						},
					},
					LoadBalancerSKU: LoadBalancerSKUStandard.ToPtr(),
					OutboundType:    OutboundTypeLoadBalancer.ToPtr(),
				},
				ServicePrincipalProfile: &ManagedClusterServicePrincipalProfile{
					ClientID: to.StringPtr("clientid"),
					Secret:   to.StringPtr("secret"),
				},
				WindowsProfile: &ManagedClusterWindowsProfile{
					AdminPassword: to.StringPtr("replacePassword1234$"),
					AdminUsername: to.StringPtr("azureuser"),
				},
			},
			SKU: &ManagedClusterSKU{
				Name: ManagedClusterSKUNameBasic.ToPtr(),
				Tier: ManagedClusterSKUTierFree.ToPtr(),
			},
		},
		&ManagedClustersBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedCluster.ID == nil {
		t.Fatal("ManagedCluster.ID should not be nil!")
	}

	// From example Create/Update AAD Managed Cluster with EnableAzureRBAC
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		ManagedCluster{
			Resource: Resource{
				Location: to.StringPtr("location1"),
				Tags: map[string]*string{
					"archv2": to.StringPtr(""),
					"tier":   to.StringPtr("production"),
				},
			},
			Properties: &ManagedClusterProperties{
				AADProfile: &ManagedClusterAADProfile{
					EnableAzureRBAC: to.BoolPtr(true),
					Managed:         to.BoolPtr(true),
				},
				AddonProfiles: map[string]*ManagedClusterAddonProfile{},
				AgentPoolProfiles: []*ManagedClusterAgentPoolProfile{
					{
						ManagedClusterAgentPoolProfileProperties: ManagedClusterAgentPoolProfileProperties{
							Type: AgentPoolTypeVirtualMachineScaleSets.ToPtr(),
							AvailabilityZones: []*string{
								to.StringPtr("1"),
								to.StringPtr("2"),
								to.StringPtr("3")},
							Count:              to.Int32Ptr(3),
							EnableNodePublicIP: to.BoolPtr(true),
							Mode:               AgentPoolModeSystem.ToPtr(),
							OSType:             OSTypeLinux.ToPtr(),
							VMSize:             to.StringPtr("Standard_DS1_v2"),
						},
						Name: to.StringPtr("nodepool1"),
					}},
				AutoScalerProfile: &ManagedClusterPropertiesAutoScalerProfile{
					ScaleDownDelayAfterAdd: to.StringPtr("15m"),
					ScanInterval:           to.StringPtr("20s"),
				},
				DiskEncryptionSetID:     to.StringPtr("/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des"),
				DNSPrefix:               to.StringPtr("dnsprefix1"),
				EnablePodSecurityPolicy: to.BoolPtr(true),
				EnableRBAC:              to.BoolPtr(true),
				KubernetesVersion:       to.StringPtr(""),
				LinuxProfile: &ContainerServiceLinuxProfile{
					AdminUsername: to.StringPtr("azureuser"),
					SSH: &ContainerServiceSSHConfiguration{
						PublicKeys: []*ContainerServiceSSHPublicKey{
							{
								KeyData: to.StringPtr("keydata"),
							}},
					},
				},
				NetworkProfile: &ContainerServiceNetworkProfile{
					LoadBalancerProfile: &ManagedClusterLoadBalancerProfile{
						ManagedOutboundIPs: &ManagedClusterLoadBalancerProfileManagedOutboundIPs{
							Count: to.Int32Ptr(2),
						},
					},
					LoadBalancerSKU: LoadBalancerSKUStandard.ToPtr(),
					OutboundType:    OutboundTypeLoadBalancer.ToPtr(),
				},
				ServicePrincipalProfile: &ManagedClusterServicePrincipalProfile{
					ClientID: to.StringPtr("clientid"),
					Secret:   to.StringPtr("secret"),
				},
				WindowsProfile: &ManagedClusterWindowsProfile{
					AdminPassword: to.StringPtr("replacePassword1234$"),
					AdminUsername: to.StringPtr("azureuser"),
				},
			},
			SKU: &ManagedClusterSKU{
				Name: ManagedClusterSKUNameBasic.ToPtr(),
				Tier: ManagedClusterSKUTierFree.ToPtr(),
			},
		},
		&ManagedClustersBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedCluster.ID == nil {
		t.Fatal("ManagedCluster.ID should not be nil!")
	}

	// From example Create/Update Managed Cluster
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		ManagedCluster{
			Resource: Resource{
				Location: to.StringPtr("location1"),
				Tags: map[string]*string{
					"archv2": to.StringPtr(""),
					"tier":   to.StringPtr("production"),
				},
			},
			Identity: &ManagedClusterIdentity{
				Type: ResourceIdentityTypeUserAssigned.ToPtr(),
				UserAssignedIdentities: map[string]*ManagedServiceIdentityUserAssignedIdentitiesValue{
					"/subscriptions/subid1/resourceGroups/rgName1/providers/Microsoft.ManagedIdentity/userAssignedIdentities/identity1": &ManagedServiceIdentityUserAssignedIdentitiesValue{},
				},
			},
			Properties: &ManagedClusterProperties{
				AddonProfiles: map[string]*ManagedClusterAddonProfile{},
				AgentPoolProfiles: []*ManagedClusterAgentPoolProfile{
					{
						ManagedClusterAgentPoolProfileProperties: ManagedClusterAgentPoolProfileProperties{
							Type: AgentPoolTypeVirtualMachineScaleSets.ToPtr(),
							AvailabilityZones: []*string{
								to.StringPtr("1"),
								to.StringPtr("2"),
								to.StringPtr("3")},
							Count:              to.Int32Ptr(3),
							EnableNodePublicIP: to.BoolPtr(true),
							Mode:               AgentPoolModeSystem.ToPtr(),
							OSType:             OSTypeLinux.ToPtr(),
							ScaleDownMode:      ScaleDownModeDeallocate.ToPtr(),
							VMSize:             to.StringPtr("Standard_DS1_v2"),
						},
						Name: to.StringPtr("nodepool1"),
					}},
				AutoScalerProfile: &ManagedClusterPropertiesAutoScalerProfile{
					BalanceSimilarNodeGroups: to.StringPtr("true"),
					Expander:                 ExpanderPriority.ToPtr(),
					MaxNodeProvisionTime:     to.StringPtr("15m"),
					NewPodScaleUpDelay:       to.StringPtr("1m"),
					ScaleDownDelayAfterAdd:   to.StringPtr("15m"),
					ScanInterval:             to.StringPtr("20s"),
					SkipNodesWithSystemPods:  to.StringPtr("false"),
				},
				DiskEncryptionSetID:     to.StringPtr("/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des"),
				DNSPrefix:               to.StringPtr("dnsprefix1"),
				EnablePodSecurityPolicy: to.BoolPtr(true),
				EnableRBAC:              to.BoolPtr(true),
				KubernetesVersion:       to.StringPtr(""),
				LinuxProfile: &ContainerServiceLinuxProfile{
					AdminUsername: to.StringPtr("azureuser"),
					SSH: &ContainerServiceSSHConfiguration{
						PublicKeys: []*ContainerServiceSSHPublicKey{
							{
								KeyData: to.StringPtr("keydata"),
							}},
					},
				},
				NetworkProfile: &ContainerServiceNetworkProfile{
					LoadBalancerProfile: &ManagedClusterLoadBalancerProfile{
						ManagedOutboundIPs: &ManagedClusterLoadBalancerProfileManagedOutboundIPs{
							Count: to.Int32Ptr(2),
						},
					},
					LoadBalancerSKU: LoadBalancerSKUStandard.ToPtr(),
					OutboundType:    OutboundTypeLoadBalancer.ToPtr(),
				},
				ServicePrincipalProfile: &ManagedClusterServicePrincipalProfile{
					ClientID: to.StringPtr("clientid"),
					Secret:   to.StringPtr("secret"),
				},
				WindowsProfile: &ManagedClusterWindowsProfile{
					AdminPassword: to.StringPtr("replacePassword1234$"),
					AdminUsername: to.StringPtr("azureuser"),
				},
			},
			SKU: &ManagedClusterSKU{
				Name: ManagedClusterSKUNameBasic.ToPtr(),
				Tier: ManagedClusterSKUTierFree.ToPtr(),
			},
		},
		&ManagedClustersBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedCluster.ID == nil {
		t.Fatal("ManagedCluster.ID should not be nil!")
	}

	// From example Create/Update Managed Cluster with EnableAHUB
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		ManagedCluster{
			Resource: Resource{
				Location: to.StringPtr("location1"),
				Tags: map[string]*string{
					"archv2": to.StringPtr(""),
					"tier":   to.StringPtr("production"),
				},
			},
			Identity: &ManagedClusterIdentity{
				Type: ResourceIdentityTypeUserAssigned.ToPtr(),
				UserAssignedIdentities: map[string]*ManagedServiceIdentityUserAssignedIdentitiesValue{
					"/subscriptions/subid1/resourceGroups/rgName1/providers/Microsoft.ManagedIdentity/userAssignedIdentities/identity1": &ManagedServiceIdentityUserAssignedIdentitiesValue{},
				},
			},
			Properties: &ManagedClusterProperties{
				AddonProfiles: map[string]*ManagedClusterAddonProfile{},
				AgentPoolProfiles: []*ManagedClusterAgentPoolProfile{
					{
						ManagedClusterAgentPoolProfileProperties: ManagedClusterAgentPoolProfileProperties{
							Type: AgentPoolTypeVirtualMachineScaleSets.ToPtr(),
							AvailabilityZones: []*string{
								to.StringPtr("1"),
								to.StringPtr("2"),
								to.StringPtr("3")},
							Count:              to.Int32Ptr(3),
							EnableNodePublicIP: to.BoolPtr(true),
							Mode:               AgentPoolModeSystem.ToPtr(),
							OSType:             OSTypeLinux.ToPtr(),
							VMSize:             to.StringPtr("Standard_DS1_v2"),
						},
						Name: to.StringPtr("nodepool1"),
					}},
				AutoScalerProfile: &ManagedClusterPropertiesAutoScalerProfile{
					ScaleDownDelayAfterAdd: to.StringPtr("15m"),
					ScanInterval:           to.StringPtr("20s"),
				},
				DiskEncryptionSetID:     to.StringPtr("/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.Compute/diskEncryptionSets/des"),
				DNSPrefix:               to.StringPtr("dnsprefix1"),
				EnablePodSecurityPolicy: to.BoolPtr(true),
				EnableRBAC:              to.BoolPtr(true),
				KubernetesVersion:       to.StringPtr(""),
				LinuxProfile: &ContainerServiceLinuxProfile{
					AdminUsername: to.StringPtr("azureuser"),
					SSH: &ContainerServiceSSHConfiguration{
						PublicKeys: []*ContainerServiceSSHPublicKey{
							{
								KeyData: to.StringPtr("keydata"),
							}},
					},
				},
				NetworkProfile: &ContainerServiceNetworkProfile{
					LoadBalancerProfile: &ManagedClusterLoadBalancerProfile{
						ManagedOutboundIPs: &ManagedClusterLoadBalancerProfileManagedOutboundIPs{
							Count: to.Int32Ptr(2),
						},
					},
					LoadBalancerSKU: LoadBalancerSKUStandard.ToPtr(),
					OutboundType:    OutboundTypeLoadBalancer.ToPtr(),
				},
				ServicePrincipalProfile: &ManagedClusterServicePrincipalProfile{
					ClientID: to.StringPtr("clientid"),
					Secret:   to.StringPtr("secret"),
				},
				WindowsProfile: &ManagedClusterWindowsProfile{
					AdminPassword: to.StringPtr("replacePassword1234$"),
					AdminUsername: to.StringPtr("azureuser"),
					LicenseType:   LicenseTypeWindowsServer.ToPtr(),
				},
			},
			SKU: &ManagedClusterSKU{
				Name: ManagedClusterSKUNameBasic.ToPtr(),
				Tier: ManagedClusterSKUTierFree.ToPtr(),
			},
		},
		&ManagedClustersBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedCluster.ID == nil {
		t.Fatal("ManagedCluster.ID should not be nil!")
	}
}

func TestManagedClusters_UpdateTags(t *testing.T) {
	// From example Update Managed Cluster Tags
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewManagedClustersClient(con,
		"subid1")
	poller, err := client.BeginUpdateTags(ctx,
		"rg1",
		"clustername1",
		TagsObject{
			Tags: map[string]*string{
				"archv3": to.StringPtr(""),
				"tier":   to.StringPtr("testing"),
			},
		},
		&ManagedClustersBeginUpdateTagsOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err := poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.ManagedCluster.ID == nil {
		t.Fatal("ManagedCluster.ID should not be nil!")
	}
}

func TestManagedClusters_Delete(t *testing.T) {
	// From example Delete Managed Cluster
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewManagedClustersClient(con,
		"subid1")
	poller, err := client.BeginDelete(ctx,
		"rg1",
		"clustername1",
		&ManagedClustersBeginDeleteOptions{})
	if err != nil {
		t.Fatal(err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
}

func TestManagedClusters_ResetServicePrincipalProfile(t *testing.T) {
	// From example Reset Service Principal Profile
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewManagedClustersClient(con,
		"subid1")
	poller, err := client.BeginResetServicePrincipalProfile(ctx,
		"rg1",
		"clustername1",
		ManagedClusterServicePrincipalProfile{
			ClientID: to.StringPtr("clientid"),
			Secret:   to.StringPtr("secret"),
		},
		&ManagedClustersBeginResetServicePrincipalProfileOptions{})
	if err != nil {
		t.Fatal(err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
}

func TestManagedClusters_ResetAADProfile(t *testing.T) {
	// From example Reset AAD Profile
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewManagedClustersClient(con,
		"subid1")
	poller, err := client.BeginResetAADProfile(ctx,
		"rg1",
		"clustername1",
		ManagedClusterAADProfile{
			ClientAppID:     to.StringPtr("clientappid"),
			ServerAppID:     to.StringPtr("serverappid"),
			ServerAppSecret: to.StringPtr("serverappsecret"),
			TenantID:        to.StringPtr("tenantid"),
		},
		&ManagedClustersBeginResetAADProfileOptions{})
	if err != nil {
		t.Fatal(err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
}

func TestManagedClusters_RotateClusterCertificates(t *testing.T) {
	// From example Rotate Cluster Certificates
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewManagedClustersClient(con,
		"subid1")
	poller, err := client.BeginRotateClusterCertificates(ctx,
		"rg1",
		"clustername1",
		&ManagedClustersBeginRotateClusterCertificatesOptions{})
	if err != nil {
		t.Fatal(err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
}

func TestManagedClusters_Stop(t *testing.T) {
	// From example Stop Managed Cluster
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewManagedClustersClient(con,
		"subid1")
	poller, err := client.BeginStop(ctx,
		"rg1",
		"clustername1",
		&ManagedClustersBeginStopOptions{})
	if err != nil {
		t.Fatal(err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
}

func TestManagedClusters_Start(t *testing.T) {
	// From example Start Managed Cluster
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewManagedClustersClient(con,
		"subid1")
	poller, err := client.BeginStart(ctx,
		"rg1",
		"clustername1",
		&ManagedClustersBeginStartOptions{})
	if err != nil {
		t.Fatal(err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
}

func TestManagedClusters_RunCommand(t *testing.T) {
	// From example submitNewCommand
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewManagedClustersClient(con,
		"subid1")
	poller, err := client.BeginRunCommand(ctx,
		"rg1",
		"clustername1",
		RunCommandRequest{
			ClusterToken: to.StringPtr(""),
			Command:      to.StringPtr("kubectl apply -f ns.yaml"),
			Context:      to.StringPtr(""),
		},
		&ManagedClustersBeginRunCommandOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err := poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.RunCommandResult.ID == nil {
		t.Fatal("RunCommandResult.ID should not be nil!")
	}
}

func TestManagedClusters_GetCommandResult(t *testing.T) {
	// From example commandFailedResult
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewManagedClustersClient(con,
		"subid1")
	res, err := client.GetCommandResult(ctx,
		"rg1",
		"clustername1",
		"def7b3ea71bd4f7e9d226ddbc0f00ad9",
		&ManagedClustersGetCommandResultOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.RunCommandResult.ID == nil {
		t.Fatal("RunCommandResult.ID should not be nil!")
	}

	// From example commandSucceedResult
	res, err = client.GetCommandResult(ctx,
		"rg1",
		"clustername1",
		"def7b3ea71bd4f7e9d226ddbc0f00ad9",
		&ManagedClustersGetCommandResultOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.RunCommandResult.ID == nil {
		t.Fatal("RunCommandResult.ID should not be nil!")
	}
}

func TestManagedClusters_ListOutboundNetworkDependenciesEndpoints(t *testing.T) {
	// From example List OutboundNetworkDependenciesEndpoints by Managed Cluster
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewManagedClustersClient(con,
		"subid1")
	pager := client.ListOutboundNetworkDependenciesEndpoints("rg1",
		"clustername1",
		&ManagedClustersListOutboundNetworkDependenciesEndpointsOptions{})
	for pager.NextPage(ctx) {
		if err := pager.Err(); err != nil {
			t.Fatalf("failed to advance page: %v", err)
		}
	}
}

func TestMaintenanceConfigurations_ListByManagedCluster(t *testing.T) {
	// From example List maintenance configurations by Managed Cluster
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewMaintenanceConfigurationsClient(con,
		"subid1")
	pager := client.ListByManagedCluster("rg1",
		"clustername1",
		&MaintenanceConfigurationsListByManagedClusterOptions{})
	for pager.NextPage(ctx) {
		if err := pager.Err(); err != nil {
			t.Fatalf("failed to advance page: %v", err)
		}
		for _, v := range pager.PageResponse().Value {
			fmt.Printf("MaintenanceConfiguration.ID: %s\n", *v.ID)
			if v.ID == nil {
				t.Fatal("MaintenanceConfiguration.ID should not be nil!")
			}
		}
	}
}

func TestMaintenanceConfigurations_Get(t *testing.T) {
	// From example Get Maintenance Configuration
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewMaintenanceConfigurationsClient(con,
		"subid1")
	res, err := client.Get(ctx,
		"rg1",
		"clustername1",
		"default",
		&MaintenanceConfigurationsGetOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.MaintenanceConfiguration.ID == nil {
		t.Fatal("MaintenanceConfiguration.ID should not be nil!")
	}
}

func TestMaintenanceConfigurations_CreateOrUpdate(t *testing.T) {
	// From example Create/Update Maintenance Configuration
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewMaintenanceConfigurationsClient(con,
		"subid1")
	res, err := client.CreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		"default",
		MaintenanceConfiguration{
			Properties: &MaintenanceConfigurationProperties{
				NotAllowedTime: []*TimeSpan{
					{
						End:   to.TimePtr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-11-30T12:00:00Z"); return t }()),
						Start: to.TimePtr(func() time.Time { t, _ := time.Parse(time.RFC3339Nano, "2020-11-26T03:00:00Z"); return t }()),
					}},
				TimeInWeek: []*TimeInWeek{
					{
						Day: WeekDayMonday.ToPtr(),
						HourSlots: []*int32{
							to.Int32Ptr(1),
							to.Int32Ptr(2)},
					}},
			},
		},
		&MaintenanceConfigurationsCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.MaintenanceConfiguration.ID == nil {
		t.Fatal("MaintenanceConfiguration.ID should not be nil!")
	}
}

func TestMaintenanceConfigurations_Delete(t *testing.T) {
	// From example Delete Maintenance Configuration
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewMaintenanceConfigurationsClient(con,
		"subid1")
	_, err := client.Delete(ctx,
		"rg1",
		"clustername1",
		"default",
		&MaintenanceConfigurationsDeleteOptions{})
	if err != nil {
		t.Fatal(err)
	}
}

func TestAgentPools_List(t *testing.T) {
	// From example List Agent Pools by Managed Cluster
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewAgentPoolsClient(con,
		"subid1")
	pager := client.List("rg1",
		"clustername1",
		&AgentPoolsListOptions{})
	for pager.NextPage(ctx) {
		if err := pager.Err(); err != nil {
			t.Fatalf("failed to advance page: %v", err)
		}
		for _, v := range pager.PageResponse().Value {
			fmt.Printf("AgentPool.ID: %s\n", *v.ID)
			if v.ID == nil {
				t.Fatal("AgentPool.ID should not be nil!")
			}
		}
	}
}

func TestAgentPools_Get(t *testing.T) {
	// From example Get Agent Pool
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewAgentPoolsClient(con,
		"subid1")
	res, err := client.Get(ctx,
		"rg1",
		"clustername1",
		"agentpool1",
		&AgentPoolsGetOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.AgentPool.ID == nil {
		t.Fatal("AgentPool.ID should not be nil!")
	}
}

func TestAgentPools_CreateOrUpdate(t *testing.T) {
	// From example Create Agent Pool using an agent pool snapshot
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewAgentPoolsClient(con,
		"subid1")
	poller, err := client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		"agentpool1",
		AgentPool{
			Properties: &ManagedClusterAgentPoolProfileProperties{
				Count: to.Int32Ptr(3),
				CreationData: &CreationData{
					SourceResourceID: to.StringPtr("/subscriptions/subid1/resourceGroups/rg1/providers/Microsoft.ContainerService/snapshots/snapshot1"),
				},
				EnableFIPS:          to.BoolPtr(true),
				OrchestratorVersion: to.StringPtr(""),
				OSType:              OSTypeLinux.ToPtr(),
				VMSize:              to.StringPtr("Standard_DS2_v2"),
			},
		},
		&AgentPoolsBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err := poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.AgentPool.ID == nil {
		t.Fatal("AgentPool.ID should not be nil!")
	}

	// From example Create Agent Pool with EncryptionAtHost enabled
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		"agentpool1",
		AgentPool{
			Properties: &ManagedClusterAgentPoolProfileProperties{
				Count:                  to.Int32Ptr(3),
				EnableEncryptionAtHost: to.BoolPtr(true),
				OrchestratorVersion:    to.StringPtr(""),
				OSType:                 OSTypeLinux.ToPtr(),
				VMSize:                 to.StringPtr("Standard_DS2_v2"),
			},
		},
		&AgentPoolsBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.AgentPool.ID == nil {
		t.Fatal("AgentPool.ID should not be nil!")
	}

	// From example Create Agent Pool with Ephemeral OS Disk
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		"agentpool1",
		AgentPool{
			Properties: &ManagedClusterAgentPoolProfileProperties{
				Count:               to.Int32Ptr(3),
				OrchestratorVersion: to.StringPtr(""),
				OSDiskSizeGB:        to.Int32Ptr(64),
				OSDiskType:          OSDiskTypeEphemeral.ToPtr(),
				OSType:              OSTypeLinux.ToPtr(),
				VMSize:              to.StringPtr("Standard_DS2_v2"),
			},
		},
		&AgentPoolsBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.AgentPool.ID == nil {
		t.Fatal("AgentPool.ID should not be nil!")
	}

	// From example Create Agent Pool with FIPS enabled OS
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		"agentpool1",
		AgentPool{
			Properties: &ManagedClusterAgentPoolProfileProperties{
				Count:               to.Int32Ptr(3),
				EnableFIPS:          to.BoolPtr(true),
				OrchestratorVersion: to.StringPtr(""),
				OSType:              OSTypeLinux.ToPtr(),
				VMSize:              to.StringPtr("Standard_DS2_v2"),
			},
		},
		&AgentPoolsBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.AgentPool.ID == nil {
		t.Fatal("AgentPool.ID should not be nil!")
	}

	// From example Create Agent Pool with GPUMIG
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		"agentpool1",
		AgentPool{
			Properties: &ManagedClusterAgentPoolProfileProperties{
				Count:              to.Int32Ptr(3),
				GpuInstanceProfile: GPUInstanceProfileMIG2G.ToPtr(),
				KubeletConfig: &KubeletConfig{
					AllowedUnsafeSysctls: []*string{
						to.StringPtr("kernel.msg*"),
						to.StringPtr("net.core.somaxconn")},
					CPUCfsQuota:           to.BoolPtr(true),
					CPUCfsQuotaPeriod:     to.StringPtr("200ms"),
					CPUManagerPolicy:      to.StringPtr("static"),
					FailSwapOn:            to.BoolPtr(false),
					ImageGcHighThreshold:  to.Int32Ptr(90),
					ImageGcLowThreshold:   to.Int32Ptr(70),
					TopologyManagerPolicy: to.StringPtr("best-effort"),
				},
				LinuxOSConfig: &LinuxOSConfig{
					SwapFileSizeMB: to.Int32Ptr(1500),
					Sysctls: &SysctlConfig{
						KernelThreadsMax:        to.Int32Ptr(99999),
						NetCoreWmemDefault:      to.Int32Ptr(12345),
						NetIPv4IPLocalPortRange: to.StringPtr("20000 60000"),
						NetIPv4TCPTwReuse:       to.BoolPtr(true),
					},
					TransparentHugePageDefrag:  to.StringPtr("madvise"),
					TransparentHugePageEnabled: to.StringPtr("always"),
				},
				OrchestratorVersion: to.StringPtr(""),
				OSType:              OSTypeLinux.ToPtr(),
				VMSize:              to.StringPtr("Standard_ND96asr_v4"),
			},
		},
		&AgentPoolsBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.AgentPool.ID == nil {
		t.Fatal("AgentPool.ID should not be nil!")
	}

	// From example Create Agent Pool with Krustlet and the WASI runtime
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		"agentpool1",
		AgentPool{
			Properties: &ManagedClusterAgentPoolProfileProperties{
				Count:               to.Int32Ptr(3),
				Mode:                AgentPoolModeUser.ToPtr(),
				OrchestratorVersion: to.StringPtr(""),
				OSDiskSizeGB:        to.Int32Ptr(64),
				OSType:              OSTypeLinux.ToPtr(),
				VMSize:              to.StringPtr("Standard_DS2_v2"),
				WorkloadRuntime:     WorkloadRuntimeWasmWasi.ToPtr(),
			},
		},
		&AgentPoolsBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.AgentPool.ID == nil {
		t.Fatal("AgentPool.ID should not be nil!")
	}

	// From example Create Agent Pool with KubeletConfig and LinuxOSConfig
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		"agentpool1",
		AgentPool{
			Properties: &ManagedClusterAgentPoolProfileProperties{
				Count: to.Int32Ptr(3),
				KubeletConfig: &KubeletConfig{
					AllowedUnsafeSysctls: []*string{
						to.StringPtr("kernel.msg*"),
						to.StringPtr("net.core.somaxconn")},
					CPUCfsQuota:           to.BoolPtr(true),
					CPUCfsQuotaPeriod:     to.StringPtr("200ms"),
					CPUManagerPolicy:      to.StringPtr("static"),
					FailSwapOn:            to.BoolPtr(false),
					ImageGcHighThreshold:  to.Int32Ptr(90),
					ImageGcLowThreshold:   to.Int32Ptr(70),
					TopologyManagerPolicy: to.StringPtr("best-effort"),
				},
				LinuxOSConfig: &LinuxOSConfig{
					SwapFileSizeMB: to.Int32Ptr(1500),
					Sysctls: &SysctlConfig{
						KernelThreadsMax:        to.Int32Ptr(99999),
						NetCoreWmemDefault:      to.Int32Ptr(12345),
						NetIPv4IPLocalPortRange: to.StringPtr("20000 60000"),
						NetIPv4TCPTwReuse:       to.BoolPtr(true),
					},
					TransparentHugePageDefrag:  to.StringPtr("madvise"),
					TransparentHugePageEnabled: to.StringPtr("always"),
				},
				OrchestratorVersion: to.StringPtr(""),
				OSType:              OSTypeLinux.ToPtr(),
				VMSize:              to.StringPtr("Standard_DS2_v2"),
			},
		},
		&AgentPoolsBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.AgentPool.ID == nil {
		t.Fatal("AgentPool.ID should not be nil!")
	}

	// From example Create Agent Pool with OSSKU
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		"agentpool1",
		AgentPool{
			Properties: &ManagedClusterAgentPoolProfileProperties{
				Count: to.Int32Ptr(3),
				KubeletConfig: &KubeletConfig{
					AllowedUnsafeSysctls: []*string{
						to.StringPtr("kernel.msg*"),
						to.StringPtr("net.core.somaxconn")},
					CPUCfsQuota:           to.BoolPtr(true),
					CPUCfsQuotaPeriod:     to.StringPtr("200ms"),
					CPUManagerPolicy:      to.StringPtr("static"),
					FailSwapOn:            to.BoolPtr(false),
					ImageGcHighThreshold:  to.Int32Ptr(90),
					ImageGcLowThreshold:   to.Int32Ptr(70),
					TopologyManagerPolicy: to.StringPtr("best-effort"),
				},
				LinuxOSConfig: &LinuxOSConfig{
					SwapFileSizeMB: to.Int32Ptr(1500),
					Sysctls: &SysctlConfig{
						KernelThreadsMax:        to.Int32Ptr(99999),
						NetCoreWmemDefault:      to.Int32Ptr(12345),
						NetIPv4IPLocalPortRange: to.StringPtr("20000 60000"),
						NetIPv4TCPTwReuse:       to.BoolPtr(true),
					},
					TransparentHugePageDefrag:  to.StringPtr("madvise"),
					TransparentHugePageEnabled: to.StringPtr("always"),
				},
				OrchestratorVersion: to.StringPtr(""),
				OSSKU:               OSSKUCBLMariner.ToPtr(),
				OSType:              OSTypeLinux.ToPtr(),
				VMSize:              to.StringPtr("Standard_DS2_v2"),
			},
		},
		&AgentPoolsBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.AgentPool.ID == nil {
		t.Fatal("AgentPool.ID should not be nil!")
	}

	// From example Create Agent Pool with PPG
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		"agentpool1",
		AgentPool{
			Properties: &ManagedClusterAgentPoolProfileProperties{
				Count:                     to.Int32Ptr(3),
				OrchestratorVersion:       to.StringPtr(""),
				OSType:                    OSTypeLinux.ToPtr(),
				ProximityPlacementGroupID: to.StringPtr("/subscriptions/subid1/resourcegroups/rg1/providers//Microsoft.Compute/proximityPlacementGroups/ppg1"),
				VMSize:                    to.StringPtr("Standard_DS2_v2"),
			},
		},
		&AgentPoolsBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.AgentPool.ID == nil {
		t.Fatal("AgentPool.ID should not be nil!")
	}

	// From example Create Agent Pool with UltraSSD enabled
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		"agentpool1",
		AgentPool{
			Properties: &ManagedClusterAgentPoolProfileProperties{
				Count:               to.Int32Ptr(3),
				EnableUltraSSD:      to.BoolPtr(true),
				OrchestratorVersion: to.StringPtr(""),
				OSType:              OSTypeLinux.ToPtr(),
				VMSize:              to.StringPtr("Standard_DS2_v2"),
			},
		},
		&AgentPoolsBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.AgentPool.ID == nil {
		t.Fatal("AgentPool.ID should not be nil!")
	}

	// From example Create Spot Agent Pool
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		"agentpool1",
		AgentPool{
			Properties: &ManagedClusterAgentPoolProfileProperties{
				Count: to.Int32Ptr(3),
				NodeLabels: map[string]*string{
					"key1": to.StringPtr("val1"),
				},
				NodeTaints: []*string{
					to.StringPtr("Key1=Value1:NoSchedule")},
				OrchestratorVersion:    to.StringPtr(""),
				OSType:                 OSTypeLinux.ToPtr(),
				ScaleSetEvictionPolicy: ScaleSetEvictionPolicyDelete.ToPtr(),
				ScaleSetPriority:       ScaleSetPrioritySpot.ToPtr(),
				Tags: map[string]*string{
					"name1": to.StringPtr("val1"),
				},
				VMSize: to.StringPtr("Standard_DS1_v2"),
			},
		},
		&AgentPoolsBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.AgentPool.ID == nil {
		t.Fatal("AgentPool.ID should not be nil!")
	}

	// From example Create/Update Agent Pool
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		"agentpool1",
		AgentPool{
			Properties: &ManagedClusterAgentPoolProfileProperties{
				Count: to.Int32Ptr(3),
				Mode:  AgentPoolModeUser.ToPtr(),
				NodeLabels: map[string]*string{
					"key1": to.StringPtr("val1"),
				},
				NodeTaints: []*string{
					to.StringPtr("Key1=Value1:NoSchedule")},
				OrchestratorVersion:    to.StringPtr(""),
				OSType:                 OSTypeLinux.ToPtr(),
				ScaleSetEvictionPolicy: ScaleSetEvictionPolicyDelete.ToPtr(),
				ScaleSetPriority:       ScaleSetPrioritySpot.ToPtr(),
				Tags: map[string]*string{
					"name1": to.StringPtr("val1"),
				},
				VMSize: to.StringPtr("Standard_DS1_v2"),
			},
		},
		&AgentPoolsBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.AgentPool.ID == nil {
		t.Fatal("AgentPool.ID should not be nil!")
	}

	// From example Update Agent Pool
	poller, err = client.BeginCreateOrUpdate(ctx,
		"rg1",
		"clustername1",
		"agentpool1",
		AgentPool{
			Properties: &ManagedClusterAgentPoolProfileProperties{
				Count:             to.Int32Ptr(3),
				EnableAutoScaling: to.BoolPtr(true),
				MaxCount:          to.Int32Ptr(2),
				MinCount:          to.Int32Ptr(2),
				NodeTaints: []*string{
					to.StringPtr("Key1=Value1:NoSchedule")},
				OrchestratorVersion:    to.StringPtr(""),
				OSType:                 OSTypeLinux.ToPtr(),
				ScaleSetEvictionPolicy: ScaleSetEvictionPolicyDelete.ToPtr(),
				ScaleSetPriority:       ScaleSetPrioritySpot.ToPtr(),
				VMSize:                 to.StringPtr("Standard_DS1_v2"),
			},
		},
		&AgentPoolsBeginCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.AgentPool.ID == nil {
		t.Fatal("AgentPool.ID should not be nil!")
	}
}

func TestAgentPools_Delete(t *testing.T) {
	// From example Delete Agent Pool
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewAgentPoolsClient(con,
		"subid1")
	poller, err := client.BeginDelete(ctx,
		"rg1",
		"clustername1",
		"agentpool1",
		&AgentPoolsBeginDeleteOptions{})
	if err != nil {
		t.Fatal(err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
}

func TestAgentPools_GetUpgradeProfile(t *testing.T) {
	// From example Get Upgrade Profile for Agent Pool
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewAgentPoolsClient(con,
		"subid1")
	res, err := client.GetUpgradeProfile(ctx,
		"rg1",
		"clustername1",
		"agentpool1",
		&AgentPoolsGetUpgradeProfileOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.AgentPoolUpgradeProfile.ID == nil {
		t.Fatal("AgentPoolUpgradeProfile.ID should not be nil!")
	}
}

func TestAgentPools_GetAvailableAgentPoolVersions(t *testing.T) {
	// From example Get available versions for agent pool
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewAgentPoolsClient(con,
		"subid1")
	res, err := client.GetAvailableAgentPoolVersions(ctx,
		"rg1",
		"clustername1",
		&AgentPoolsGetAvailableAgentPoolVersionsOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.AgentPoolAvailableVersions.ID == nil {
		t.Fatal("AgentPoolAvailableVersions.ID should not be nil!")
	}
}

func TestAgentPools_UpgradeNodeImageVersion(t *testing.T) {
	// From example Upgrade Agent Pool Node Image Version
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewAgentPoolsClient(con,
		"subid1")
	poller, err := client.BeginUpgradeNodeImageVersion(ctx,
		"rg1",
		"clustername1",
		"agentpool1",
		&AgentPoolsBeginUpgradeNodeImageVersionOptions{})
	if err != nil {
		t.Fatal(err)
	}
	res, err := poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
	if res.AgentPool.ID == nil {
		t.Fatal("AgentPool.ID should not be nil!")
	}
}

func TestPrivateEndpointConnections_List(t *testing.T) {
	// From example List Private Endpoint Connections by Managed Cluster
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewPrivateEndpointConnectionsClient(con,
		"subid1")
	_, err := client.List(ctx,
		"rg1",
		"clustername1",
		&PrivateEndpointConnectionsListOptions{})
	if err != nil {
		t.Fatal(err)
	}
}

func TestPrivateEndpointConnections_Get(t *testing.T) {
	// From example Get Private Endpoint Connection
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewPrivateEndpointConnectionsClient(con,
		"subid1")
	res, err := client.Get(ctx,
		"rg1",
		"clustername1",
		"privateendpointconnection1",
		&PrivateEndpointConnectionsGetOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.PrivateEndpointConnection.ID == nil {
		t.Fatal("PrivateEndpointConnection.ID should not be nil!")
	}
}

func TestPrivateEndpointConnections_Update(t *testing.T) {
	// From example Update Private Endpoint Connection
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewPrivateEndpointConnectionsClient(con,
		"subid1")
	res, err := client.Update(ctx,
		"rg1",
		"clustername1",
		"privateendpointconnection1",
		PrivateEndpointConnection{
			Properties: &PrivateEndpointConnectionProperties{
				PrivateLinkServiceConnectionState: &PrivateLinkServiceConnectionState{
					Status: ConnectionStatusApproved.ToPtr(),
				},
			},
		},
		&PrivateEndpointConnectionsUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.PrivateEndpointConnection.ID == nil {
		t.Fatal("PrivateEndpointConnection.ID should not be nil!")
	}
}

func TestPrivateEndpointConnections_Delete(t *testing.T) {
	// From example Delete Private Endpoint Connection
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewPrivateEndpointConnectionsClient(con,
		"subid1")
	poller, err := client.BeginDelete(ctx,
		"rg1",
		"clustername1",
		"privateendpointconnection1",
		&PrivateEndpointConnectionsBeginDeleteOptions{})
	if err != nil {
		t.Fatal(err)
	}
	_, err = poller.PollUntilDone(ctx, 30*time.Second)
	if err != nil {
		t.Fatal(err)
	}
}

func TestPrivateLinkResources_List(t *testing.T) {
	// From example List Private Link Resources by Managed Cluster
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewPrivateLinkResourcesClient(con,
		"subid1")
	_, err := client.List(ctx,
		"rg1",
		"clustername1",
		&PrivateLinkResourcesListOptions{})
	if err != nil {
		t.Fatal(err)
	}
}

func TestResolvePrivateLinkServiceId_POST(t *testing.T) {
	// From example Resolve the Private Link Service ID for Managed Cluster
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewResolvePrivateLinkServiceIDClient(con,
		"subid1")
	res, err := client.POST(ctx,
		"rg1",
		"clustername1",
		PrivateLinkResource{
			Name: to.StringPtr("management"),
		},
		&ResolvePrivateLinkServiceIDPOSTOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.PrivateLinkResource.ID == nil {
		t.Fatal("PrivateLinkResource.ID should not be nil!")
	}
}

func TestSnapshots_List(t *testing.T) {
	// From example List Snapshots
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewSnapshotsClient(con,
		"subid1")
	pager := client.List(&SnapshotsListOptions{})
	for pager.NextPage(ctx) {
		if err := pager.Err(); err != nil {
			t.Fatalf("failed to advance page: %v", err)
		}
		for _, v := range pager.PageResponse().Value {
			fmt.Printf("Snapshot.ID: %s\n", *v.ID)
			if v.ID == nil {
				t.Fatal("Snapshot.ID should not be nil!")
			}
		}
	}
}

func TestSnapshots_ListByResourceGroup(t *testing.T) {
	// From example List Snapshots by Resource Group
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewSnapshotsClient(con,
		"subid1")
	pager := client.ListByResourceGroup("rg1",
		&SnapshotsListByResourceGroupOptions{})
	for pager.NextPage(ctx) {
		if err := pager.Err(); err != nil {
			t.Fatalf("failed to advance page: %v", err)
		}
		for _, v := range pager.PageResponse().Value {
			fmt.Printf("Snapshot.ID: %s\n", *v.ID)
			if v.ID == nil {
				t.Fatal("Snapshot.ID should not be nil!")
			}
		}
	}
}

func TestSnapshots_Get(t *testing.T) {
	// From example Get Snapshot
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewSnapshotsClient(con,
		"subid1")
	res, err := client.Get(ctx,
		"rg1",
		"snapshot1",
		&SnapshotsGetOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.Snapshot.ID == nil {
		t.Fatal("Snapshot.ID should not be nil!")
	}
}

func TestSnapshots_CreateOrUpdate(t *testing.T) {
	// From example Create/Update Snapshot
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewSnapshotsClient(con,
		"subid1")
	res, err := client.CreateOrUpdate(ctx,
		"rg1",
		"snapshot1",
		Snapshot{
			Resource: Resource{
				Location: to.StringPtr("westus"),
				Tags: map[string]*string{
					"key1": to.StringPtr("val1"),
					"key2": to.StringPtr("val2"),
				},
			},
			Properties: &SnapshotProperties{
				CreationData: &CreationData{
					SourceResourceID: to.StringPtr("/subscriptions/subid1/resourcegroups/rg1/providers/Microsoft.ContainerService/managedClusters/cluster1/agentPools/pool0"),
				},
			},
		},
		&SnapshotsCreateOrUpdateOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.Snapshot.ID == nil {
		t.Fatal("Snapshot.ID should not be nil!")
	}
}

func TestSnapshots_UpdateTags(t *testing.T) {
	// From example Update Snapshot Tags
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewSnapshotsClient(con,
		"subid1")
	res, err := client.UpdateTags(ctx,
		"rg1",
		"snapshot1",
		TagsObject{
			Tags: map[string]*string{
				"key2": to.StringPtr("new-val2"),
				"key3": to.StringPtr("val3"),
			},
		},
		&SnapshotsUpdateTagsOptions{})
	if err != nil {
		t.Fatal(err)
	}
	if res.Snapshot.ID == nil {
		t.Fatal("Snapshot.ID should not be nil!")
	}
}

func TestSnapshots_Delete(t *testing.T) {
	// From example Delete Snapshot
	defer func() {
		if r := recover(); r != nil {
			t.Fatal("stacktrace from panic: \n" + string(debug.Stack()))
		}
	}()
	client := NewSnapshotsClient(con,
		"subid1")
	_, err := client.Delete(ctx,
		"rg1",
		"snapshot1",
		&SnapshotsDeleteOptions{})
	if err != nil {
		t.Fatal(err)
	}
}

// TestMain will exec each test
func TestMain(m *testing.M) {
	setUp()
	retCode := m.Run() // exec test and this returns an exit code to pass to os
	tearDown()
	os.Exit(retCode)
}

func getEnv(key, fallback string) string {
	if value, ok := os.LookupEnv(key); ok {
		return value
	}
	return fallback
}

func setUp() {
	ctx = context.Background()
	subscriptionId = getEnv("SUBSCRIPTION_ID", "00000000-0000-0000-0000-000000000000")
	mockHost = getEnv("AZURE_VIRTUAL_SERVER_HOST", "https://localhost:8443")

	tr := &http.Transport{}
	if err := http2.ConfigureTransport(tr); err != nil {
		fmt.Printf("Failed to configure http2 transport: %v", err)
	}
	tr.TLSClientConfig.InsecureSkipVerify = true
	client := &http.Client{Transport: tr}
	cred, err = azidentity.NewEnvironmentCredential(&azidentity.EnvironmentCredentialOptions{AuthorityHost: mockHost, HTTPClient: client})
	if err != nil {
		panic(err)
	}

	con = arm.NewConnection(mockHost, cred, &arm.ConnectionOptions{
		Logging: policy.LogOptions{
			IncludeBody: true,
		},
		HTTPClient: client,
	})
}

func tearDown() {

}
