//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armcompute

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AvailabilitySetsClientListAvailableSizesPager provides operations for iterating over paged responses.
type AvailabilitySetsClientListAvailableSizesPager struct {
	client    *AvailabilitySetsClient
	current   AvailabilitySetsClientListAvailableSizesResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AvailabilitySetsClientListAvailableSizesPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *AvailabilitySetsClientListAvailableSizesPager) NextPage(ctx context.Context) (AvailabilitySetsClientListAvailableSizesResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return AvailabilitySetsClientListAvailableSizesResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AvailabilitySetsClientListAvailableSizesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AvailabilitySetsClientListAvailableSizesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AvailabilitySetsClientListAvailableSizesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAvailableSizesHandleResponse(resp)
	if err != nil {
		return AvailabilitySetsClientListAvailableSizesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AvailabilitySetsClientListBySubscriptionPager provides operations for iterating over paged responses.
type AvailabilitySetsClientListBySubscriptionPager struct {
	client    *AvailabilitySetsClient
	current   AvailabilitySetsClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailabilitySetsClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AvailabilitySetsClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailabilitySetListResult.NextLink == nil || len(*p.current.AvailabilitySetListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AvailabilitySetsClientListBySubscriptionPager) NextPage(ctx context.Context) (AvailabilitySetsClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AvailabilitySetsClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AvailabilitySetsClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AvailabilitySetsClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AvailabilitySetsClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return AvailabilitySetsClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AvailabilitySetsClientListPager provides operations for iterating over paged responses.
type AvailabilitySetsClientListPager struct {
	client    *AvailabilitySetsClient
	current   AvailabilitySetsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AvailabilitySetsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AvailabilitySetsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AvailabilitySetListResult.NextLink == nil || len(*p.current.AvailabilitySetListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AvailabilitySetsClientListPager) NextPage(ctx context.Context) (AvailabilitySetsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AvailabilitySetsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AvailabilitySetsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AvailabilitySetsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AvailabilitySetsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return AvailabilitySetsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CapacityReservationGroupsClientListByResourceGroupPager provides operations for iterating over paged responses.
type CapacityReservationGroupsClientListByResourceGroupPager struct {
	client    *CapacityReservationGroupsClient
	current   CapacityReservationGroupsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CapacityReservationGroupsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CapacityReservationGroupsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CapacityReservationGroupListResult.NextLink == nil || len(*p.current.CapacityReservationGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CapacityReservationGroupsClientListByResourceGroupPager) NextPage(ctx context.Context) (CapacityReservationGroupsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CapacityReservationGroupsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CapacityReservationGroupsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CapacityReservationGroupsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CapacityReservationGroupsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return CapacityReservationGroupsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CapacityReservationGroupsClientListBySubscriptionPager provides operations for iterating over paged responses.
type CapacityReservationGroupsClientListBySubscriptionPager struct {
	client    *CapacityReservationGroupsClient
	current   CapacityReservationGroupsClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CapacityReservationGroupsClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CapacityReservationGroupsClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CapacityReservationGroupListResult.NextLink == nil || len(*p.current.CapacityReservationGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CapacityReservationGroupsClientListBySubscriptionPager) NextPage(ctx context.Context) (CapacityReservationGroupsClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CapacityReservationGroupsClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CapacityReservationGroupsClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CapacityReservationGroupsClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CapacityReservationGroupsClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return CapacityReservationGroupsClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CapacityReservationsClientListByCapacityReservationGroupPager provides operations for iterating over paged responses.
type CapacityReservationsClientListByCapacityReservationGroupPager struct {
	client    *CapacityReservationsClient
	current   CapacityReservationsClientListByCapacityReservationGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CapacityReservationsClientListByCapacityReservationGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CapacityReservationsClientListByCapacityReservationGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CapacityReservationListResult.NextLink == nil || len(*p.current.CapacityReservationListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CapacityReservationsClientListByCapacityReservationGroupPager) NextPage(ctx context.Context) (CapacityReservationsClientListByCapacityReservationGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CapacityReservationsClientListByCapacityReservationGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CapacityReservationsClientListByCapacityReservationGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CapacityReservationsClientListByCapacityReservationGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CapacityReservationsClientListByCapacityReservationGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByCapacityReservationGroupHandleResponse(resp)
	if err != nil {
		return CapacityReservationsClientListByCapacityReservationGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CloudServiceOperatingSystemsClientListOSFamiliesPager provides operations for iterating over paged responses.
type CloudServiceOperatingSystemsClientListOSFamiliesPager struct {
	client    *CloudServiceOperatingSystemsClient
	current   CloudServiceOperatingSystemsClientListOSFamiliesResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CloudServiceOperatingSystemsClientListOSFamiliesResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CloudServiceOperatingSystemsClientListOSFamiliesPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OSFamilyListResult.NextLink == nil || len(*p.current.OSFamilyListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CloudServiceOperatingSystemsClientListOSFamiliesPager) NextPage(ctx context.Context) (CloudServiceOperatingSystemsClientListOSFamiliesResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CloudServiceOperatingSystemsClientListOSFamiliesResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CloudServiceOperatingSystemsClientListOSFamiliesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CloudServiceOperatingSystemsClientListOSFamiliesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CloudServiceOperatingSystemsClientListOSFamiliesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listOSFamiliesHandleResponse(resp)
	if err != nil {
		return CloudServiceOperatingSystemsClientListOSFamiliesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CloudServiceOperatingSystemsClientListOSVersionsPager provides operations for iterating over paged responses.
type CloudServiceOperatingSystemsClientListOSVersionsPager struct {
	client    *CloudServiceOperatingSystemsClient
	current   CloudServiceOperatingSystemsClientListOSVersionsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CloudServiceOperatingSystemsClientListOSVersionsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CloudServiceOperatingSystemsClientListOSVersionsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OSVersionListResult.NextLink == nil || len(*p.current.OSVersionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CloudServiceOperatingSystemsClientListOSVersionsPager) NextPage(ctx context.Context) (CloudServiceOperatingSystemsClientListOSVersionsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CloudServiceOperatingSystemsClientListOSVersionsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CloudServiceOperatingSystemsClientListOSVersionsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CloudServiceOperatingSystemsClientListOSVersionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CloudServiceOperatingSystemsClientListOSVersionsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listOSVersionsHandleResponse(resp)
	if err != nil {
		return CloudServiceOperatingSystemsClientListOSVersionsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CloudServiceRoleInstancesClientListPager provides operations for iterating over paged responses.
type CloudServiceRoleInstancesClientListPager struct {
	client    *CloudServiceRoleInstancesClient
	current   CloudServiceRoleInstancesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CloudServiceRoleInstancesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CloudServiceRoleInstancesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RoleInstanceListResult.NextLink == nil || len(*p.current.RoleInstanceListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CloudServiceRoleInstancesClientListPager) NextPage(ctx context.Context) (CloudServiceRoleInstancesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CloudServiceRoleInstancesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CloudServiceRoleInstancesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CloudServiceRoleInstancesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CloudServiceRoleInstancesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return CloudServiceRoleInstancesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CloudServiceRolesClientListPager provides operations for iterating over paged responses.
type CloudServiceRolesClientListPager struct {
	client    *CloudServiceRolesClient
	current   CloudServiceRolesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CloudServiceRolesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CloudServiceRolesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CloudServiceRoleListResult.NextLink == nil || len(*p.current.CloudServiceRoleListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CloudServiceRolesClientListPager) NextPage(ctx context.Context) (CloudServiceRolesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CloudServiceRolesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CloudServiceRolesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CloudServiceRolesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CloudServiceRolesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return CloudServiceRolesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CloudServicesClientListAllPager provides operations for iterating over paged responses.
type CloudServicesClientListAllPager struct {
	client    *CloudServicesClient
	current   CloudServicesClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CloudServicesClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CloudServicesClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CloudServiceListResult.NextLink == nil || len(*p.current.CloudServiceListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CloudServicesClientListAllPager) NextPage(ctx context.Context) (CloudServicesClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CloudServicesClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CloudServicesClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CloudServicesClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CloudServicesClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return CloudServicesClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CloudServicesClientListPager provides operations for iterating over paged responses.
type CloudServicesClientListPager struct {
	client    *CloudServicesClient
	current   CloudServicesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CloudServicesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CloudServicesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CloudServiceListResult.NextLink == nil || len(*p.current.CloudServiceListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CloudServicesClientListPager) NextPage(ctx context.Context) (CloudServicesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CloudServicesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CloudServicesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CloudServicesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CloudServicesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return CloudServicesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CloudServicesUpdateDomainClientListUpdateDomainsPager provides operations for iterating over paged responses.
type CloudServicesUpdateDomainClientListUpdateDomainsPager struct {
	client    *CloudServicesUpdateDomainClient
	current   CloudServicesUpdateDomainClientListUpdateDomainsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CloudServicesUpdateDomainClientListUpdateDomainsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CloudServicesUpdateDomainClientListUpdateDomainsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.UpdateDomainListResult.NextLink == nil || len(*p.current.UpdateDomainListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CloudServicesUpdateDomainClientListUpdateDomainsPager) NextPage(ctx context.Context) (CloudServicesUpdateDomainClientListUpdateDomainsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CloudServicesUpdateDomainClientListUpdateDomainsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CloudServicesUpdateDomainClientListUpdateDomainsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CloudServicesUpdateDomainClientListUpdateDomainsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CloudServicesUpdateDomainClientListUpdateDomainsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listUpdateDomainsHandleResponse(resp)
	if err != nil {
		return CloudServicesUpdateDomainClientListUpdateDomainsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DedicatedHostGroupsClientListByResourceGroupPager provides operations for iterating over paged responses.
type DedicatedHostGroupsClientListByResourceGroupPager struct {
	client    *DedicatedHostGroupsClient
	current   DedicatedHostGroupsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DedicatedHostGroupsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DedicatedHostGroupsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DedicatedHostGroupListResult.NextLink == nil || len(*p.current.DedicatedHostGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DedicatedHostGroupsClientListByResourceGroupPager) NextPage(ctx context.Context) (DedicatedHostGroupsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DedicatedHostGroupsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DedicatedHostGroupsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DedicatedHostGroupsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DedicatedHostGroupsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return DedicatedHostGroupsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DedicatedHostGroupsClientListBySubscriptionPager provides operations for iterating over paged responses.
type DedicatedHostGroupsClientListBySubscriptionPager struct {
	client    *DedicatedHostGroupsClient
	current   DedicatedHostGroupsClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DedicatedHostGroupsClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DedicatedHostGroupsClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DedicatedHostGroupListResult.NextLink == nil || len(*p.current.DedicatedHostGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DedicatedHostGroupsClientListBySubscriptionPager) NextPage(ctx context.Context) (DedicatedHostGroupsClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DedicatedHostGroupsClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DedicatedHostGroupsClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DedicatedHostGroupsClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DedicatedHostGroupsClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return DedicatedHostGroupsClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DedicatedHostsClientListByHostGroupPager provides operations for iterating over paged responses.
type DedicatedHostsClientListByHostGroupPager struct {
	client    *DedicatedHostsClient
	current   DedicatedHostsClientListByHostGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DedicatedHostsClientListByHostGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DedicatedHostsClientListByHostGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DedicatedHostListResult.NextLink == nil || len(*p.current.DedicatedHostListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DedicatedHostsClientListByHostGroupPager) NextPage(ctx context.Context) (DedicatedHostsClientListByHostGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DedicatedHostsClientListByHostGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DedicatedHostsClientListByHostGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DedicatedHostsClientListByHostGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DedicatedHostsClientListByHostGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByHostGroupHandleResponse(resp)
	if err != nil {
		return DedicatedHostsClientListByHostGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DiskAccessesClientListByResourceGroupPager provides operations for iterating over paged responses.
type DiskAccessesClientListByResourceGroupPager struct {
	client    *DiskAccessesClient
	current   DiskAccessesClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiskAccessesClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DiskAccessesClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskAccessList.NextLink == nil || len(*p.current.DiskAccessList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DiskAccessesClientListByResourceGroupPager) NextPage(ctx context.Context) (DiskAccessesClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DiskAccessesClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DiskAccessesClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DiskAccessesClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DiskAccessesClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return DiskAccessesClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DiskAccessesClientListPager provides operations for iterating over paged responses.
type DiskAccessesClientListPager struct {
	client    *DiskAccessesClient
	current   DiskAccessesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiskAccessesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DiskAccessesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskAccessList.NextLink == nil || len(*p.current.DiskAccessList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DiskAccessesClientListPager) NextPage(ctx context.Context) (DiskAccessesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DiskAccessesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DiskAccessesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DiskAccessesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DiskAccessesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return DiskAccessesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DiskAccessesClientListPrivateEndpointConnectionsPager provides operations for iterating over paged responses.
type DiskAccessesClientListPrivateEndpointConnectionsPager struct {
	client    *DiskAccessesClient
	current   DiskAccessesClientListPrivateEndpointConnectionsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiskAccessesClientListPrivateEndpointConnectionsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DiskAccessesClientListPrivateEndpointConnectionsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateEndpointConnectionListResult.NextLink == nil || len(*p.current.PrivateEndpointConnectionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DiskAccessesClientListPrivateEndpointConnectionsPager) NextPage(ctx context.Context) (DiskAccessesClientListPrivateEndpointConnectionsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DiskAccessesClientListPrivateEndpointConnectionsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DiskAccessesClientListPrivateEndpointConnectionsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DiskAccessesClientListPrivateEndpointConnectionsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DiskAccessesClientListPrivateEndpointConnectionsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listPrivateEndpointConnectionsHandleResponse(resp)
	if err != nil {
		return DiskAccessesClientListPrivateEndpointConnectionsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DiskEncryptionSetsClientListAssociatedResourcesPager provides operations for iterating over paged responses.
type DiskEncryptionSetsClientListAssociatedResourcesPager struct {
	client    *DiskEncryptionSetsClient
	current   DiskEncryptionSetsClientListAssociatedResourcesResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiskEncryptionSetsClientListAssociatedResourcesResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DiskEncryptionSetsClientListAssociatedResourcesPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceURIList.NextLink == nil || len(*p.current.ResourceURIList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DiskEncryptionSetsClientListAssociatedResourcesPager) NextPage(ctx context.Context) (DiskEncryptionSetsClientListAssociatedResourcesResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DiskEncryptionSetsClientListAssociatedResourcesResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DiskEncryptionSetsClientListAssociatedResourcesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DiskEncryptionSetsClientListAssociatedResourcesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DiskEncryptionSetsClientListAssociatedResourcesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAssociatedResourcesHandleResponse(resp)
	if err != nil {
		return DiskEncryptionSetsClientListAssociatedResourcesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DiskEncryptionSetsClientListByResourceGroupPager provides operations for iterating over paged responses.
type DiskEncryptionSetsClientListByResourceGroupPager struct {
	client    *DiskEncryptionSetsClient
	current   DiskEncryptionSetsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiskEncryptionSetsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DiskEncryptionSetsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskEncryptionSetList.NextLink == nil || len(*p.current.DiskEncryptionSetList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DiskEncryptionSetsClientListByResourceGroupPager) NextPage(ctx context.Context) (DiskEncryptionSetsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DiskEncryptionSetsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DiskEncryptionSetsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DiskEncryptionSetsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DiskEncryptionSetsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return DiskEncryptionSetsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DiskEncryptionSetsClientListPager provides operations for iterating over paged responses.
type DiskEncryptionSetsClientListPager struct {
	client    *DiskEncryptionSetsClient
	current   DiskEncryptionSetsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiskEncryptionSetsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DiskEncryptionSetsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskEncryptionSetList.NextLink == nil || len(*p.current.DiskEncryptionSetList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DiskEncryptionSetsClientListPager) NextPage(ctx context.Context) (DiskEncryptionSetsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DiskEncryptionSetsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DiskEncryptionSetsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DiskEncryptionSetsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DiskEncryptionSetsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return DiskEncryptionSetsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DiskRestorePointClientListByRestorePointPager provides operations for iterating over paged responses.
type DiskRestorePointClientListByRestorePointPager struct {
	client    *DiskRestorePointClient
	current   DiskRestorePointClientListByRestorePointResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DiskRestorePointClientListByRestorePointResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DiskRestorePointClientListByRestorePointPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskRestorePointList.NextLink == nil || len(*p.current.DiskRestorePointList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DiskRestorePointClientListByRestorePointPager) NextPage(ctx context.Context) (DiskRestorePointClientListByRestorePointResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DiskRestorePointClientListByRestorePointResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DiskRestorePointClientListByRestorePointResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DiskRestorePointClientListByRestorePointResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DiskRestorePointClientListByRestorePointResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByRestorePointHandleResponse(resp)
	if err != nil {
		return DiskRestorePointClientListByRestorePointResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DisksClientListByResourceGroupPager provides operations for iterating over paged responses.
type DisksClientListByResourceGroupPager struct {
	client    *DisksClient
	current   DisksClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DisksClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DisksClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskList.NextLink == nil || len(*p.current.DiskList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DisksClientListByResourceGroupPager) NextPage(ctx context.Context) (DisksClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DisksClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DisksClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DisksClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DisksClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return DisksClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DisksClientListPager provides operations for iterating over paged responses.
type DisksClientListPager struct {
	client    *DisksClient
	current   DisksClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DisksClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DisksClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DiskList.NextLink == nil || len(*p.current.DiskList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DisksClientListPager) NextPage(ctx context.Context) (DisksClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DisksClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DisksClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DisksClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DisksClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return DisksClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GalleriesClientListByResourceGroupPager provides operations for iterating over paged responses.
type GalleriesClientListByResourceGroupPager struct {
	client    *GalleriesClient
	current   GalleriesClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleriesClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GalleriesClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryList.NextLink == nil || len(*p.current.GalleryList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GalleriesClientListByResourceGroupPager) NextPage(ctx context.Context) (GalleriesClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GalleriesClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GalleriesClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GalleriesClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GalleriesClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return GalleriesClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GalleriesClientListPager provides operations for iterating over paged responses.
type GalleriesClientListPager struct {
	client    *GalleriesClient
	current   GalleriesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleriesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GalleriesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryList.NextLink == nil || len(*p.current.GalleryList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GalleriesClientListPager) NextPage(ctx context.Context) (GalleriesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GalleriesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GalleriesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GalleriesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GalleriesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return GalleriesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GalleryApplicationVersionsClientListByGalleryApplicationPager provides operations for iterating over paged responses.
type GalleryApplicationVersionsClientListByGalleryApplicationPager struct {
	client    *GalleryApplicationVersionsClient
	current   GalleryApplicationVersionsClientListByGalleryApplicationResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleryApplicationVersionsClientListByGalleryApplicationResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GalleryApplicationVersionsClientListByGalleryApplicationPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryApplicationVersionList.NextLink == nil || len(*p.current.GalleryApplicationVersionList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GalleryApplicationVersionsClientListByGalleryApplicationPager) NextPage(ctx context.Context) (GalleryApplicationVersionsClientListByGalleryApplicationResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GalleryApplicationVersionsClientListByGalleryApplicationResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GalleryApplicationVersionsClientListByGalleryApplicationResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GalleryApplicationVersionsClientListByGalleryApplicationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GalleryApplicationVersionsClientListByGalleryApplicationResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByGalleryApplicationHandleResponse(resp)
	if err != nil {
		return GalleryApplicationVersionsClientListByGalleryApplicationResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GalleryApplicationsClientListByGalleryPager provides operations for iterating over paged responses.
type GalleryApplicationsClientListByGalleryPager struct {
	client    *GalleryApplicationsClient
	current   GalleryApplicationsClientListByGalleryResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleryApplicationsClientListByGalleryResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GalleryApplicationsClientListByGalleryPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryApplicationList.NextLink == nil || len(*p.current.GalleryApplicationList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GalleryApplicationsClientListByGalleryPager) NextPage(ctx context.Context) (GalleryApplicationsClientListByGalleryResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GalleryApplicationsClientListByGalleryResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GalleryApplicationsClientListByGalleryResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GalleryApplicationsClientListByGalleryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GalleryApplicationsClientListByGalleryResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByGalleryHandleResponse(resp)
	if err != nil {
		return GalleryApplicationsClientListByGalleryResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GalleryImageVersionsClientListByGalleryImagePager provides operations for iterating over paged responses.
type GalleryImageVersionsClientListByGalleryImagePager struct {
	client    *GalleryImageVersionsClient
	current   GalleryImageVersionsClientListByGalleryImageResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleryImageVersionsClientListByGalleryImageResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GalleryImageVersionsClientListByGalleryImagePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryImageVersionList.NextLink == nil || len(*p.current.GalleryImageVersionList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GalleryImageVersionsClientListByGalleryImagePager) NextPage(ctx context.Context) (GalleryImageVersionsClientListByGalleryImageResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GalleryImageVersionsClientListByGalleryImageResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GalleryImageVersionsClientListByGalleryImageResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GalleryImageVersionsClientListByGalleryImageResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GalleryImageVersionsClientListByGalleryImageResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByGalleryImageHandleResponse(resp)
	if err != nil {
		return GalleryImageVersionsClientListByGalleryImageResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GalleryImagesClientListByGalleryPager provides operations for iterating over paged responses.
type GalleryImagesClientListByGalleryPager struct {
	client    *GalleryImagesClient
	current   GalleryImagesClientListByGalleryResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GalleryImagesClientListByGalleryResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GalleryImagesClientListByGalleryPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GalleryImageList.NextLink == nil || len(*p.current.GalleryImageList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GalleryImagesClientListByGalleryPager) NextPage(ctx context.Context) (GalleryImagesClientListByGalleryResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GalleryImagesClientListByGalleryResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GalleryImagesClientListByGalleryResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GalleryImagesClientListByGalleryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GalleryImagesClientListByGalleryResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByGalleryHandleResponse(resp)
	if err != nil {
		return GalleryImagesClientListByGalleryResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ImagesClientListByResourceGroupPager provides operations for iterating over paged responses.
type ImagesClientListByResourceGroupPager struct {
	client    *ImagesClient
	current   ImagesClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ImagesClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ImagesClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ImageListResult.NextLink == nil || len(*p.current.ImageListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ImagesClientListByResourceGroupPager) NextPage(ctx context.Context) (ImagesClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ImagesClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ImagesClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ImagesClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ImagesClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return ImagesClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ImagesClientListPager provides operations for iterating over paged responses.
type ImagesClientListPager struct {
	client    *ImagesClient
	current   ImagesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ImagesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ImagesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ImageListResult.NextLink == nil || len(*p.current.ImageListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ImagesClientListPager) NextPage(ctx context.Context) (ImagesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ImagesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ImagesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ImagesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ImagesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ImagesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *OperationsClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *OperationsClientListPager) NextPage(ctx context.Context) (OperationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return OperationsClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return OperationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProximityPlacementGroupsClientListByResourceGroupPager provides operations for iterating over paged responses.
type ProximityPlacementGroupsClientListByResourceGroupPager struct {
	client    *ProximityPlacementGroupsClient
	current   ProximityPlacementGroupsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProximityPlacementGroupsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProximityPlacementGroupsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProximityPlacementGroupListResult.NextLink == nil || len(*p.current.ProximityPlacementGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProximityPlacementGroupsClientListByResourceGroupPager) NextPage(ctx context.Context) (ProximityPlacementGroupsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProximityPlacementGroupsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProximityPlacementGroupsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProximityPlacementGroupsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProximityPlacementGroupsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return ProximityPlacementGroupsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ProximityPlacementGroupsClientListBySubscriptionPager provides operations for iterating over paged responses.
type ProximityPlacementGroupsClientListBySubscriptionPager struct {
	client    *ProximityPlacementGroupsClient
	current   ProximityPlacementGroupsClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ProximityPlacementGroupsClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ProximityPlacementGroupsClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ProximityPlacementGroupListResult.NextLink == nil || len(*p.current.ProximityPlacementGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ProximityPlacementGroupsClientListBySubscriptionPager) NextPage(ctx context.Context) (ProximityPlacementGroupsClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ProximityPlacementGroupsClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ProximityPlacementGroupsClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ProximityPlacementGroupsClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ProximityPlacementGroupsClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return ProximityPlacementGroupsClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ResourceSKUsClientListPager provides operations for iterating over paged responses.
type ResourceSKUsClientListPager struct {
	client    *ResourceSKUsClient
	current   ResourceSKUsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ResourceSKUsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ResourceSKUsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ResourceSKUsResult.NextLink == nil || len(*p.current.ResourceSKUsResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ResourceSKUsClientListPager) NextPage(ctx context.Context) (ResourceSKUsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ResourceSKUsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ResourceSKUsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ResourceSKUsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ResourceSKUsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ResourceSKUsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RestorePointCollectionsClientListAllPager provides operations for iterating over paged responses.
type RestorePointCollectionsClientListAllPager struct {
	client    *RestorePointCollectionsClient
	current   RestorePointCollectionsClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RestorePointCollectionsClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RestorePointCollectionsClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RestorePointCollectionListResult.NextLink == nil || len(*p.current.RestorePointCollectionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RestorePointCollectionsClientListAllPager) NextPage(ctx context.Context) (RestorePointCollectionsClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RestorePointCollectionsClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RestorePointCollectionsClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RestorePointCollectionsClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RestorePointCollectionsClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return RestorePointCollectionsClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// RestorePointCollectionsClientListPager provides operations for iterating over paged responses.
type RestorePointCollectionsClientListPager struct {
	client    *RestorePointCollectionsClient
	current   RestorePointCollectionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, RestorePointCollectionsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *RestorePointCollectionsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RestorePointCollectionListResult.NextLink == nil || len(*p.current.RestorePointCollectionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *RestorePointCollectionsClientListPager) NextPage(ctx context.Context) (RestorePointCollectionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return RestorePointCollectionsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return RestorePointCollectionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return RestorePointCollectionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return RestorePointCollectionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return RestorePointCollectionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SSHPublicKeysClientListByResourceGroupPager provides operations for iterating over paged responses.
type SSHPublicKeysClientListByResourceGroupPager struct {
	client    *SSHPublicKeysClient
	current   SSHPublicKeysClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SSHPublicKeysClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SSHPublicKeysClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SSHPublicKeysGroupListResult.NextLink == nil || len(*p.current.SSHPublicKeysGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SSHPublicKeysClientListByResourceGroupPager) NextPage(ctx context.Context) (SSHPublicKeysClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SSHPublicKeysClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SSHPublicKeysClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SSHPublicKeysClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SSHPublicKeysClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return SSHPublicKeysClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SSHPublicKeysClientListBySubscriptionPager provides operations for iterating over paged responses.
type SSHPublicKeysClientListBySubscriptionPager struct {
	client    *SSHPublicKeysClient
	current   SSHPublicKeysClientListBySubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SSHPublicKeysClientListBySubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SSHPublicKeysClientListBySubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SSHPublicKeysGroupListResult.NextLink == nil || len(*p.current.SSHPublicKeysGroupListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SSHPublicKeysClientListBySubscriptionPager) NextPage(ctx context.Context) (SSHPublicKeysClientListBySubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SSHPublicKeysClientListBySubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SSHPublicKeysClientListBySubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SSHPublicKeysClientListBySubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SSHPublicKeysClientListBySubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listBySubscriptionHandleResponse(resp)
	if err != nil {
		return SSHPublicKeysClientListBySubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SharedGalleriesClientListPager provides operations for iterating over paged responses.
type SharedGalleriesClientListPager struct {
	client    *SharedGalleriesClient
	current   SharedGalleriesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SharedGalleriesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SharedGalleriesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SharedGalleryList.NextLink == nil || len(*p.current.SharedGalleryList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SharedGalleriesClientListPager) NextPage(ctx context.Context) (SharedGalleriesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SharedGalleriesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SharedGalleriesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SharedGalleriesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SharedGalleriesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return SharedGalleriesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SharedGalleryImageVersionsClientListPager provides operations for iterating over paged responses.
type SharedGalleryImageVersionsClientListPager struct {
	client    *SharedGalleryImageVersionsClient
	current   SharedGalleryImageVersionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SharedGalleryImageVersionsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SharedGalleryImageVersionsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SharedGalleryImageVersionList.NextLink == nil || len(*p.current.SharedGalleryImageVersionList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SharedGalleryImageVersionsClientListPager) NextPage(ctx context.Context) (SharedGalleryImageVersionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SharedGalleryImageVersionsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SharedGalleryImageVersionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SharedGalleryImageVersionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SharedGalleryImageVersionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return SharedGalleryImageVersionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SharedGalleryImagesClientListPager provides operations for iterating over paged responses.
type SharedGalleryImagesClientListPager struct {
	client    *SharedGalleryImagesClient
	current   SharedGalleryImagesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SharedGalleryImagesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SharedGalleryImagesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SharedGalleryImageList.NextLink == nil || len(*p.current.SharedGalleryImageList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SharedGalleryImagesClientListPager) NextPage(ctx context.Context) (SharedGalleryImagesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SharedGalleryImagesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SharedGalleryImagesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SharedGalleryImagesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SharedGalleryImagesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return SharedGalleryImagesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SnapshotsClientListByResourceGroupPager provides operations for iterating over paged responses.
type SnapshotsClientListByResourceGroupPager struct {
	client    *SnapshotsClient
	current   SnapshotsClientListByResourceGroupResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SnapshotsClientListByResourceGroupResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SnapshotsClientListByResourceGroupPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SnapshotList.NextLink == nil || len(*p.current.SnapshotList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SnapshotsClientListByResourceGroupPager) NextPage(ctx context.Context) (SnapshotsClientListByResourceGroupResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SnapshotsClientListByResourceGroupResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SnapshotsClientListByResourceGroupResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SnapshotsClientListByResourceGroupResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SnapshotsClientListByResourceGroupResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByResourceGroupHandleResponse(resp)
	if err != nil {
		return SnapshotsClientListByResourceGroupResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// SnapshotsClientListPager provides operations for iterating over paged responses.
type SnapshotsClientListPager struct {
	client    *SnapshotsClient
	current   SnapshotsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, SnapshotsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *SnapshotsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.SnapshotList.NextLink == nil || len(*p.current.SnapshotList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *SnapshotsClientListPager) NextPage(ctx context.Context) (SnapshotsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return SnapshotsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return SnapshotsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return SnapshotsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return SnapshotsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return SnapshotsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// UsageClientListPager provides operations for iterating over paged responses.
type UsageClientListPager struct {
	client    *UsageClient
	current   UsageClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, UsageClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *UsageClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ListUsagesResult.NextLink == nil || len(*p.current.ListUsagesResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *UsageClientListPager) NextPage(ctx context.Context) (UsageClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return UsageClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return UsageClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return UsageClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return UsageClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return UsageClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachineRunCommandsClientListByVirtualMachinePager provides operations for iterating over paged responses.
type VirtualMachineRunCommandsClientListByVirtualMachinePager struct {
	client    *VirtualMachineRunCommandsClient
	current   VirtualMachineRunCommandsClientListByVirtualMachineResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineRunCommandsClientListByVirtualMachineResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachineRunCommandsClientListByVirtualMachinePager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineRunCommandsListResult.NextLink == nil || len(*p.current.VirtualMachineRunCommandsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachineRunCommandsClientListByVirtualMachinePager) NextPage(ctx context.Context) (VirtualMachineRunCommandsClientListByVirtualMachineResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachineRunCommandsClientListByVirtualMachineResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachineRunCommandsClientListByVirtualMachineResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachineRunCommandsClientListByVirtualMachineResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachineRunCommandsClientListByVirtualMachineResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByVirtualMachineHandleResponse(resp)
	if err != nil {
		return VirtualMachineRunCommandsClientListByVirtualMachineResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachineRunCommandsClientListPager provides operations for iterating over paged responses.
type VirtualMachineRunCommandsClientListPager struct {
	client    *VirtualMachineRunCommandsClient
	current   VirtualMachineRunCommandsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineRunCommandsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachineRunCommandsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.RunCommandListResult.NextLink == nil || len(*p.current.RunCommandListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachineRunCommandsClientListPager) NextPage(ctx context.Context) (VirtualMachineRunCommandsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachineRunCommandsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachineRunCommandsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachineRunCommandsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachineRunCommandsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualMachineRunCommandsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachineScaleSetExtensionsClientListPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetExtensionsClientListPager struct {
	client    *VirtualMachineScaleSetExtensionsClient
	current   VirtualMachineScaleSetExtensionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetExtensionsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachineScaleSetExtensionsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetExtensionListResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetExtensionListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachineScaleSetExtensionsClientListPager) NextPage(ctx context.Context) (VirtualMachineScaleSetExtensionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachineScaleSetExtensionsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachineScaleSetExtensionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachineScaleSetExtensionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachineScaleSetExtensionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualMachineScaleSetExtensionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachineScaleSetVMRunCommandsClientListPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetVMRunCommandsClientListPager struct {
	client    *VirtualMachineScaleSetVMRunCommandsClient
	current   VirtualMachineScaleSetVMRunCommandsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetVMRunCommandsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachineScaleSetVMRunCommandsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineRunCommandsListResult.NextLink == nil || len(*p.current.VirtualMachineRunCommandsListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachineScaleSetVMRunCommandsClientListPager) NextPage(ctx context.Context) (VirtualMachineScaleSetVMRunCommandsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachineScaleSetVMRunCommandsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachineScaleSetVMRunCommandsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachineScaleSetVMRunCommandsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachineScaleSetVMRunCommandsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualMachineScaleSetVMRunCommandsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachineScaleSetVMsClientListPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetVMsClientListPager struct {
	client    *VirtualMachineScaleSetVMsClient
	current   VirtualMachineScaleSetVMsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetVMsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachineScaleSetVMsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetVMListResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetVMListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachineScaleSetVMsClientListPager) NextPage(ctx context.Context) (VirtualMachineScaleSetVMsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachineScaleSetVMsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachineScaleSetVMsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachineScaleSetVMsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachineScaleSetVMsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualMachineScaleSetVMsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachineScaleSetsClientGetOSUpgradeHistoryPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetsClientGetOSUpgradeHistoryPager struct {
	client    *VirtualMachineScaleSetsClient
	current   VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachineScaleSetsClientGetOSUpgradeHistoryPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetListOSUpgradeHistory.NextLink == nil || len(*p.current.VirtualMachineScaleSetListOSUpgradeHistory.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachineScaleSetsClientGetOSUpgradeHistoryPager) NextPage(ctx context.Context) (VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.getOSUpgradeHistoryHandleResponse(resp)
	if err != nil {
		return VirtualMachineScaleSetsClientGetOSUpgradeHistoryResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachineScaleSetsClientListAllPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetsClientListAllPager struct {
	client    *VirtualMachineScaleSetsClient
	current   VirtualMachineScaleSetsClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetsClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachineScaleSetsClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetListWithLinkResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetListWithLinkResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachineScaleSetsClientListAllPager) NextPage(ctx context.Context) (VirtualMachineScaleSetsClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachineScaleSetsClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachineScaleSetsClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachineScaleSetsClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachineScaleSetsClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return VirtualMachineScaleSetsClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachineScaleSetsClientListByLocationPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetsClientListByLocationPager struct {
	client    *VirtualMachineScaleSetsClient
	current   VirtualMachineScaleSetsClientListByLocationResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetsClientListByLocationResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachineScaleSetsClientListByLocationPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetListResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachineScaleSetsClientListByLocationPager) NextPage(ctx context.Context) (VirtualMachineScaleSetsClientListByLocationResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachineScaleSetsClientListByLocationResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachineScaleSetsClientListByLocationResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachineScaleSetsClientListByLocationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachineScaleSetsClientListByLocationResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		return VirtualMachineScaleSetsClientListByLocationResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachineScaleSetsClientListPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetsClientListPager struct {
	client    *VirtualMachineScaleSetsClient
	current   VirtualMachineScaleSetsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachineScaleSetsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetListResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachineScaleSetsClientListPager) NextPage(ctx context.Context) (VirtualMachineScaleSetsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachineScaleSetsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachineScaleSetsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachineScaleSetsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachineScaleSetsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualMachineScaleSetsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachineScaleSetsClientListSKUsPager provides operations for iterating over paged responses.
type VirtualMachineScaleSetsClientListSKUsPager struct {
	client    *VirtualMachineScaleSetsClient
	current   VirtualMachineScaleSetsClientListSKUsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachineScaleSetsClientListSKUsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachineScaleSetsClientListSKUsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineScaleSetListSKUsResult.NextLink == nil || len(*p.current.VirtualMachineScaleSetListSKUsResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachineScaleSetsClientListSKUsPager) NextPage(ctx context.Context) (VirtualMachineScaleSetsClientListSKUsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachineScaleSetsClientListSKUsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachineScaleSetsClientListSKUsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachineScaleSetsClientListSKUsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachineScaleSetsClientListSKUsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listSKUsHandleResponse(resp)
	if err != nil {
		return VirtualMachineScaleSetsClientListSKUsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachineSizesClientListPager provides operations for iterating over paged responses.
type VirtualMachineSizesClientListPager struct {
	client    *VirtualMachineSizesClient
	current   VirtualMachineSizesClientListResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachineSizesClientListPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *VirtualMachineSizesClientListPager) NextPage(ctx context.Context) (VirtualMachineSizesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return VirtualMachineSizesClientListResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachineSizesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachineSizesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachineSizesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualMachineSizesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachinesClientListAllPager provides operations for iterating over paged responses.
type VirtualMachinesClientListAllPager struct {
	client    *VirtualMachinesClient
	current   VirtualMachinesClientListAllResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachinesClientListAllResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachinesClientListAllPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineListResult.NextLink == nil || len(*p.current.VirtualMachineListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachinesClientListAllPager) NextPage(ctx context.Context) (VirtualMachinesClientListAllResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachinesClientListAllResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachinesClientListAllResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachinesClientListAllResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachinesClientListAllResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAllHandleResponse(resp)
	if err != nil {
		return VirtualMachinesClientListAllResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachinesClientListAvailableSizesPager provides operations for iterating over paged responses.
type VirtualMachinesClientListAvailableSizesPager struct {
	client    *VirtualMachinesClient
	current   VirtualMachinesClientListAvailableSizesResponse
	requester func(context.Context) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachinesClientListAvailableSizesPager) More() bool {
	return reflect.ValueOf(p.current).IsZero()
}

// NextPage advances the pager to the next page.
func (p *VirtualMachinesClientListAvailableSizesPager) NextPage(ctx context.Context) (VirtualMachinesClientListAvailableSizesResponse, error) {
	var req *policy.Request
	var err error
	if !p.More() {
		return VirtualMachinesClientListAvailableSizesResponse{}, errors.New("no more pages")
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachinesClientListAvailableSizesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachinesClientListAvailableSizesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachinesClientListAvailableSizesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listAvailableSizesHandleResponse(resp)
	if err != nil {
		return VirtualMachinesClientListAvailableSizesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachinesClientListByLocationPager provides operations for iterating over paged responses.
type VirtualMachinesClientListByLocationPager struct {
	client    *VirtualMachinesClient
	current   VirtualMachinesClientListByLocationResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachinesClientListByLocationResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachinesClientListByLocationPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineListResult.NextLink == nil || len(*p.current.VirtualMachineListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachinesClientListByLocationPager) NextPage(ctx context.Context) (VirtualMachinesClientListByLocationResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachinesClientListByLocationResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachinesClientListByLocationResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachinesClientListByLocationResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachinesClientListByLocationResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listByLocationHandleResponse(resp)
	if err != nil {
		return VirtualMachinesClientListByLocationResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachinesClientListPager provides operations for iterating over paged responses.
type VirtualMachinesClientListPager struct {
	client    *VirtualMachinesClient
	current   VirtualMachinesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachinesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachinesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachineListResult.NextLink == nil || len(*p.current.VirtualMachineListResult.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachinesClientListPager) NextPage(ctx context.Context) (VirtualMachinesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachinesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachinesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachinesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachinesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualMachinesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}
