//go:build go1.16
// +build go1.16

// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for license information.
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is regenerated.

package armavs

import (
	"context"
	"errors"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/policy"
	"github.com/Azure/azure-sdk-for-go/sdk/azcore/runtime"
	"net/http"
	"reflect"
)

// AddonsClientListPager provides operations for iterating over paged responses.
type AddonsClientListPager struct {
	client    *AddonsClient
	current   AddonsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AddonsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AddonsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.AddonList.NextLink == nil || len(*p.current.AddonList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AddonsClientListPager) NextPage(ctx context.Context) (AddonsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AddonsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AddonsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AddonsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AddonsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return AddonsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// AuthorizationsClientListPager provides operations for iterating over paged responses.
type AuthorizationsClientListPager struct {
	client    *AuthorizationsClient
	current   AuthorizationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, AuthorizationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *AuthorizationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ExpressRouteAuthorizationList.NextLink == nil || len(*p.current.ExpressRouteAuthorizationList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *AuthorizationsClientListPager) NextPage(ctx context.Context) (AuthorizationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return AuthorizationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return AuthorizationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return AuthorizationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return AuthorizationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return AuthorizationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// CloudLinksClientListPager provides operations for iterating over paged responses.
type CloudLinksClientListPager struct {
	client    *CloudLinksClient
	current   CloudLinksClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, CloudLinksClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *CloudLinksClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.CloudLinkList.NextLink == nil || len(*p.current.CloudLinkList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *CloudLinksClientListPager) NextPage(ctx context.Context) (CloudLinksClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return CloudLinksClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return CloudLinksClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return CloudLinksClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return CloudLinksClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return CloudLinksClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ClustersClientListPager provides operations for iterating over paged responses.
type ClustersClientListPager struct {
	client    *ClustersClient
	current   ClustersClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ClustersClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ClustersClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ClusterList.NextLink == nil || len(*p.current.ClusterList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ClustersClientListPager) NextPage(ctx context.Context) (ClustersClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ClustersClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ClustersClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ClustersClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ClustersClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ClustersClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// DatastoresClientListPager provides operations for iterating over paged responses.
type DatastoresClientListPager struct {
	client    *DatastoresClient
	current   DatastoresClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, DatastoresClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *DatastoresClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.DatastoreList.NextLink == nil || len(*p.current.DatastoreList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *DatastoresClientListPager) NextPage(ctx context.Context) (DatastoresClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return DatastoresClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return DatastoresClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return DatastoresClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return DatastoresClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return DatastoresClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// GlobalReachConnectionsClientListPager provides operations for iterating over paged responses.
type GlobalReachConnectionsClientListPager struct {
	client    *GlobalReachConnectionsClient
	current   GlobalReachConnectionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, GlobalReachConnectionsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *GlobalReachConnectionsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.GlobalReachConnectionList.NextLink == nil || len(*p.current.GlobalReachConnectionList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *GlobalReachConnectionsClientListPager) NextPage(ctx context.Context) (GlobalReachConnectionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return GlobalReachConnectionsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return GlobalReachConnectionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return GlobalReachConnectionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return GlobalReachConnectionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return GlobalReachConnectionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// HcxEnterpriseSitesClientListPager provides operations for iterating over paged responses.
type HcxEnterpriseSitesClientListPager struct {
	client    *HcxEnterpriseSitesClient
	current   HcxEnterpriseSitesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, HcxEnterpriseSitesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *HcxEnterpriseSitesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.HcxEnterpriseSiteList.NextLink == nil || len(*p.current.HcxEnterpriseSiteList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *HcxEnterpriseSitesClientListPager) NextPage(ctx context.Context) (HcxEnterpriseSitesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return HcxEnterpriseSitesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return HcxEnterpriseSitesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return HcxEnterpriseSitesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return HcxEnterpriseSitesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return HcxEnterpriseSitesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// OperationsClientListPager provides operations for iterating over paged responses.
type OperationsClientListPager struct {
	client    *OperationsClient
	current   OperationsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, OperationsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *OperationsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.OperationList.NextLink == nil || len(*p.current.OperationList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *OperationsClientListPager) NextPage(ctx context.Context) (OperationsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return OperationsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return OperationsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return OperationsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PlacementPoliciesClientListPager provides operations for iterating over paged responses.
type PlacementPoliciesClientListPager struct {
	client    *PlacementPoliciesClient
	current   PlacementPoliciesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PlacementPoliciesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PlacementPoliciesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PlacementPoliciesList.NextLink == nil || len(*p.current.PlacementPoliciesList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PlacementPoliciesClientListPager) NextPage(ctx context.Context) (PlacementPoliciesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PlacementPoliciesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PlacementPoliciesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PlacementPoliciesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PlacementPoliciesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return PlacementPoliciesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PrivateCloudsClientListInSubscriptionPager provides operations for iterating over paged responses.
type PrivateCloudsClientListInSubscriptionPager struct {
	client    *PrivateCloudsClient
	current   PrivateCloudsClientListInSubscriptionResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateCloudsClientListInSubscriptionResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PrivateCloudsClientListInSubscriptionPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateCloudList.NextLink == nil || len(*p.current.PrivateCloudList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PrivateCloudsClientListInSubscriptionPager) NextPage(ctx context.Context) (PrivateCloudsClientListInSubscriptionResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PrivateCloudsClientListInSubscriptionResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PrivateCloudsClientListInSubscriptionResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PrivateCloudsClientListInSubscriptionResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PrivateCloudsClientListInSubscriptionResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listInSubscriptionHandleResponse(resp)
	if err != nil {
		return PrivateCloudsClientListInSubscriptionResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// PrivateCloudsClientListPager provides operations for iterating over paged responses.
type PrivateCloudsClientListPager struct {
	client    *PrivateCloudsClient
	current   PrivateCloudsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, PrivateCloudsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *PrivateCloudsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.PrivateCloudList.NextLink == nil || len(*p.current.PrivateCloudList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *PrivateCloudsClientListPager) NextPage(ctx context.Context) (PrivateCloudsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return PrivateCloudsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return PrivateCloudsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return PrivateCloudsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return PrivateCloudsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return PrivateCloudsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ScriptCmdletsClientListPager provides operations for iterating over paged responses.
type ScriptCmdletsClientListPager struct {
	client    *ScriptCmdletsClient
	current   ScriptCmdletsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ScriptCmdletsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ScriptCmdletsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ScriptCmdletsList.NextLink == nil || len(*p.current.ScriptCmdletsList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ScriptCmdletsClientListPager) NextPage(ctx context.Context) (ScriptCmdletsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ScriptCmdletsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ScriptCmdletsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ScriptCmdletsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ScriptCmdletsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ScriptCmdletsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ScriptExecutionsClientListPager provides operations for iterating over paged responses.
type ScriptExecutionsClientListPager struct {
	client    *ScriptExecutionsClient
	current   ScriptExecutionsClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ScriptExecutionsClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ScriptExecutionsClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ScriptExecutionsList.NextLink == nil || len(*p.current.ScriptExecutionsList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ScriptExecutionsClientListPager) NextPage(ctx context.Context) (ScriptExecutionsClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ScriptExecutionsClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ScriptExecutionsClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ScriptExecutionsClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ScriptExecutionsClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ScriptExecutionsClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// ScriptPackagesClientListPager provides operations for iterating over paged responses.
type ScriptPackagesClientListPager struct {
	client    *ScriptPackagesClient
	current   ScriptPackagesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, ScriptPackagesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *ScriptPackagesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.ScriptPackagesList.NextLink == nil || len(*p.current.ScriptPackagesList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *ScriptPackagesClientListPager) NextPage(ctx context.Context) (ScriptPackagesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return ScriptPackagesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return ScriptPackagesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return ScriptPackagesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return ScriptPackagesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return ScriptPackagesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// VirtualMachinesClientListPager provides operations for iterating over paged responses.
type VirtualMachinesClientListPager struct {
	client    *VirtualMachinesClient
	current   VirtualMachinesClientListResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, VirtualMachinesClientListResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *VirtualMachinesClientListPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.VirtualMachinesList.NextLink == nil || len(*p.current.VirtualMachinesList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *VirtualMachinesClientListPager) NextPage(ctx context.Context) (VirtualMachinesClientListResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return VirtualMachinesClientListResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return VirtualMachinesClientListResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return VirtualMachinesClientListResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return VirtualMachinesClientListResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listHandleResponse(resp)
	if err != nil {
		return VirtualMachinesClientListResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkloadNetworksClientListDNSServicesPager provides operations for iterating over paged responses.
type WorkloadNetworksClientListDNSServicesPager struct {
	client    *WorkloadNetworksClient
	current   WorkloadNetworksClientListDNSServicesResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkloadNetworksClientListDNSServicesResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkloadNetworksClientListDNSServicesPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkloadNetworkDNSServicesList.NextLink == nil || len(*p.current.WorkloadNetworkDNSServicesList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WorkloadNetworksClientListDNSServicesPager) NextPage(ctx context.Context) (WorkloadNetworksClientListDNSServicesResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WorkloadNetworksClientListDNSServicesResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkloadNetworksClientListDNSServicesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkloadNetworksClientListDNSServicesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkloadNetworksClientListDNSServicesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listDNSServicesHandleResponse(resp)
	if err != nil {
		return WorkloadNetworksClientListDNSServicesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkloadNetworksClientListDNSZonesPager provides operations for iterating over paged responses.
type WorkloadNetworksClientListDNSZonesPager struct {
	client    *WorkloadNetworksClient
	current   WorkloadNetworksClientListDNSZonesResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkloadNetworksClientListDNSZonesResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkloadNetworksClientListDNSZonesPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkloadNetworkDNSZonesList.NextLink == nil || len(*p.current.WorkloadNetworkDNSZonesList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WorkloadNetworksClientListDNSZonesPager) NextPage(ctx context.Context) (WorkloadNetworksClientListDNSZonesResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WorkloadNetworksClientListDNSZonesResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkloadNetworksClientListDNSZonesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkloadNetworksClientListDNSZonesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkloadNetworksClientListDNSZonesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listDNSZonesHandleResponse(resp)
	if err != nil {
		return WorkloadNetworksClientListDNSZonesResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkloadNetworksClientListDhcpPager provides operations for iterating over paged responses.
type WorkloadNetworksClientListDhcpPager struct {
	client    *WorkloadNetworksClient
	current   WorkloadNetworksClientListDhcpResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkloadNetworksClientListDhcpResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkloadNetworksClientListDhcpPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkloadNetworkDhcpList.NextLink == nil || len(*p.current.WorkloadNetworkDhcpList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WorkloadNetworksClientListDhcpPager) NextPage(ctx context.Context) (WorkloadNetworksClientListDhcpResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WorkloadNetworksClientListDhcpResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkloadNetworksClientListDhcpResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkloadNetworksClientListDhcpResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkloadNetworksClientListDhcpResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listDhcpHandleResponse(resp)
	if err != nil {
		return WorkloadNetworksClientListDhcpResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkloadNetworksClientListGatewaysPager provides operations for iterating over paged responses.
type WorkloadNetworksClientListGatewaysPager struct {
	client    *WorkloadNetworksClient
	current   WorkloadNetworksClientListGatewaysResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkloadNetworksClientListGatewaysResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkloadNetworksClientListGatewaysPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkloadNetworkGatewayList.NextLink == nil || len(*p.current.WorkloadNetworkGatewayList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WorkloadNetworksClientListGatewaysPager) NextPage(ctx context.Context) (WorkloadNetworksClientListGatewaysResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WorkloadNetworksClientListGatewaysResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkloadNetworksClientListGatewaysResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkloadNetworksClientListGatewaysResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkloadNetworksClientListGatewaysResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listGatewaysHandleResponse(resp)
	if err != nil {
		return WorkloadNetworksClientListGatewaysResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkloadNetworksClientListPortMirroringPager provides operations for iterating over paged responses.
type WorkloadNetworksClientListPortMirroringPager struct {
	client    *WorkloadNetworksClient
	current   WorkloadNetworksClientListPortMirroringResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkloadNetworksClientListPortMirroringResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkloadNetworksClientListPortMirroringPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkloadNetworkPortMirroringList.NextLink == nil || len(*p.current.WorkloadNetworkPortMirroringList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WorkloadNetworksClientListPortMirroringPager) NextPage(ctx context.Context) (WorkloadNetworksClientListPortMirroringResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WorkloadNetworksClientListPortMirroringResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkloadNetworksClientListPortMirroringResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkloadNetworksClientListPortMirroringResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkloadNetworksClientListPortMirroringResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listPortMirroringHandleResponse(resp)
	if err != nil {
		return WorkloadNetworksClientListPortMirroringResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkloadNetworksClientListPublicIPsPager provides operations for iterating over paged responses.
type WorkloadNetworksClientListPublicIPsPager struct {
	client    *WorkloadNetworksClient
	current   WorkloadNetworksClientListPublicIPsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkloadNetworksClientListPublicIPsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkloadNetworksClientListPublicIPsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkloadNetworkPublicIPsList.NextLink == nil || len(*p.current.WorkloadNetworkPublicIPsList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WorkloadNetworksClientListPublicIPsPager) NextPage(ctx context.Context) (WorkloadNetworksClientListPublicIPsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WorkloadNetworksClientListPublicIPsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkloadNetworksClientListPublicIPsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkloadNetworksClientListPublicIPsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkloadNetworksClientListPublicIPsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listPublicIPsHandleResponse(resp)
	if err != nil {
		return WorkloadNetworksClientListPublicIPsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkloadNetworksClientListSegmentsPager provides operations for iterating over paged responses.
type WorkloadNetworksClientListSegmentsPager struct {
	client    *WorkloadNetworksClient
	current   WorkloadNetworksClientListSegmentsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkloadNetworksClientListSegmentsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkloadNetworksClientListSegmentsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkloadNetworkSegmentsList.NextLink == nil || len(*p.current.WorkloadNetworkSegmentsList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WorkloadNetworksClientListSegmentsPager) NextPage(ctx context.Context) (WorkloadNetworksClientListSegmentsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WorkloadNetworksClientListSegmentsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkloadNetworksClientListSegmentsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkloadNetworksClientListSegmentsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkloadNetworksClientListSegmentsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listSegmentsHandleResponse(resp)
	if err != nil {
		return WorkloadNetworksClientListSegmentsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkloadNetworksClientListVMGroupsPager provides operations for iterating over paged responses.
type WorkloadNetworksClientListVMGroupsPager struct {
	client    *WorkloadNetworksClient
	current   WorkloadNetworksClientListVMGroupsResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkloadNetworksClientListVMGroupsResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkloadNetworksClientListVMGroupsPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkloadNetworkVMGroupsList.NextLink == nil || len(*p.current.WorkloadNetworkVMGroupsList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WorkloadNetworksClientListVMGroupsPager) NextPage(ctx context.Context) (WorkloadNetworksClientListVMGroupsResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WorkloadNetworksClientListVMGroupsResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkloadNetworksClientListVMGroupsResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkloadNetworksClientListVMGroupsResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkloadNetworksClientListVMGroupsResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listVMGroupsHandleResponse(resp)
	if err != nil {
		return WorkloadNetworksClientListVMGroupsResponse{}, err
	}
	p.current = result
	return p.current, nil
}

// WorkloadNetworksClientListVirtualMachinesPager provides operations for iterating over paged responses.
type WorkloadNetworksClientListVirtualMachinesPager struct {
	client    *WorkloadNetworksClient
	current   WorkloadNetworksClientListVirtualMachinesResponse
	requester func(context.Context) (*policy.Request, error)
	advancer  func(context.Context, WorkloadNetworksClientListVirtualMachinesResponse) (*policy.Request, error)
}

// More returns true if there are more pages to retrieve.
func (p *WorkloadNetworksClientListVirtualMachinesPager) More() bool {
	if !reflect.ValueOf(p.current).IsZero() {
		if p.current.WorkloadNetworkVirtualMachinesList.NextLink == nil || len(*p.current.WorkloadNetworkVirtualMachinesList.NextLink) == 0 {
			return false
		}
	}
	return true
}

// NextPage advances the pager to the next page.
func (p *WorkloadNetworksClientListVirtualMachinesPager) NextPage(ctx context.Context) (WorkloadNetworksClientListVirtualMachinesResponse, error) {
	var req *policy.Request
	var err error
	if !reflect.ValueOf(p.current).IsZero() {
		if !p.More() {
			return WorkloadNetworksClientListVirtualMachinesResponse{}, errors.New("no more pages")
		}
		req, err = p.advancer(ctx, p.current)
	} else {
		req, err = p.requester(ctx)
	}
	if err != nil {
		return WorkloadNetworksClientListVirtualMachinesResponse{}, err
	}
	resp, err := p.client.pl.Do(req)
	if err != nil {
		return WorkloadNetworksClientListVirtualMachinesResponse{}, err
	}
	if !runtime.HasStatusCode(resp, http.StatusOK) {

		return WorkloadNetworksClientListVirtualMachinesResponse{}, runtime.NewResponseError(resp)
	}
	result, err := p.client.listVirtualMachinesHandleResponse(resp)
	if err != nil {
		return WorkloadNetworksClientListVirtualMachinesResponse{}, err
	}
	p.current = result
	return p.current, nil
}
